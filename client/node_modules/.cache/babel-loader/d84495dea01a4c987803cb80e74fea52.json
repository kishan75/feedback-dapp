{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Abi = exports.ConstructorEntry = exports.FallbackEntry = exports.ReceiveEntry = exports.FunctionEntry = exports.ErrorEntry = exports.EventEntry = exports.EventParameter = exports.Parameter = void 0;\n\nconst fc = __importStar(require(\"fast-check\"));\n\nconst faker_1 = __importDefault(require(\"faker\"));\n\nconst change_case_1 = require(\"change-case\");\n\nconst Parameter = () => fc.tuple(fc.record({\n  name: ParameterName()\n}), TypeRecord()).map(([{\n  name\n}, type]) => Object.assign({\n  name\n}, type));\n\nexports.Parameter = Parameter;\n\nconst EventParameter = () => fc.tuple(fc.record({\n  name: ParameterName(),\n  indexed: fc.boolean()\n}), TypeRecord()).map(([{\n  name,\n  indexed\n}, type]) => Object.assign({\n  name,\n  indexed\n}, type));\n\nexports.EventParameter = EventParameter;\n\nconst EventEntry = () => fc.record({\n  type: fc.constant(\"event\"),\n  name: EventName(),\n  inputs: fc.array(exports.EventParameter(), {\n    maxLength: 10\n  }).filter(inputs => {\n    if (inputs.filter(({\n      indexed\n    }) => indexed).length > 3) {\n      // only up to 3 params can be indexed\n      return false;\n    } // names that are not blank should be unique\n\n\n    const names = inputs.map(({\n      name\n    }) => name).filter(name => name !== \"\");\n    return names.length === new Set(names).size;\n  }),\n  anonymous: fc.boolean()\n});\n\nexports.EventEntry = EventEntry;\n\nconst ErrorEntry = () => fc.record({\n  type: fc.constant(\"error\"),\n  name: ErrorName(),\n  inputs: fc.array(exports.Parameter(), {\n    maxLength: 10\n  }).filter(inputs => {\n    // names that are not blank should be unique\n    const names = inputs.map(({\n      name\n    }) => name).filter(name => name !== \"\");\n    return names.length === new Set(names).size;\n  })\n});\n\nexports.ErrorEntry = ErrorEntry;\n\nconst FunctionEntry = () => fc.tuple(fc.record({\n  type: fc.constant(\"function\")\n}, {\n  withDeletedKeys: true\n}), fc.record({\n  name: FunctionName(),\n  inputs: fc.array(exports.Parameter(), {\n    maxLength: 10\n  })\n}), fc.record({\n  outputs: fc.array(exports.Parameter(), {\n    maxLength: 10\n  })\n}, {\n  withDeletedKeys: true\n}), fc.tuple(fc.oneof(fc.constant(\"pure\"), fc.constant(\"view\"), fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean()).map(([stateMutability, includeLegacy, includeModern]) => {\n  const payable = stateMutability === \"payable\";\n  const constant = stateMutability === \"view\" || stateMutability === \"pure\";\n  const modern = {\n    stateMutability\n  };\n  const legacy = {\n    payable,\n    constant\n  };\n  return includeLegacy && includeModern ? Object.assign(Object.assign({}, modern), legacy) : includeModern ? modern : legacy;\n})).map(records => records.reduce((a, b) => Object.assign(Object.assign({}, a), b), {})).filter(entry => {\n  const inputs = entry.inputs,\n        _entry$outputs = entry.outputs,\n        outputs = _entry$outputs === void 0 ? [] : _entry$outputs; // names that are not blank should be unique\n\n  const names = [...inputs, ...outputs].map(({\n    name\n  }) => name).filter(name => name !== \"\");\n  return names.length === new Set(names).size;\n});\n\nexports.FunctionEntry = FunctionEntry;\n\nconst ReceiveEntry = () => fc.record({\n  type: fc.constant(\"receive\"),\n  stateMutability: fc.constant(\"payable\")\n});\n\nexports.ReceiveEntry = ReceiveEntry;\n\nconst FallbackEntry = () => fc.tuple(fc.record({\n  type: fc.constant(\"fallback\")\n}), fc.tuple(fc.oneof(fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean()).map(([stateMutability, includeLegacy, includeModern]) => {\n  const payable = stateMutability === \"payable\";\n  const modern = {\n    stateMutability\n  };\n  const legacy = {\n    payable\n  };\n  return includeLegacy && includeModern ? Object.assign(Object.assign({}, modern), legacy) : includeModern ? modern : legacy;\n})).map(([{\n  type\n}, mutabilityFields]) => Object.assign({\n  type\n}, mutabilityFields));\n\nexports.FallbackEntry = FallbackEntry;\n\nconst ConstructorEntry = () => fc.tuple(fc.record({\n  type: fc.constant(\"constructor\"),\n  inputs: fc.array(exports.Parameter(), {\n    maxLength: 10\n  }).filter(inputs => {\n    // names that are not blank should be unique\n    const names = inputs.map(({\n      name\n    }) => name).filter(name => name !== \"\");\n    return names.length === new Set(names).size;\n  })\n}), fc.tuple(fc.oneof(fc.constant(\"nonpayable\"), fc.constant(\"payable\")), fc.boolean(), fc.boolean()).map(([stateMutability, includeLegacy, includeModern]) => {\n  const payable = stateMutability === \"payable\";\n  const modern = {\n    stateMutability\n  };\n  const legacy = {\n    payable\n  };\n  return includeLegacy && includeModern ? Object.assign(Object.assign({}, modern), legacy) : includeModern ? modern : legacy;\n})).map(([{\n  type,\n  inputs\n}, mutabilityFields]) => Object.assign({\n  type,\n  inputs\n}, mutabilityFields));\n\nexports.ConstructorEntry = ConstructorEntry;\n\nconst Abi = () => fc.tuple(exports.ConstructorEntry(), exports.FallbackEntry(), exports.ReceiveEntry(), fc.array(fc.oneof(exports.FunctionEntry(), exports.EventEntry(), exports.ErrorEntry()))).chain(([constructor, fallback, receive, entries]) => fc.shuffledSubarray([constructor, fallback, receive, ...entries]));\n\nexports.Abi = Abi;\nvar Numerics;\n\n(function (Numerics) {\n  // 0 < n <= 32\n  // use subtraction so that fast-check treats 32 as simpler than 1\n  Numerics.Bytes = () => fc.nat(31).map(k => 32 - k); // 0 < n <= 256, 8 | n\n\n\n  Numerics.Bits = () => Numerics.Bytes().map(k => 8 * k); // 0 < n <= 80\n  // use fancy math so that fast-check treats 18 as the simplest case\n  //\n  //     0 ----------------- 79\n  //     lines up as:\n  //     18 ------ 80, 0 --- 17\n\n\n  Numerics.DecimalPlaces = () => fc.nat(79).map(k => (k + 17) % 80 + 1);\n\n  Numerics.Precision = () => fc.tuple(Numerics.Bits(), Numerics.DecimalPlaces());\n})(Numerics || (Numerics = {}));\n\nvar Primitives;\n\n(function (Primitives) {\n  Primitives.Uint = () => Numerics.Bits().map(m => \"uint\".concat(m));\n\n  Primitives.Int = () => Numerics.Bits().map(m => \"int\".concat(m));\n\n  Primitives.Address = () => fc.constant(\"address\");\n\n  Primitives.Bool = () => fc.constant(\"bool\");\n\n  Primitives.Fixed = () => Numerics.Precision().map(([m, n]) => \"fixed\".concat(m, \"x\").concat(n));\n\n  Primitives.Ufixed = () => Numerics.Precision().map(([m, n]) => \"ufixed\".concat(m, \"x\").concat(n));\n\n  Primitives.BytesM = () => Numerics.Bytes().map(m => \"bytes\".concat(m));\n\n  Primitives.Function = () => fc.constant(\"function\");\n\n  Primitives.Bytes = () => fc.constant(\"bytes\");\n\n  Primitives.String = () => fc.constant(\"string\");\n\n  Primitives.Tuple = () => fc.constant(\"tuple\");\n})(Primitives || (Primitives = {}));\n\nconst Primitive = () => fc.oneof(Primitives.Uint(), Primitives.Int(), Primitives.Address(), Primitives.Bool(), Primitives.Fixed(), Primitives.Ufixed(), Primitives.BytesM(), Primitives.Function(), Primitives.Bytes(), Primitives.String(), Primitives.Tuple());\n\nconst Type = fc.memo(n => n === 0 ? Primitive() : // we cap this at 3 so that fast-check doesn't blow the stack\nfc.oneof(Primitive(), ArrayFixed(n > 3 ? 3 : n), ArrayDynamic(n)));\nconst ArrayFixed = fc.memo(n => fc.tuple(Type(n - 1), fc.integer(1, 256)).map(([type, length]) => \"\".concat(type, \"[\").concat(length, \"]\")));\nconst ArrayDynamic = fc.memo(n => Type(n - 1).map(type => \"\".concat(type, \"[]\")));\nconst reservedWords = new Set([\"Error\", \"Panic\", \"_\", \"abi\", \"abstract\", \"addmod\", \"address\", \"after\", \"alias\", \"anonymous\", \"apply\", \"as\", \"assembly\", \"assert\", \"auto\", \"block\", \"blockhash\", \"bool\", \"break\", \"byte\", \"bytes\", \"calldata\", \"case\", \"catch\", \"constant\", \"constructor\", \"continue\", \"contract\", \"copyof\", \"days\", \"default\", \"define\", \"delete\", \"ecrecover\", \"else\", \"emit\", \"enum\", \"error\", \"ether\", \"event\", \"external\", \"fallback\", \"false\", \"final\", \"finney\", \"fixed\", \"for\", \"from\", \"function\", \"gasleft\", \"gwei\", \"hours\", \"if\", \"immutable\", \"implements\", \"import\", \"in\", \"indexed\", \"inline\", \"int\", \"interface\", \"internal\", \"is\", \"keccak256\", \"let\", \"library\", \"log0\", \"log1\", \"log2\", \"log3\", \"log4\", \"macro\", \"mapping\", \"match\", \"memory\", \"minutes\", \"modifier\", \"msg\", \"mulmod\", \"mutable\", \"new\", \"now\", \"null\", \"of\", \"override\", \"partial\", \"payable\", \"pragma\", \"private\", \"promise\", \"public\", \"pure\", \"receive\", \"reference\", \"relocatable\", \"require\", \"return\", \"returns\", \"revert\", \"ripemd160\", \"sealed\", \"seconds\", \"selfdestruct\", \"sha256\", \"sha3\", \"sizeof\", \"static\", \"storage\", \"string\", \"struct\", \"suicide\", \"super\", \"supports\", \"switch\", \"szabo\", \"this\", \"throw\", \"true\", \"try\", \"tx\", \"type\", \"typedef\", \"typeof\", \"ufixed\", \"uint\", \"unchecked\", \"using\", \"var\", \"view\", \"virtual\", \"weeks\", \"wei\", \"while\", \"years\"]); // borrowed from https://runkit.com/dubzzz/faker-to-fast-check\n\nconst fakerToArb = (template, transform = change_case_1.camelCase) => {\n  return fc.integer().noBias().noShrink().map(seed => {\n    faker_1.default.seed(seed);\n    return transform(faker_1.default.fake(template));\n  }).filter(word => !reservedWords.has(word));\n};\n\nconst ParameterName = () => fc.frequency({\n  arbitrary: fakerToArb(\"{{hacker.noun}}\"),\n  weight: 9\n}, {\n  arbitrary: fc.constant(\"\"),\n  weight: 1\n});\n\nconst EventName = () => fakerToArb(\"{{hacker.verb}} {{hacker.noun}}\", change_case_1.pascalCase);\n\nconst ErrorName = () => fakerToArb(\"{{hacker.noun}} {{hacker.noun}}\", change_case_1.pascalCase);\n\nconst FunctionName = () => fakerToArb(\"{{hacker.verb}} {{hacker.noun}}\");\n\nconst TypeRecord = () => Type().chain(type => type.startsWith(\"tuple\") ? fc.record({\n  type: fc.constant(type),\n  components: fc.array(exports.Parameter().filter(({\n    name\n  }) => name !== \"\"), {\n    minLength: 1,\n    maxLength: 5\n  }).filter(items => {\n    const names = items.map(({\n      name\n    }) => name).filter(name => name !== \"\");\n    return names.length === new Set(names).size;\n  })\n}) : fc.record({\n  type: fc.constant(type)\n}));","map":null,"metadata":{},"sourceType":"script"}