{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.checkPaddingLeft = exports.decodeExternalFunction = exports.decodeContract = exports.decodeBasic = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:basic:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Contexts = __importStar(require(\"../../contexts\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst errors_1 = require(\"../../errors\");\n\nconst allocate_1 = require(\"../allocate\");\n\nfunction* decodeBasic(dataType, pointer, info, options = {}) {\n  const state = info.state;\n  const strict = options.strictAbiMode; //if this is undefined it'll still be falsy so it's OK\n\n  const paddingMode = options.paddingMode || \"default\";\n  let bytes;\n  let rawBytes;\n\n  try {\n    bytes = yield* read_1.default(pointer, state);\n  } catch (error) {\n    debug(\"segfault, pointer %o, state: %O\", pointer, state);\n    return errors_1.handleDecodingError(dataType, error, strict);\n  }\n\n  rawBytes = bytes;\n  debug(\"type %O\", dataType);\n  debug(\"pointer %o\", pointer);\n\n  switch (dataType.typeClass) {\n    case \"userDefinedValueType\":\n      {\n        const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n\n        if (!fullType.underlyingType) {\n          const error = {\n            kind: \"UserDefinedTypeNotFoundError\",\n            type: fullType\n          };\n\n          if (strict || options.allowRetry) {\n            throw new errors_1.StopDecodingError(error, true); //note that we allow a retry if we couldn't locate the underlying type!\n          }\n\n          return {\n            type: fullType,\n            kind: \"error\",\n            error\n          };\n        }\n\n        const underlyingResult = yield* decodeBasic(fullType.underlyingType, pointer, info, options);\n\n        switch (underlyingResult.kind //yes this switch is a little unnecessary :P\n        ) {\n          case \"value\":\n            //wrap the value and return\n            return {\n              //no idea why need coercion here\n              type: fullType,\n              kind: \"value\",\n              value: underlyingResult\n            };\n\n          case \"error\":\n            //wrap the error and return an error result!\n            //this is inconsistent with how we handle other container types\n            //(structs, arrays, mappings), where having an error in one element\n            //does not cause an error in the whole thing, but to do that here\n            //would cause problems for the type system :-/\n            //so we'll just be inconsistent\n            return {\n              //TS is being bad again :-/\n              type: fullType,\n              kind: \"error\",\n              error: {\n                kind: \"WrappedError\",\n                error: underlyingResult\n              }\n            };\n        }\n\n        break; //to satisfy TS :P\n      }\n\n    case \"bool\":\n      {\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"BoolPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n\n        bytes = removePadding(bytes, dataType, paddingMode); //note: the use of the BN is a little silly here,\n        //but, kind of stuck with it for now\n\n        const numeric = Conversion.toBN(bytes);\n\n        if (numeric.eqn(0)) {\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: false\n            }\n          };\n        } else if (numeric.eqn(1)) {\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          };\n        } else {\n          let error = {\n            kind: \"BoolOutOfRangeError\",\n            rawAsBN: numeric\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n      }\n\n    case \"uint\":\n      //first, check padding (if needed)\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"UintPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      } //now, truncate to appropriate length\n\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asBN: Conversion.toBN(bytes),\n          rawAsBN: Conversion.toBN(rawBytes)\n        }\n      };\n\n    case \"int\":\n      //first, check padding (if needed)\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"IntPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      } //now, truncate to appropriate length (keeping the bytes on the right)\n\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asBN: Conversion.toSignedBN(bytes),\n          rawAsBN: Conversion.toSignedBN(rawBytes)\n        }\n      };\n\n    case \"address\":\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"AddressPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      }\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: {\n          asAddress: Evm.Utils.toAddress(bytes),\n          rawAsHex: Conversion.toHexString(rawBytes)\n        }\n      };\n\n    case \"contract\":\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"ContractPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      }\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n      const contractValueInfo = yield* decodeContract(bytes, info);\n      return {\n        type: fullType,\n        kind: \"value\",\n        value: contractValueInfo\n      };\n\n    case \"bytes\":\n      //NOTE: we assume this is a *static* bytestring,\n      //because this is decodeBasic! dynamic ones should\n      //go to decodeBytes!\n      let coercedDataType = dataType; //first, check padding (if needed)\n\n      if (!checkPadding(bytes, dataType, paddingMode)) {\n        let error = {\n          kind: \"BytesPaddingError\",\n          paddingType: getPaddingType(dataType, paddingMode),\n          raw: Conversion.toHexString(bytes)\n        };\n\n        if (strict) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: coercedDataType,\n          kind: \"error\",\n          error\n        };\n      } //now, truncate to appropriate length\n\n\n      bytes = removePadding(bytes, dataType, paddingMode);\n      return {\n        type: coercedDataType,\n        kind: \"value\",\n        value: {\n          asHex: Conversion.toHexString(bytes),\n          rawAsHex: Conversion.toHexString(rawBytes)\n        }\n      };\n\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            const error = {\n              kind: \"FunctionExternalNonStackPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n\n          bytes = removePadding(bytes, dataType, paddingMode);\n          const address = bytes.slice(0, Evm.Utils.ADDRESS_SIZE);\n          const selector = bytes.slice(Evm.Utils.ADDRESS_SIZE, Evm.Utils.ADDRESS_SIZE + Evm.Utils.SELECTOR_SIZE);\n          return {\n            type: dataType,\n            kind: \"value\",\n            value: yield* decodeExternalFunction(address, selector, info)\n          };\n\n        case \"internal\":\n          //note: we used to error if we hit this point with strict === true,\n          //since internal function pointers don't go in the ABI, and strict\n          //mode is intended for ABI decoding.  however, there are times when\n          //we want to use strict mode to decode immutables, and immutables can\n          //include internal function pointers.  so now we allow this.  yes,\n          //this is a bit of an abuse of strict mode, which was after all meant\n          //for ABI decoding, but oh well.\n          if (!checkPadding(bytes, dataType, paddingMode)) {\n            const error = {\n              kind: \"FunctionInternalPaddingError\",\n              paddingType: getPaddingType(dataType, paddingMode),\n              raw: Conversion.toHexString(bytes)\n            };\n\n            if (strict) {\n              throw new errors_1.StopDecodingError(error);\n            }\n\n            return {\n              type: dataType,\n              kind: \"error\",\n              error\n            };\n          }\n\n          bytes = removePadding(bytes, dataType, paddingMode);\n          const deployedPc = bytes.slice(-Evm.Utils.PC_SIZE);\n          const constructorPc = bytes.slice(-Evm.Utils.PC_SIZE * 2, -Evm.Utils.PC_SIZE);\n          return decodeInternalFunction(dataType, deployedPc, constructorPc, info, strict);\n      }\n\n      break;\n    //to satisfy TypeScript\n\n    case \"enum\":\n      {\n        let numeric = Conversion.toBN(bytes);\n        const fullType = Format.Types.fullType(dataType, info.userDefinedTypes);\n\n        if (!fullType.options) {\n          let error = {\n            kind: \"EnumNotFoundDecodingError\",\n            type: fullType,\n            rawAsBN: numeric\n          };\n\n          if (strict || options.allowRetry) {\n            throw new errors_1.StopDecodingError(error, true); //note that we allow a retry if we couldn't locate the enum type!\n          }\n\n          return {\n            type: fullType,\n            kind: \"error\",\n            error\n          };\n        } //note: I'm doing the padding checks a little more manually on this one\n        //so that we can have the right type of error\n\n\n        const numOptions = fullType.options.length;\n        const numBytes = Math.ceil(Math.log2(numOptions) / 8);\n        const paddingType = getPaddingType(dataType, paddingMode);\n\n        if (!checkPaddingDirect(bytes, numBytes, paddingType)) {\n          let error = {\n            kind: \"EnumPaddingError\",\n            type: fullType,\n            paddingType,\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        }\n\n        bytes = removePaddingDirect(bytes, numBytes, paddingType);\n        numeric = Conversion.toBN(bytes); //alter numeric!\n\n        if (numeric.ltn(numOptions)) {\n          const name = fullType.options[numeric.toNumber()]; //NOTE: despite the use of toNumber(), I'm NOT catching exceptions here and returning an\n          //error value like elsewhere; I'm just letting this one fail.  Why?  Because if we have\n          //an enum with that many options in the first place, we have bigger problems!\n\n          return {\n            type: fullType,\n            kind: \"value\",\n            value: {\n              name,\n              numericAsBN: numeric\n            }\n          };\n        } else {\n          let error = {\n            kind: \"EnumOutOfRangeError\",\n            type: fullType,\n            rawAsBN: numeric\n          };\n\n          if (strict) {\n            //note:\n            //if the enum is merely out of range rather than out of the ABI range,\n            //we do NOT throw an error here!  instead we simply return an error value,\n            //which we normally avoid doing in strict mode.  (the error will be caught\n            //later at the re-encoding step instead.)  why?  because we might be running\n            //in ABI mode, so we may need to abify this \"value\" rather than just throwing\n            //it out.\n            throw new errors_1.StopDecodingError(error); //note that we do NOT allow a retry here!\n            //if we *can* find the enum type but the value is out of range,\n            //we *know* that it is invalid!\n          }\n\n          return {\n            type: fullType,\n            kind: \"error\",\n            error\n          };\n        }\n      }\n\n    case \"fixed\":\n      {\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"FixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        } //now, truncate to appropriate length (keeping the bytes on the right)\n\n\n        bytes = removePadding(bytes, dataType, paddingMode);\n        let asBN = Conversion.toSignedBN(bytes);\n        let rawAsBN = Conversion.toSignedBN(rawBytes);\n        let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n        let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asBig,\n            rawAsBig\n          }\n        };\n      }\n\n    case \"ufixed\":\n      {\n        //first, check padding (if needed)\n        if (!checkPadding(bytes, dataType, paddingMode)) {\n          let error = {\n            kind: \"UfixedPaddingError\",\n            paddingType: getPaddingType(dataType, paddingMode),\n            raw: Conversion.toHexString(bytes)\n          };\n\n          if (strict) {\n            throw new errors_1.StopDecodingError(error);\n          }\n\n          return {\n            type: dataType,\n            kind: \"error\",\n            error\n          };\n        } //now, truncate to appropriate length (keeping the bytes on the right)\n\n\n        bytes = removePadding(bytes, dataType, paddingMode);\n        let asBN = Conversion.toBN(bytes);\n        let rawAsBN = Conversion.toBN(rawBytes);\n        let asBig = Conversion.shiftBigDown(Conversion.toBig(asBN), dataType.places);\n        let rawAsBig = Conversion.shiftBigDown(Conversion.toBig(rawAsBN), dataType.places);\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: {\n            asBig,\n            rawAsBig\n          }\n        };\n      }\n  }\n}\n\nexports.decodeBasic = decodeBasic; //NOTE that this function returns a ContractValueInfo, not a ContractResult\n\nfunction* decodeContract(addressBytes, info) {\n  return (yield* decodeContractAndContext(addressBytes, info)).contractInfo;\n}\n\nexports.decodeContract = decodeContract;\n\nfunction* decodeContractAndContext(addressBytes, info) {\n  let address = Evm.Utils.toAddress(addressBytes);\n  let rawAddress = Conversion.toHexString(addressBytes);\n  let codeBytes = yield {\n    type: \"code\",\n    address\n  };\n  let code = Conversion.toHexString(codeBytes);\n  let context = Contexts.Utils.findContext(info.contexts, code);\n\n  if (context !== null) {\n    return {\n      context,\n      contractInfo: {\n        kind: \"known\",\n        address,\n        rawAddress,\n        class: Contexts.Import.contextToType(context)\n      }\n    };\n  } else {\n    return {\n      context,\n      contractInfo: {\n        kind: \"unknown\",\n        address,\n        rawAddress\n      }\n    };\n  }\n} //note: address can have extra zeroes on the left like elsewhere, but selector should be exactly 4 bytes\n//NOTE this again returns a FunctionExternalValueInfo, not a FunctionExternalResult\n\n\nfunction* decodeExternalFunction(addressBytes, selectorBytes, info) {\n  let _ref = yield* decodeContractAndContext(addressBytes, info),\n      contract = _ref.contractInfo,\n      context = _ref.context;\n\n  let selector = Conversion.toHexString(selectorBytes);\n\n  if (contract.kind === \"unknown\") {\n    return {\n      kind: \"unknown\",\n      contract,\n      selector\n    };\n  }\n\n  let abiEntry = context.abi !== undefined ? context.abi[selector] : undefined;\n\n  if (abiEntry === undefined) {\n    return {\n      kind: \"invalid\",\n      contract,\n      selector\n    };\n  }\n\n  return {\n    kind: \"known\",\n    contract,\n    selector,\n    abi: abiEntry\n  };\n}\n\nexports.decodeExternalFunction = decodeExternalFunction; //this one works a bit differently -- in order to handle errors, it *does* return a FunctionInternalResult\n\nfunction decodeInternalFunction(dataType, deployedPcBytes, constructorPcBytes, info, strict) {\n  const deployedPc = Conversion.toBN(deployedPcBytes).toNumber();\n  const constructorPc = Conversion.toBN(constructorPcBytes).toNumber();\n  const context = Contexts.Import.contextToType(info.currentContext); //before anything else: do we even have an internal functions table?\n  //if not, we'll just return the info we have without really attemting to decode\n\n  if (!info.internalFunctionsTable) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"unknown\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //also before we continue: is the PC zero? if so let's just return that\n\n\n  if (deployedPc === 0 && constructorPc === 0) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  } //another check: is only the deployed PC zero?\n\n\n  if (deployedPc === 0 && constructorPc !== 0) {\n    const error = {\n      kind: \"MalformedInternalFunctionError\",\n      context,\n      deployedProgramCounter: 0,\n      constructorProgramCounter: constructorPc\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  } //one last pre-check: is this a deployed-format pointer in a constructor?\n\n\n  if (info.currentContext.isConstructor && constructorPc === 0) {\n    const error = {\n      kind: \"DeployedFunctionInConstructorError\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: 0\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  } //otherwise, we get our function\n\n\n  const pc = info.currentContext.isConstructor ? constructorPc : deployedPc;\n  const functionEntry = info.internalFunctionsTable[pc];\n\n  if (!functionEntry) {\n    //if it's not zero and there's no entry... error!\n    const error = {\n      kind: \"NoSuchInternalFunctionError\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n\n  if (functionEntry.isDesignatedInvalid) {\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: {\n        kind: \"exception\",\n        context,\n        deployedProgramCounter: deployedPc,\n        constructorProgramCounter: constructorPc\n      }\n    };\n  }\n\n  const name = functionEntry.name;\n  const mutability = functionEntry.mutability;\n  const definedIn = Evm.Import.functionTableEntryToType(functionEntry); //may be null\n\n  const id = Evm.Import.makeInternalFunctionId(functionEntry);\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: {\n      kind: \"function\",\n      context,\n      deployedProgramCounter: deployedPc,\n      constructorProgramCounter: constructorPc,\n      name,\n      id,\n      definedIn,\n      mutability\n    }\n  };\n}\n\nfunction checkPadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  const length = allocate_1.byteLength(dataType, userDefinedTypes);\n  const paddingType = getPaddingType(dataType, paddingMode);\n\n  if (paddingMode === \"permissive\") {\n    switch (dataType.typeClass) {\n      case \"bool\":\n      case \"enum\":\n      case \"function\":\n        //these three types are checked even in permissive mode\n        return checkPaddingDirect(bytes, length, paddingType);\n\n      default:\n        return true;\n    }\n  } else {\n    return checkPaddingDirect(bytes, length, paddingType);\n  }\n}\n\nfunction removePadding(bytes, dataType, paddingMode, userDefinedTypes) {\n  const length = allocate_1.byteLength(dataType, userDefinedTypes);\n  const paddingType = getPaddingType(dataType, paddingMode);\n  return removePaddingDirect(bytes, length, paddingType);\n}\n\nfunction removePaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"right\":\n      return bytes.slice(0, length);\n\n    default:\n      return bytes.slice(-length);\n  }\n}\n\nfunction checkPaddingDirect(bytes, length, paddingType) {\n  switch (paddingType) {\n    case \"left\":\n      return checkPaddingLeft(bytes, length);\n\n    case \"right\":\n      return checkPaddingRight(bytes, length);\n\n    case \"signed\":\n      return checkPaddingSigned(bytes, length);\n\n    case \"signedOrLeft\":\n      return checkPaddingSigned(bytes, length) || checkPaddingLeft(bytes, length);\n  }\n}\n\nfunction getPaddingType(dataType, paddingMode) {\n  switch (paddingMode) {\n    case \"right\":\n      return \"right\";\n\n    case \"default\":\n    case \"permissive\":\n      return defaultPaddingType(dataType);\n\n    case \"zero\":\n      {\n        const defaultType = defaultPaddingType(dataType);\n        return defaultType === \"signed\" ? \"left\" : defaultType;\n      }\n\n    case \"defaultOrZero\":\n      {\n        const defaultType = defaultPaddingType(dataType);\n        return defaultType === \"signed\" ? \"signedOrLeft\" : defaultType;\n      }\n  }\n}\n\nfunction defaultPaddingType(dataType) {\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      return \"right\";\n\n    case \"int\":\n    case \"fixed\":\n      return \"signed\";\n\n    case \"function\":\n      if (dataType.visibility === \"external\") {\n        return \"right\";\n      }\n\n    //otherwise, fall through to default\n\n    default:\n      return \"left\";\n  }\n}\n\nfunction checkPaddingRight(bytes, length) {\n  let padding = bytes.slice(length); //cut off the first length bytes\n\n  return padding.every(paddingByte => paddingByte === 0);\n} //exporting this one for use in stack.ts\n\n\nfunction checkPaddingLeft(bytes, length) {\n  let padding = bytes.slice(0, -length); //cut off the last length bytes\n\n  return padding.every(paddingByte => paddingByte === 0);\n}\n\nexports.checkPaddingLeft = checkPaddingLeft;\n\nfunction checkPaddingSigned(bytes, length) {\n  let padding = bytes.slice(0, -length); //padding is all but the last length bytes\n\n  let value = bytes.slice(-length); //meanwhile the actual value is those last length bytes\n\n  let signByte = value[0] & 0x80 ? 0xff : 0x00;\n  return padding.every(paddingByte => paddingByte === signByte);\n}","map":null,"metadata":{},"sourceType":"script"}