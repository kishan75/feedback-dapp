{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"F:\\\\BlockChain\\\\Projects\\\\feedback-dapp\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getEventAllocations = exports.getReturndataAllocations = exports.getCalldataAllocations = exports.abiSizeInfo = exports.getAbiAllocations = exports.FallbackOutputAllocation = exports.Utils = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:allocate\");\nexports.Utils = __importStar(require(\"./utils\"));\n\nconst Import = __importStar(require(\"../import\"));\n\nconst AbiDataUtils = __importStar(require(\"../utils\"));\n\nconst Web3Utils = require(\"web3-utils\"); //sorry for untyped import\n\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst Common = __importStar(require(\"../../common\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Ast = __importStar(require(\"../../ast\"));\n\nconst import_1 = require(\"../../contexts/import\");\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst partition_1 = __importDefault(require(\"lodash/partition\"));\n\nexports.FallbackOutputAllocation = {\n  kind: \"returnmessage\",\n  selector: new Uint8Array(),\n  allocationMode: \"full\"\n};\n\nfunction getAbiAllocations(userDefinedTypes) {\n  let allocations = {};\n\n  for (const dataType of Object.values(userDefinedTypes)) {\n    if (dataType.typeClass === \"struct\") {\n      try {\n        allocations = allocateStruct(dataType, userDefinedTypes, allocations);\n      } catch (_) {//if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n        //note: a better way of handling this would probably be to *mark* it\n        //as failed rather than throwing an exception as that would lead to less\n        //recomputation, but this is simpler and I don't think the recomputation\n        //should really be a problem\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getAbiAllocations = getAbiAllocations;\n\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations);\n} //note: we will still allocate circular structs, even though they're not allowed in the abi, because it's\n//not worth the effort to detect them.  However on mappings or internal functions, we'll vomit (allocate null)\n\n\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations, start = 0) {\n  let dynamic = false; //note that we will mutate the start argument also!\n  //don't allocate things that have already been allocated\n\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n\n  let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n\n  let memberAllocations = [];\n\n  for (const member of members) {\n    let length;\n    let dynamicMember;\n\n    var _abiSizeAndAllocate = abiSizeAndAllocate(member.type, userDefinedTypes, allocations);\n\n    length = _abiSizeAndAllocate.size;\n    dynamicMember = _abiSizeAndAllocate.dynamic;\n    allocations = _abiSizeAndAllocate.allocations;\n\n    //vomit on illegal types in calldata -- note the short-circuit!\n    if (length === undefined) {\n      allocations[parentId] = null;\n      return allocations;\n    }\n\n    let pointer = {\n      location: \"abi\",\n      start,\n      length\n    };\n    memberAllocations.push({\n      name: member.name,\n      type: member.type,\n      pointer\n    });\n    start += length;\n    dynamic = dynamic || dynamicMember;\n  }\n\n  allocations[parentId] = {\n    members: memberAllocations,\n    length: dynamic ? Evm.Utils.WORD_SIZE : start,\n    dynamic\n  };\n  return allocations;\n} //first return value is the actual size.\n//second return value is whether the type is dynamic\n//both will be undefined if type is a mapping or internal function\n//third return value is resulting allocations, INCLUDING the ones passed in\n\n\nfunction abiSizeAndAllocate(dataType, userDefinedTypes, existingAllocations) {\n  switch (dataType.typeClass) {\n    case \"bool\":\n    case \"address\":\n    case \"contract\":\n    case \"int\":\n    case \"uint\":\n    case \"fixed\":\n    case \"ufixed\":\n    case \"enum\":\n    case \"userDefinedValueType\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: false,\n        allocations: existingAllocations\n      };\n\n    case \"string\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: true,\n        allocations: existingAllocations\n      };\n\n    case \"bytes\":\n      return {\n        size: Evm.Utils.WORD_SIZE,\n        dynamic: dataType.kind === \"dynamic\",\n        allocations: existingAllocations\n      };\n\n    case \"mapping\":\n      return {\n        allocations: existingAllocations\n      };\n\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            size: Evm.Utils.WORD_SIZE,\n            dynamic: false,\n            allocations: existingAllocations\n          };\n\n        case \"internal\":\n          return {\n            allocations: existingAllocations\n          };\n      }\n\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: Evm.Utils.WORD_SIZE,\n              dynamic: true,\n              allocations: existingAllocations\n            };\n\n          case \"static\":\n            if (dataType.length.isZero()) {\n              //arrays of length 0 are static regardless of base type\n              return {\n                size: 0,\n                dynamic: false,\n                allocations: existingAllocations\n              };\n            }\n\n            const _abiSizeAndAllocate2 = abiSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations),\n                  baseSize = _abiSizeAndAllocate2.size,\n                  dynamic = _abiSizeAndAllocate2.dynamic,\n                  allocations = _abiSizeAndAllocate2.allocations;\n\n            return {\n              //WARNING!  The use of toNumber() here may throw an exception!\n              //I'm judging this OK since if you have arrays that large we have bigger problems :P\n              size: dataType.length.toNumber() * baseSize,\n              dynamic,\n              allocations\n            };\n        }\n      }\n\n    case \"struct\":\n      {\n        let allocations = existingAllocations;\n        let allocation = allocations[dataType.id];\n\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          const storedType = userDefinedTypes[dataType.id];\n\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n\n          allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = allocations[storedType.id];\n        } //having found our allocation, if it's not null, we can just look up its size and dynamicity\n\n\n        if (allocation !== null) {\n          return {\n            size: allocation.length,\n            dynamic: allocation.dynamic,\n            allocations\n          };\n        } //if it is null, this type doesn't go in the abi\n        else {\n            return {\n              allocations\n            };\n          }\n      }\n\n    case \"tuple\":\n      {\n        //Warning! Yucky wasteful recomputation here!\n        let size = 0;\n        let dynamic = false; //note that we don't just invoke allocateStruct here!\n        //why not? because it has no ID to store the result in!\n        //and we can't use a fake like -1 because there might be a recursive call to it,\n        //and then the results would overwrite each other\n        //I mean, we could do some hashing thing or something, but I think it's easier to just\n        //copy the logic in this one case (sorry)\n\n        for (let member of dataType.memberTypes) {\n          let _abiSizeAndAllocate3 = abiSizeAndAllocate(member.type, userDefinedTypes, existingAllocations),\n              memberSize = _abiSizeAndAllocate3.size,\n              memberDynamic = _abiSizeAndAllocate3.dynamic;\n\n          size += memberSize;\n          dynamic = dynamic || memberDynamic;\n        }\n\n        return {\n          size,\n          dynamic,\n          allocations: existingAllocations\n        };\n      }\n  }\n} //assumes you've already done allocation! don't use if you haven't!\n\n/**\n * @protected\n */\n\n\nfunction abiSizeInfo(dataType, allocations) {\n  let _abiSizeAndAllocate4 = abiSizeAndAllocate(dataType, null, allocations),\n      size = _abiSizeAndAllocate4.size,\n      dynamic = _abiSizeAndAllocate4.dynamic; //the above line should work fine... as long as allocation is already done!\n  //the middle argument, userDefinedTypes, is only needed during allocation\n  //again, this function is only for use if allocation is done, so it's safe to pass null here\n\n\n  return {\n    size,\n    dynamic\n  };\n}\n\nexports.abiSizeInfo = abiSizeInfo; //allocates an external call\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n//NOTE: returns undefined if attempting to allocate a constructor but we don't have the\n//bytecode for the constructor\n\nfunction allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext) {\n  //first: determine the corresponding function node\n  //(simultaneously: determine the offset)\n  let node = undefined;\n  let inputParametersFull;\n  let outputParametersFull;\n  let inputParametersAbi;\n  let outputParametersAbi;\n  let offset; //refers to INPUT offset; output offset is always 0\n\n  debug(\"allocating calldata and returndata\");\n\n  switch (abiEntry.type) {\n    case \"constructor\":\n      if (!constructorContext) {\n        return undefined;\n      }\n\n      let rawLength = constructorContext.binary.length;\n      offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n      //for a constructor, we only want to search the particular contract\n\n      if (contractNode) {\n        node = contractNode.nodes.find(functionNode => AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a function node, but then it will\n        //return false (well, unless it's a getter node!)\n        abiEntry, functionNode, referenceDeclarations));\n      } //if we can't find it, we'll handle this below\n\n\n      break;\n\n    case \"function\":\n      offset = Evm.Utils.SELECTOR_SIZE; //search through base contracts, from most derived (left) to most base (right)\n\n      if (contractNode) {\n        const linearizedBaseContracts = contractNode.linearizedBaseContracts;\n        debug(\"linearized: %O\", linearizedBaseContracts);\n        node = findNodeAndContract(linearizedBaseContracts, referenceDeclarations, functionNode => AbiDataUtils.definitionMatchesAbi(abiEntry, functionNode, referenceDeclarations), contractNode).node; //may be undefined!  that's OK!\n\n        debug(\"found node: %o\", Boolean(node));\n      }\n\n      break;\n  } //now: get the parameters (both full-mode & ABI)\n\n\n  if (node) {\n    switch (node.nodeType) {\n      case \"FunctionDefinition\":\n        //normal case\n        inputParametersFull = node.parameters.parameters;\n        outputParametersFull = node.returnParameters.parameters; //this exists even for constructors!\n\n        break;\n\n      case \"VariableDeclaration\":\n        //getter case\n        var _Ast$Utils$getterPara = Ast.Utils.getterParameters(node, referenceDeclarations);\n\n        inputParametersFull = _Ast$Utils$getterPara.inputs;\n        outputParametersFull = _Ast$Utils$getterPara.outputs;\n        break;\n    }\n  } else {\n    inputParametersFull = undefined;\n    outputParametersFull = undefined;\n  }\n\n  inputParametersAbi = abiEntry.inputs;\n\n  switch (abiEntry.type) {\n    case \"function\":\n      outputParametersAbi = abiEntry.outputs;\n      break;\n\n    case \"constructor\":\n      //we just leave this empty for constructors\n      outputParametersAbi = [];\n      break;\n  } //now: do the allocation!\n\n\n  let _allocateDataArgument = allocateDataArguments(inputParametersFull, inputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, offset),\n      abiAllocationInput = _allocateDataArgument.allocation,\n      inputMode = _allocateDataArgument.mode;\n\n  let _allocateDataArgument2 = allocateDataArguments(outputParametersFull, outputParametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler //note no offset\n  ),\n      abiAllocationOutput = _allocateDataArgument2.allocation,\n      outputMode = _allocateDataArgument2.mode;\n\n  debug(\"modes: %s in, %s out\", inputMode, outputMode); //finally: transform the allocation appropriately\n\n  let inputArgumentsAllocation = abiAllocationInput.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"calldata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  let outputArgumentsAllocation = abiAllocationOutput.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"returndata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  let inputsAllocation = {\n    abi: abiEntry,\n    offset,\n    arguments: inputArgumentsAllocation,\n    allocationMode: inputMode\n  };\n  let outputsAllocation;\n\n  switch (abiEntry.type) {\n    case \"function\":\n      outputsAllocation = {\n        selector: new Uint8Array(),\n        arguments: outputArgumentsAllocation,\n        allocationMode: outputMode,\n        kind: \"return\"\n      };\n      break;\n\n    case \"constructor\":\n      outputsAllocation = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, outputMode);\n      break;\n  }\n\n  return {\n    input: inputsAllocation,\n    output: outputsAllocation\n  }; //TS chokes on this for some reason\n} //note: allocateEvent doesn't use this because it needs additional\n//handling for indexed parameters (maybe these can be unified in\n//the future though?)\n\n\nfunction allocateDataArguments(fullModeParameters, abiParameters, userDefinedTypes, abiAllocations, compilationId, compiler, offset = 0) {\n  let allocationMode = fullModeParameters ? \"full\" : \"abi\"; //can degrade\n\n  let parameterTypes;\n  let abiAllocation;\n\n  if (allocationMode === \"full\") {\n    let id = \"-1\"; //fake ID that doesn't matter\n\n    parameterTypes = fullModeParameters.map(parameter => ({\n      name: parameter.name,\n      type: Ast.Import.definitionToType(parameter, compilationId, compiler) //if node is defined, compiler had also better be!\n\n    }));\n    debug(\"parameterTypes: %O\", parameterTypes); //now: perform the allocation!\n\n    try {\n      abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n    } catch (_a) {\n      //if something goes wrong, switch to ABI mdoe\n      debug(\"falling back to ABI due to exception!\");\n      allocationMode = \"abi\";\n    }\n  }\n\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    //this is the ABI case.  we end up here EITHER\n    //if node doesn't exist, OR if something went wrong\n    //during allocation\n    let id = \"-1\"; //fake irrelevant ID\n\n    parameterTypes = abiParameters.map(parameter => ({\n      name: parameter.name,\n      type: Import.abiParameterToType(parameter)\n    }));\n    abiAllocation = allocateMembers(id, parameterTypes, userDefinedTypes, abiAllocations, offset)[id];\n  }\n\n  return {\n    allocation: abiAllocation,\n    mode: allocationMode\n  };\n} //allocates an event\n//NOTE: returns just a single allocation; assumes primary allocation is already complete!\n\n\nfunction allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let parameterTypes;\n  let nodeId;\n  let id; //first: determine the corresponding event node\n  //search through base contracts, from most derived (right) to most base (left)\n\n  let node = undefined;\n  let definedIn = undefined;\n  let allocationMode = \"full\"; //degrade to abi as needed\n\n  debug(\"allocating ABI: %O\", abiEntry);\n\n  if (contractNode) {\n    //first: check same contract for the event\n    node = contractNode.nodes.find(eventNode => AbiDataUtils.definitionMatchesAbi( //note this needn't actually be an event node, but then it will\n    //return false\n    abiEntry, eventNode, referenceDeclarations)); //if we found the node, great!  If not...\n\n    if (!node) {\n      debug(\"didn't find node in base contract...\"); //let's search for the node among the base contracts.\n      //but if we find it...\n      //[note: the following code is overcomplicated; it was used\n      //when we were trying to get the actual node, it's overcomplicated\n      //now that we're just determining its presence.  oh well]\n\n      let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n      linearizedBaseContractsMinusSelf.shift(); //remove self\n\n      debug(\"checking contracts: %o\", linearizedBaseContractsMinusSelf);\n      node = findNodeAndContract(linearizedBaseContractsMinusSelf, referenceDeclarations, eventNode => AbiDataUtils.definitionMatchesAbi( //note this needn't actually be a event node, but then it will return false\n      abiEntry, eventNode, referenceDeclarations) //don't pass deriveContractNode here, we're not checking the contract itself\n      ).node; //may be undefined! that's OK!\n\n      if (node) {\n        //...if we find the node in an ancestor, we\n        //deliberately *don't* allocate!  instead such cases\n        //will be handled during a later combination step\n        debug(\"bailing out for later handling!\");\n        debug(\"ABI: %O\", abiEntry);\n        return undefined;\n      }\n    }\n  } //otherwise, leave node undefined\n\n\n  if (node) {\n    debug(\"found node\"); //if we found the node, let's also turn it into a type\n\n    definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler); //can skip reference declarations argument here\n    //...and set the ID\n\n    id = import_1.makeTypeId(node.id, compilationId);\n  } else {\n    //if no node, have to fall back into ABI mode\n    debug(\"falling back to ABI because no node\");\n    allocationMode = \"abi\";\n  } //now: construct the list of parameter types, attaching indexedness info\n  //and overall position (for later reconstruction)\n\n\n  let indexed;\n  let nonIndexed;\n  let abiAllocation; //the untransformed allocation for the non-indexed parameters\n\n  if (allocationMode === \"full\") {\n    nodeId = node.id.toString();\n    let parameters = node.parameters.parameters;\n    parameterTypes = parameters.map(definition => ({\n      //note: if node is defined, compiler had better be defined, too!\n      type: Ast.Import.definitionToType(definition, compilationId, compiler),\n      name: definition.name,\n      indexed: definition.indexed\n    })); //now: split the list of parameters into indexed and non-indexed\n\n    var _partition_1$default = partition_1.default(parameterTypes, parameter => parameter.indexed);\n\n    var _partition_1$default2 = _slicedToArray(_partition_1$default, 2);\n\n    indexed = _partition_1$default2[0];\n    nonIndexed = _partition_1$default2[1];\n\n    try {\n      //now: perform the allocation for the non-indexed parameters!\n      abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n    } catch (_a) {\n      allocationMode = \"abi\";\n    }\n  }\n\n  if (allocationMode === \"abi\") {\n    //THIS IS DELIBERATELY NOT AN ELSE\n    nodeId = \"-1\"; //fake irrelevant ID\n\n    parameterTypes = abiEntry.inputs.map(abiParameter => ({\n      type: Import.abiParameterToType(abiParameter),\n      name: abiParameter.name,\n      indexed: abiParameter.indexed\n    })); //now: split the list of parameters into indexed and non-indexed\n\n    var _partition_1$default3 = partition_1.default(parameterTypes, parameter => parameter.indexed);\n\n    var _partition_1$default4 = _slicedToArray(_partition_1$default3, 2);\n\n    indexed = _partition_1$default4[0];\n    nonIndexed = _partition_1$default4[1];\n    //now: perform the allocation for the non-indexed parameters!\n    abiAllocation = allocateMembers(nodeId, nonIndexed, userDefinedTypes, abiAllocations)[nodeId]; //note the implicit conversion from EventParameterInfo to NameTypePair\n  } //now: transform the result appropriately\n\n\n  const nonIndexedArgumentsAllocation = abiAllocation.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"eventdata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  })); //now: allocate the indexed parameters\n\n  const startingTopic = abiEntry.anonymous ? 0 : 1; //if not anonymous, selector takes up topic 0\n\n  const indexedArgumentsAllocation = indexed.map(({\n    type,\n    name\n  }, position) => ({\n    type,\n    name,\n    pointer: {\n      location: \"eventtopic\",\n      topic: startingTopic + position\n    }\n  })); //finally: weave these back together\n\n  let argumentsAllocation = [];\n\n  for (let parameter of parameterTypes) {\n    let arrayToGrabFrom = parameter.indexed ? indexedArgumentsAllocation : nonIndexedArgumentsAllocation;\n    argumentsAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n  } //...and return\n\n\n  return {\n    abi: abiEntry,\n    contextHash: undefined,\n    definedIn,\n    id,\n    arguments: argumentsAllocation,\n    allocationMode,\n    anonymous: abiEntry.anonymous\n  };\n}\n\nfunction allocateError(abiEntry, errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  //first: if we got passed just a node & no abi entry,\n  let id = undefined;\n  let definedIn = undefined;\n  let parametersFull = undefined;\n  const parametersAbi = abiEntry.inputs;\n\n  if (errorNode) {\n    //first, set parametersFull\n    parametersFull = errorNode.parameters.parameters; //now, set id\n\n    id = import_1.makeTypeId(errorNode.id, compilationId); //now, set definedIn\n\n    let contractNode = null;\n\n    for (const node of Object.values(referenceDeclarations)) {\n      if (node.nodeType === \"ContractDefinition\") {\n        if (node.nodes.some(subNode => subNode.id === errorNode.id)) {\n          contractNode = node;\n          break;\n        }\n      } //if we didn't find it, then contractNode is null\n      //(and thus so will be definedIn)\n\n    }\n\n    if (contractNode === null) {\n      definedIn = null;\n    } else {\n      definedIn = Ast.Import.definitionToStoredType(contractNode, compilationId, compiler);\n    }\n  } //otherwise, leave parametersFull, id, and definedIn undefined\n\n\n  const _allocateDataArgument3 = allocateDataArguments(parametersFull, parametersAbi, userDefinedTypes, abiAllocations, compilationId, compiler, Evm.Utils.SELECTOR_SIZE //errors use a 4-byte selector\n  ),\n        abiAllocation = _allocateDataArgument3.allocation,\n        allocationMode = _allocateDataArgument3.mode; //finally: transform the allocation appropriately\n\n\n  const argumentsAllocation = abiAllocation.members.map(member => Object.assign(Object.assign({}, member), {\n    pointer: {\n      location: \"returndata\",\n      start: member.pointer.start,\n      length: member.pointer.length\n    }\n  }));\n  const selector = Conversion.toBytes(AbiDataUtils.abiSelector(abiEntry));\n  return {\n    kind: \"revert\",\n    selector,\n    abi: abiEntry,\n    id,\n    definedIn,\n    arguments: argumentsAllocation,\n    allocationMode\n  };\n}\n\nfunction getCalldataAllocationsForContract(abi, contractNode, constructorContext, deployedContext, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let allocations = {\n    constructorAllocation: undefined,\n    //(if it doesn't then it will remain as default)\n    functionAllocations: {}\n  };\n\n  if (!abi) {\n    //if no ABI, can't do much!\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    return allocations;\n  }\n\n  for (let abiEntry of abi) {\n    if (AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry) || AbiDataUtils.abiEntryHasStorageParameters(abiEntry)) {\n      //the first of these conditions is a hack workaround for a Solidity bug.\n      //the second of these is because... seriously? we're not handling these\n      //(at least not for now!) (these only exist prior to Solidity 0.5.6,\n      //thankfully)\n      continue;\n    }\n\n    switch (abiEntry.type) {\n      case \"constructor\":\n        allocations.constructorAllocation = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n        debug(\"constructor alloc: %O\", allocations.constructorAllocation);\n        break;\n\n      case \"function\":\n        allocations.functionAllocations[AbiDataUtils.abiSelector(abiEntry)] = allocateCalldataAndReturndata(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler, constructorContext, deployedContext);\n        break;\n\n      default:\n        //skip over fallback, error, and event\n        break;\n    }\n  }\n\n  if (!allocations.constructorAllocation) {\n    //set a default constructor allocation if we haven't allocated one yet\n    allocations.constructorAllocation = defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext);\n    debug(\"default constructor alloc: %O\", allocations.constructorAllocation);\n  }\n\n  return allocations;\n}\n\nfunction defaultConstructorAllocation(constructorContext, contractNode, referenceDeclarations, deployedContext) {\n  if (!constructorContext) {\n    return undefined;\n  }\n\n  const rawLength = constructorContext.binary.length;\n  const offset = (rawLength - 2) / 2; //number of bytes in 0x-prefixed bytestring\n\n  const input = {\n    offset,\n    abi: AbiDataUtils.DEFAULT_CONSTRUCTOR_ABI,\n    arguments: [],\n    allocationMode: \"full\"\n  };\n  const output = constructorOutputAllocation(deployedContext, contractNode, referenceDeclarations, \"full\"); //assume full, degrade as necessary\n\n  return {\n    input,\n    output\n  };\n} //note: context should be deployed context!\n\n\nfunction constructorOutputAllocation(context, contractNode, referenceDeclarations, allocationMode) {\n  if (!context) {\n    //just return a default abi mode result\n    return {\n      selector: new Uint8Array(),\n      allocationMode: \"abi\",\n      kind: \"bytecode\",\n      delegatecallGuard: false\n    };\n  }\n\n  const immutableReferences = context.immutableReferences,\n        compilationId = context.compilationId,\n        compiler = context.compiler,\n        contractKind = context.contractKind,\n        binary = context.binary;\n  let immutables;\n\n  if (allocationMode === \"full\" && immutableReferences) {\n    if (contractNode) {\n      debug(\"allocating immutables\");\n      immutables = [];\n\n      for (const _ref of Object.entries(immutableReferences)) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        const id = _ref2[0];\n        const references = _ref2[1];\n\n        if (references.length === 0) {\n          continue; //don't allocate immutables that don't exist\n        }\n\n        const astId = parseInt(id); //get the corresponding variable node; potentially fail\n\n        const _findNodeAndContract = findNodeAndContract(contractNode.linearizedBaseContracts, referenceDeclarations, node => node.id === astId, contractNode),\n              definition = _findNodeAndContract.node,\n              definedIn = _findNodeAndContract.contract;\n\n        if (!definition || definition.nodeType !== \"VariableDeclaration\") {\n          debug(\"didn't find definition for %d!\", astId);\n          allocationMode = \"abi\";\n          immutables = undefined;\n          break;\n        }\n\n        const definedInClass = Ast.Import.definitionToStoredType(definedIn, compilationId, compiler); //can skip reference declarations argument here\n\n        const dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n        immutables.push({\n          name: definition.name,\n          definedIn: definedInClass,\n          type: dataType,\n          pointer: {\n            location: \"returndata\",\n            start: references[0].start,\n            length: references[0].length\n          }\n        });\n      }\n    } else if (Object.entries(immutableReferences).length > 0) {\n      //if there are immutables, but no contract mode, go to abi mode\n      debug(\"immutables but no node!\");\n      allocationMode = \"abi\";\n    }\n  } else {\n    debug(\"no immutables\");\n  } //now, is there a delegatecall guard?\n\n\n  let delegatecallGuard = false;\n\n  if (contractKind === \"library\") {\n    //note: I am relying on this being present!\n    //(also this part is a bit HACKy)\n    const pushAddressInstruction = (0x60 + Evm.Utils.ADDRESS_SIZE - 1).toString(16); //\"73\"\n\n    const delegateCallGuardString = \"0x\" + pushAddressInstruction + \"..\".repeat(Evm.Utils.ADDRESS_SIZE);\n\n    if (binary.startsWith(delegateCallGuardString)) {\n      delegatecallGuard = true;\n    }\n  }\n\n  return {\n    selector: new Uint8Array(),\n    allocationMode,\n    kind: \"bytecode\",\n    immutables,\n    delegatecallGuard\n  };\n}\n\nfunction getCalldataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allocations = {\n    constructorAllocations: {},\n    functionAllocations: {}\n  };\n\n  for (let contract of contracts) {\n    const contractAllocations = getCalldataAllocationsForContract(contract.abi, contract.contractNode, contract.constructorContext, contract.deployedContext, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n\n    if (contract.constructorContext) {\n      allocations.constructorAllocations[contract.constructorContext.context] = contractAllocations.constructorAllocation;\n    }\n\n    if (contract.deployedContext) {\n      allocations.functionAllocations[contract.deployedContext.context] = contractAllocations.functionAllocations; //set this up under both constructor *and* deployed! this is to handle\n      //constructor returndata decoding\n\n      allocations.constructorAllocations[contract.deployedContext.context] = contractAllocations.constructorAllocation;\n    }\n  }\n\n  return allocations;\n}\n\nexports.getCalldataAllocations = getCalldataAllocations;\n\nfunction getReturndataAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  let useAst = Boolean(contractNode && contractNode.usedErrors);\n\n  if (useAst) {\n    const errorNodes = contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]);\n    let abis;\n\n    try {\n      abis = errorNodes.map(errorNode => Ast.Utils.definitionToAbi(errorNode, referenceDeclarations));\n    } catch (_a) {\n      useAst = false;\n    }\n\n    if (useAst) {\n      //i.e. if the above operation succeeded\n      return contractNode.usedErrors.map(errorNodeId => referenceDeclarations[errorNodeId]).map((errorNode, index) => allocateError(abis[index], errorNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n    }\n  }\n\n  if (!useAst && abi) {\n    //deliberately *not* an else!\n    return abi.filter(abiEntry => abiEntry.type === \"error\").filter(abiEntry => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n    .map(abiEntry => allocateError(abiEntry, undefined, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler));\n  } //otherwise just return nothing\n\n\n  return [];\n}\n\nfunction getReturndataAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  let allContexts = [].concat(...contracts.map(({\n    deployedContext,\n    constructorContext\n  }) => [deployedContext, constructorContext])).filter(x => x) //filter out nonexistent contexts\n  .map(context => context.context);\n  allContexts.push(\"\"); //HACK: add fictional empty-string context to represent no-context\n  //holds allocations for a given context\n\n  let selfAllocations = {}; //holds allocations for *other* contexts\n\n  let additionalAllocations = {}; //now: process the allocations for each contract. we'll add each contract's\n  //allocations to *its* entries in allocations, and to every *other* entry\n  //in additionalAllocations.\n\n  for (const contract of contracts) {\n    const contractAllocations = getReturndataAllocationsForContract(contract.abi, contract.contractNode, referenceDeclarations[contract.compilationId], userDefinedTypes, abiAllocations, contract.compilationId, contract.compiler);\n    const contexts = [//contexts for this contract\n    contract.deployedContext, contract.constructorContext].filter(x => x) //filter out nonexistent contexts\n    .map(context => context.context);\n    const otherContexts = allContexts.filter( //contexts for all other contracts\n    contextHash => !contexts.includes(contextHash)); //add them to selfAllocations\n\n    for (const contextHash of contexts) {\n      selfAllocations[contextHash] = contractAllocations;\n    } //add them to additionalAllocations\n\n\n    for (const contextHash of otherContexts) {\n      if (additionalAllocations[contextHash] === undefined) {\n        additionalAllocations[contextHash] = [];\n      }\n\n      additionalAllocations[contextHash] = additionalAllocations[contextHash].concat(contractAllocations);\n    }\n  }\n\n  let allocations = Object.assign({}, ...allContexts.map(contextHash => ({\n    [contextHash]: {}\n  }))); //now: perform coalescense!\n\n  for (const contract of contracts) {\n    //we're setting up contexts again, sorry >_>\n    const contexts = [//contexts for this contract\n    contract.deployedContext, contract.constructorContext].filter(x => x) //filter out nonexistent contexts\n    .map(context => context.context);\n\n    for (const contextHash of contexts) {\n      allocations[contextHash] = coalesceReturndataAllocations(selfAllocations[contextHash] || [], additionalAllocations[contextHash] || []);\n      debug(\"allocations: %O\", allocations[contextHash]);\n    }\n  } //...also coalesce the fake \"\" context\n\n\n  allocations[\"\"] = coalesceReturndataAllocations([], additionalAllocations[\"\"] || []);\n  /*\n  for (const [contextHash, contextAllocations] of Object.entries(allAllocations)) {\n    for (const [signature, signatureAllocations] of Object.entries(contextAllocations)) {\n      const selector = Web3Utils.soliditySha3({ type: \"string\", value: signature })\n        .slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n      if (!allocations[contextHash][selector]) {\n        allocations[contextHash][selector] = [];\n      }\n      allocations[contextHash][selector] = allocations[contextHash][selector].concat(signatureAllocations);\n    }\n  }\n  */\n\n  debug(\"error allocations: %O\", allocations);\n  return allocations;\n}\n\nexports.getReturndataAllocations = getReturndataAllocations;\n\nfunction coalesceReturndataAllocations(selfAllocations, additionalAllocations) {\n  let bySelector = {}; //start with the additional allocations; we want to process\n  //the self allocations last, due to special handling of no-ID allocations there\n\n  for (const allocation of additionalAllocations) {\n    const signature = AbiDataUtils.abiSignature(allocation.abi);\n    const selector = Web3Utils.soliditySha3({\n      type: \"string\",\n      value: signature\n    }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n\n    if (bySelector[selector]) {\n      //note: at this point, for any given signature, there should only be a\n      //no-ID allocation for that signature if it's the only one\n      if (allocation.id !== undefined) {\n        //delete anything with that signature but w/o an ID, or with this same ID\n        bySelector[selector] = bySelector[selector].filter(({\n          abi,\n          id\n        }) => !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id))); //add this allocation\n\n        bySelector[selector].push(allocation);\n      } else if (!bySelector[selector].some(({\n        abi\n      }) => AbiDataUtils.abiSignature(abi) === signature)) {\n        //only add ID-less ones if there isn't anything of that signature already\n        bySelector[selector].push(allocation);\n      }\n    } else {\n      //if there's nothing there thus far, add it\n      bySelector[selector] = [allocation];\n    }\n  } //now we're going to perform a modified version of this procedure for the self allocations:\n  //1. we're going to add to the front, not the back\n  //2. we can add an ID-less one even if there are already ones with IDs there\n  //(sorry for the copypaste)\n\n\n  for (const allocation of selfAllocations) {\n    const signature = AbiDataUtils.abiSignature(allocation.abi);\n    const selector = Web3Utils.soliditySha3({\n      type: \"string\",\n      value: signature\n    }).slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE); //arithmetic to account for hex string\n\n    if (bySelector[selector]) {\n      //delete anything with that signature but w/o an ID, or with this same ID\n      //(if this alloc has no ID, this will only delete ID-less ones :) )\n      bySelector[selector] = bySelector[selector].filter(({\n        abi,\n        id\n      }) => !(AbiDataUtils.abiSignature(abi) === signature && (id === undefined || id === allocation.id))); //add this allocation to front, not back!\n\n      bySelector[selector].unshift(allocation);\n    } else {\n      //if there's nothing there thus far, add it\n      bySelector[selector] = [allocation];\n    }\n  }\n\n  return bySelector;\n}\n\nfunction getEventAllocationsForContract(abi, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler) {\n  return abi.filter(abiEntry => abiEntry.type === \"event\").filter(abiEntry => !AbiDataUtils.abiEntryIsObviouslyIllTyped(abiEntry)) //hack workaround\n  .map(abiEntry => ({\n    selector: AbiDataUtils.abiSelector(abiEntry),\n    anonymous: abiEntry.anonymous,\n    topics: AbiDataUtils.topicsCount(abiEntry),\n    allocation: allocateEvent(abiEntry, contractNode, referenceDeclarations, userDefinedTypes, abiAllocations, compilationId, compiler)\n  })); //note we do *not* filter out undefined allocations; we need these as placeholders\n} //note: constructor context is ignored by this function; no need to pass it in\n//WARNING: this function is full of hacks... sorry\n\n\nfunction getEventAllocations(contracts, referenceDeclarations, userDefinedTypes, abiAllocations) {\n  //first: do allocations for individual contracts\n  let individualAllocations = {};\n  let groupedAllocations = {};\n  let allocations = {};\n\n  for (let _ref3 of contracts) {\n    let abi = _ref3.abi;\n    let deployedContext = _ref3.deployedContext;\n    let contractNode = _ref3.contractNode;\n    let compilationId = _ref3.compilationId;\n    let compiler = _ref3.compiler;\n\n    if (!deployedContext && !contractNode) {\n      //we'll need *one* of these two at least\n      continue;\n    }\n\n    let contractAllocations = getEventAllocationsForContract(abi, contractNode, referenceDeclarations[compilationId], userDefinedTypes, abiAllocations, compilationId, compiler);\n    let key = makeContractKey(deployedContext, contractNode ? contractNode.id : undefined, compilationId);\n\n    if (individualAllocations[key] === undefined) {\n      individualAllocations[key] = {};\n    }\n\n    for (let allocationTemporary of contractAllocations) {\n      //we'll use selector *even for anonymous* here, because it's just\n      //for determining what overrides what at this point\n      individualAllocations[key][allocationTemporary.selector] = {\n        context: deployedContext,\n        contractNode,\n        allocationTemporary,\n        compilationId\n      };\n    }\n  } //now: put things together for inheritance\n  //note how we always put things in order from most derived to most base\n\n\n  for (let contextOrId in individualAllocations) {\n    groupedAllocations[contextOrId] = {};\n\n    for (let selector in individualAllocations[contextOrId]) {\n      let _individualAllocation = individualAllocations[contextOrId][selector],\n          context = _individualAllocation.context,\n          contractNode = _individualAllocation.contractNode,\n          allocationTemporary = _individualAllocation.allocationTemporary,\n          compilationId = _individualAllocation.compilationId;\n      debug(\"allocationTemporary: %O\", allocationTemporary);\n      let allocationsTemporary = allocationTemporary.allocation ? [allocationTemporary] : []; //filter out undefined allocations\n      //first, copy from individual allocations\n\n      groupedAllocations[contextOrId][selector] = {\n        context,\n        contractNode,\n        allocationsTemporary\n      }; //if no contract node, that's all.  if there is...\n\n      if (contractNode) {\n        //...we have to do inheritance processing\n        debug(\"contract Id: %d\", contractNode.id);\n        debug(\"base contracts: %o\", contractNode.linearizedBaseContracts);\n        let linearizedBaseContractsMinusSelf = contractNode.linearizedBaseContracts.slice();\n        linearizedBaseContractsMinusSelf.shift(); //remove contract itself; only want ancestors\n\n        for (let baseId of linearizedBaseContractsMinusSelf) {\n          debug(\"checking baseId: %d\", baseId);\n          let baseNode = referenceDeclarations[compilationId][baseId];\n\n          if (!baseNode || baseNode.nodeType !== \"ContractDefinition\") {\n            debug(\"failed to find node for baseId: %d\", baseId);\n            break; //not a continue!\n            //if we can't find the base node, it's better to stop the loop,\n            //rather than continue to potentially erroneous things\n          } //note: we're not actually going to *use* the baseNode here.\n          //we're just checking for whether we can *find* it\n          //why? because if we couldn't find it, that means that events defined in\n          //base contracts *weren't* skipped earlier, and so we shouldn't now add them in\n\n\n          let baseContractInfo = contracts.find(contractAllocationInfo => contractAllocationInfo.compilationId === compilationId && contractAllocationInfo.contractNode && contractAllocationInfo.contractNode.id === baseId);\n\n          if (!baseContractInfo) {\n            //similar to above... this failure case can happen when there are\n            //two contracts with the same name and you attempt to use the\n            //artifacts; say you have contracts A, B, and B', where A inherits\n            //from B, and B and B' have the same name, and B' is the one that\n            //gets the artifact; B will end up in reference declarations and so\n            //get found above, but it won't appear in contracts, causing the\n            //problem here.  Unfortunately I don't know any great way to handle this,\n            //so, uh, we treat it as a failure same as above.\n            debug(\"failed to find contract info for baseId: %d\", baseId);\n            break;\n          }\n\n          let baseContext = baseContractInfo.deployedContext;\n          let baseKey = makeContractKey(baseContext, baseId, compilationId);\n\n          if (individualAllocations[baseKey][selector] !== undefined) {\n            let baseAllocation = individualAllocations[baseKey][selector].allocationTemporary;\n            debug(\"(probably) pushing inherited alloc from baseId: %d\", baseId);\n\n            if (baseAllocation.allocation) {\n              //don't push undefined!\n              groupedAllocations[contextOrId][selector].allocationsTemporary.push(baseAllocation);\n            }\n          }\n        }\n      }\n    }\n  } //finally: transform into final form & return,\n  //filtering out things w/o a context\n\n\n  for (let contractKey in groupedAllocations) {\n    if (!hasContext(contractKey)) {\n      continue; //(this filters out ones that had no context and therefore were\n      //given by ID; we needed these at the previous stage but from\n      //here on they're irrelevant)\n    }\n\n    let contextHash = contextHashForKey(contractKey);\n\n    for (let selector in groupedAllocations[contextHash]) {\n      let _groupedAllocations$c = groupedAllocations[contextHash][selector],\n          allocationsTemporary = _groupedAllocations$c.allocationsTemporary,\n          context = _groupedAllocations$c.context;\n\n      for (let _ref4 of allocationsTemporary) {\n        let anonymous = _ref4.anonymous;\n        let topics = _ref4.topics;\n        let allocation = _ref4.allocation;\n        let contractKind = context.contractKind; //HACK: this is the wrong context, but libraries can't inherit, so it's OK\n\n        if (contractKind !== \"library\") {\n          contractKind = \"contract\"; //round off interfaces to being contracts for our purposes :P\n        }\n\n        allocation = Object.assign(Object.assign({}, allocation), {\n          contextHash\n        }); //the allocation's context hash at this point depends on where it was defined, but\n        //that's not what we want going in the final allocation table!\n\n        if (allocations[topics] === undefined) {\n          allocations[topics] = {\n            bySelector: {},\n            anonymous: {\n              contract: {},\n              library: {}\n            }\n          };\n        }\n\n        if (!anonymous) {\n          if (allocations[topics].bySelector[selector] === undefined) {\n            allocations[topics].bySelector[selector] = {\n              contract: {},\n              library: {}\n            };\n          }\n\n          if (allocations[topics].bySelector[selector][contractKind][contextHash] === undefined) {\n            allocations[topics].bySelector[selector][contractKind][contextHash] = [];\n          }\n\n          allocations[topics].bySelector[selector][contractKind][contextHash].push(allocation);\n        } else {\n          if (allocations[topics].anonymous[contractKind][contextHash] === undefined) {\n            allocations[topics].anonymous[contractKind][contextHash] = [];\n          }\n\n          allocations[topics].anonymous[contractKind][contextHash].push(allocation);\n        }\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getEventAllocations = getEventAllocations; //if derivedContractNode is passed, we check that before referenceDeclarations\n\nfunction findNodeAndContract(linearizedBaseContracts, referenceDeclarations, condition, derivedContractNode) {\n  const searchResult = linearizedBaseContracts.reduce((foundNodeAndContract, baseContractId) => {\n    if (foundNodeAndContract !== undefined) {\n      return foundNodeAndContract; //once we've found something, we don't need to keep looking\n    }\n\n    debug(\"searching contract %d\", baseContractId);\n    let baseContractNode = derivedContractNode && baseContractId === derivedContractNode.id ? derivedContractNode //skip the lookup if we already have the right node! this is to reduce errors from collision\n    : referenceDeclarations[baseContractId];\n\n    if (baseContractNode === undefined || baseContractNode.nodeType !== \"ContractDefinition\") {\n      debug(\"bad contract node!\");\n      return null; //return null rather than undefined so that this will propagate through\n      //(i.e. by returning null here we give up the search)\n      //(we don't want to continue due to possibility of grabbing the wrong override)\n    }\n\n    const node = baseContractNode.nodes.find(condition); //may be undefined! that's OK!\n\n    if (node) {\n      debug(\"found node: %o\", node);\n      return {\n        node,\n        contract: baseContractNode\n      };\n    } else {\n      return undefined;\n    }\n  }, undefined //start with no node found\n  );\n  return searchResult || {\n    node: undefined,\n    contract: undefined\n  };\n}\n\nfunction makeContractKey(context, id, compilationId) {\n  return context ? context.context : id + \":\" + compilationId; //HACK!\n}\n\nfunction hasContext(key) {\n  return key.startsWith(\"0x\"); //HACK!\n}\n\nfunction contextHashForKey(key) {\n  return hasContext(key) ? key //HACK!\n  : undefined;\n}","map":null,"metadata":{},"sourceType":"script"}