{"ast":null,"code":"import { bigUintN } from '../bigUintN.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nimport { applyFlagsOnChars, computeFlagsFromChars, computeNextFlags, computeTogglePositions } from './helpers/ToggleFlags.js';\nexport class MixedCaseArbitrary extends NextArbitrary {\n  constructor(stringArb, toggleCase, untoggleAll) {\n    super();\n    this.stringArb = stringArb;\n    this.toggleCase = toggleCase;\n    this.untoggleAll = untoggleAll;\n  }\n\n  buildContextFor(rawStringNextValue, flagsNextValue) {\n    return {\n      rawString: rawStringNextValue.value,\n      rawStringContext: rawStringNextValue.context,\n      flags: flagsNextValue.value,\n      flagsContext: flagsNextValue.context\n    };\n  }\n\n  generate(mrng, biasFactor) {\n    const rawStringNextValue = this.stringArb.generate(mrng, biasFactor);\n    const chars = [...rawStringNextValue.value];\n    const togglePositions = computeTogglePositions(chars, this.toggleCase);\n    const flagsArb = convertToNext(bigUintN(togglePositions.length));\n    const flagsNextValue = flagsArb.generate(mrng, undefined);\n    applyFlagsOnChars(chars, flagsNextValue.value, togglePositions, this.toggleCase);\n    return new NextValue(chars.join(''), this.buildContextFor(rawStringNextValue, flagsNextValue));\n  }\n\n  canShrinkWithoutContext(value) {\n    if (typeof value !== 'string') {\n      return false;\n    }\n\n    return this.untoggleAll !== undefined ? this.stringArb.canShrinkWithoutContext(this.untoggleAll(value)) : this.stringArb.canShrinkWithoutContext(value);\n  }\n\n  shrink(value, context) {\n    let contextSafe;\n\n    if (context !== undefined) {\n      contextSafe = context;\n    } else {\n      if (this.untoggleAll !== undefined) {\n        const untoggledValue = this.untoggleAll(value);\n        const valueChars = [...value];\n        const untoggledValueChars = [...untoggledValue];\n        const togglePositions = computeTogglePositions(untoggledValueChars, this.toggleCase);\n        contextSafe = {\n          rawString: untoggledValue,\n          rawStringContext: undefined,\n          flags: computeFlagsFromChars(untoggledValueChars, valueChars, togglePositions),\n          flagsContext: undefined\n        };\n      } else {\n        contextSafe = {\n          rawString: value,\n          rawStringContext: undefined,\n          flags: BigInt(0),\n          flagsContext: undefined\n        };\n      }\n    }\n\n    const rawString = contextSafe.rawString;\n    const flags = contextSafe.flags;\n    return this.stringArb.shrink(rawString, contextSafe.rawStringContext).map(nRawStringNextValue => {\n      const nChars = [...nRawStringNextValue.value];\n      const nTogglePositions = computeTogglePositions(nChars, this.toggleCase);\n      const nFlags = computeNextFlags(flags, nTogglePositions.length);\n      applyFlagsOnChars(nChars, nFlags, nTogglePositions, this.toggleCase);\n      return new NextValue(nChars.join(''), this.buildContextFor(nRawStringNextValue, new NextValue(nFlags, undefined)));\n    }).join(makeLazy(() => {\n      const chars = [...rawString];\n      const togglePositions = computeTogglePositions(chars, this.toggleCase);\n      return convertToNext(bigUintN(togglePositions.length)).shrink(flags, contextSafe.flagsContext).map(nFlagsNextValue => {\n        const nChars = chars.slice();\n        applyFlagsOnChars(nChars, nFlagsNextValue.value, togglePositions, this.toggleCase);\n        return new NextValue(nChars.join(''), this.buildContextFor(new NextValue(rawString, contextSafe.rawStringContext), nFlagsNextValue));\n      });\n    }));\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}