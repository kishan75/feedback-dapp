{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abiEntryHasStorageParameters = exports.abiEntryIsObviouslyIllTyped = exports.topicsCount = exports.definitionMatchesAbi = exports.abisMatch = exports.abiSelector = exports.abiTupleSignature = exports.abiSignature = exports.abiHasPayableFallback = exports.computeSelectors = exports.DEFAULT_CONSTRUCTOR_ABI = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:utils\"); // untyped import since no @types/web3-utils exists\n\nconst Web3Utils = require(\"web3-utils\");\n\nconst Evm = __importStar(require(\"../evm\"));\n\nconst Ast = __importStar(require(\"../ast\"));\n\nexports.DEFAULT_CONSTRUCTOR_ABI = {\n  type: \"constructor\",\n  inputs: [],\n  stateMutability: \"nonpayable\"\n}; //note the return value only includes functions!\n\nfunction computeSelectors(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n\n  return Object.assign({}, ...abi.filter(abiEntry => abiEntry.type === \"function\").map(abiEntry => ({\n    [abiSelector(abiEntry)]: abiEntry\n  })));\n}\n\nexports.computeSelectors = computeSelectors; //does this ABI have a payable fallback (or receive) function?\n\nfunction abiHasPayableFallback(abi) {\n  if (abi === undefined) {\n    return undefined;\n  }\n\n  return abi.some(abiEntry => (abiEntry.type === \"fallback\" || abiEntry.type === \"receive\") && abiEntry.stateMutability === \"payable\");\n}\n\nexports.abiHasPayableFallback = abiHasPayableFallback; //NOTE: this function returns the written out SIGNATURE, not the SELECTOR\n\nfunction abiSignature(abiEntry) {\n  return abiEntry.name + abiTupleSignature(abiEntry.inputs);\n}\n\nexports.abiSignature = abiSignature;\n\nfunction abiTupleSignature(parameters) {\n  let components = parameters.map(abiTypeSignature);\n  return \"(\" + components.join(\",\") + \")\";\n}\n\nexports.abiTupleSignature = abiTupleSignature;\n\nfunction abiTypeSignature(parameter) {\n  let tupleMatch = parameter.type.match(/tuple(.*)/);\n\n  if (tupleMatch === null) {\n    //does not start with \"tuple\"\n    return parameter.type;\n  } else {\n    let tail = tupleMatch[1]; //everything after \"tuple\"\n\n    let tupleSignature = abiTupleSignature(parameter.components);\n    return tupleSignature + tail;\n  }\n}\n\nfunction abiSelector(abiEntry) {\n  let signature = abiSignature(abiEntry); //NOTE: web3's soliditySha3 has a problem if the empty\n  //string is passed in.  Fortunately, that should never happen here.\n\n  let hash = Web3Utils.soliditySha3({\n    type: \"string\",\n    value: signature\n  });\n\n  switch (abiEntry.type) {\n    case \"event\":\n      return hash;\n\n    case \"function\":\n    case \"error\":\n      return hash.slice(0, 2 + 2 * Evm.Utils.SELECTOR_SIZE);\n    //arithmetic to account for hex string\n  }\n}\n\nexports.abiSelector = abiSelector; //note: undefined does not match itself :P\n\nfunction abisMatch(entry1, entry2) {\n  //we'll consider two abi entries to match if they have the same\n  //type, name (if applicable), and inputs (if applicable).\n  //since there's already a signature function, we can just use that.\n  if (!entry1 || !entry2) {\n    return false;\n  }\n\n  if (entry1.type !== entry2.type) {\n    return false;\n  }\n\n  switch (entry1.type) {\n    case \"function\":\n    case \"event\":\n    case \"error\":\n      return abiSignature(entry1) === abiSignature(entry2);\n\n    case \"constructor\":\n      return abiTupleSignature(entry1.inputs) === abiTupleSignature(entry2.inputs);\n\n    case \"fallback\":\n    case \"receive\":\n      return true;\n  }\n}\n\nexports.abisMatch = abisMatch;\n\nfunction definitionMatchesAbi(abiEntry, definition, referenceDeclarations) {\n  try {\n    return abisMatch(abiEntry, Ast.Utils.definitionToAbi(definition, referenceDeclarations));\n  } catch (_) {\n    return false; //if an exception occurs, well, that's not a match!\n  }\n}\n\nexports.definitionMatchesAbi = definitionMatchesAbi;\n\nfunction topicsCount(abiEntry) {\n  let selectorCount = abiEntry.anonymous ? 0 : 1; //if the event is not anonymous, we must account for the selector\n\n  return abiEntry.inputs.filter(({\n    indexed\n  }) => indexed).length + selectorCount;\n}\n\nexports.topicsCount = topicsCount;\n\nfunction abiEntryIsObviouslyIllTyped(abiEntry) {\n  switch (abiEntry.type) {\n    case \"fallback\":\n    case \"receive\":\n      return false;\n\n    case \"constructor\":\n    case \"event\":\n    case \"error\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped);\n\n    case \"function\":\n      return abiEntry.inputs.some(abiParameterIsObviouslyIllTyped) || abiEntry.outputs.some(abiParameterIsObviouslyIllTyped);\n  }\n}\n\nexports.abiEntryIsObviouslyIllTyped = abiEntryIsObviouslyIllTyped;\n\nfunction abiParameterIsObviouslyIllTyped(abiParameter) {\n  const legalBaseTypeClasses = [\"uint\", \"int\", \"fixed\", \"ufixed\", \"bool\", \"address\", \"bytes\", \"string\", \"function\", \"tuple\"];\n  const baseTypeClass = abiParameter.type.match(/^([a-z]*)/)[1];\n  const baseTypeClassIsObviouslyWrong = !legalBaseTypeClasses.includes(baseTypeClass);\n\n  if (abiParameter.components) {\n    return abiParameter.components.some(abiParameterIsObviouslyIllTyped) || baseTypeClassIsObviouslyWrong;\n  } else {\n    return baseTypeClassIsObviouslyWrong;\n  }\n}\n\nfunction abiEntryHasStorageParameters(abiEntry) {\n  const isStorage = parameter => parameter.type.endsWith(\" storage\");\n\n  return abiEntry.type === \"function\" && (abiEntry.inputs.some(isStorage) || abiEntry.outputs.some(isStorage)); //Note the lack of recursion!  Storage parameters can only occur at\n  //top level so there's no need to recurse here\n  //(they can also only occur for functions)\n}\n\nexports.abiEntryHasStorageParameters = abiEntryHasStorageParameters;","map":null,"metadata":{},"sourceType":"script"}