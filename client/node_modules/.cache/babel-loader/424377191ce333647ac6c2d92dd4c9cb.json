{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.unsafeNativize = exports.unsafeNativizeVariables = exports.ResultInspector = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:format:utils:inspect\");\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst Format = __importStar(require(\"../common\"));\n\nconst Exception = __importStar(require(\"./exception\")); //HACK?\n\n\nfunction cleanStylize(options) {\n  const clonedOptions = Object.assign({}, options);\n  delete clonedOptions.stylize;\n  return clonedOptions;\n}\n/**\n * This class is meant to be used with Node's\n * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)\n * function.  Given a [[Format.Values.Result]] `value`, one can use\n * `new ResultInspector(value)` to create a ResultInspector for that value,\n * which can be used with util.inspect() to create a human-readable string\n * representing the value.\n *\n * @example\n * Suppose `value` is a Result.  In Node, the following would print to the\n * console a human-readable representation of `value`, with colors enabled,\n * no maximum depth, and no maximum array length, and lines (usually) no\n * longer than 80 characters:\n * ```javascript\n * console.log(\n *   util.inspect(\n *     new ResultInspector(value),\n *     {\n *       colors: true,\n *       depth: null,\n *       maxArrayLength: null,\n *       breakLength: 80\n *     }\n *   )\n * );\n * ```\n * Of course, there are many other ways to use util.inspect; see Node's\n * documentation, linked above, for more.\n */\n\n\nclass ResultInspector {\n  constructor(result) {\n    this.result = result;\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.result.kind) {\n      case \"value\":\n        switch (this.result.type.typeClass) {\n          case \"uint\":\n          case \"int\":\n            return options.stylize(this.result.value.asBN.toString(), \"number\");\n\n          case \"fixed\":\n          case \"ufixed\":\n            //note: because this is just for display, we don't bother adjusting the magic values Big.NE or Big.PE;\n            //we'll trust those to their defaults\n            return options.stylize(this.result.value.asBig.toString(), \"number\");\n\n          case \"bool\":\n            return util_1.default.inspect(this.result.value.asBoolean, options);\n\n          case \"bytes\":\n            let hex = this.result.value.asHex;\n\n            switch (this.result.type.kind) {\n              case \"static\":\n                return options.stylize(hex, \"number\");\n\n              case \"dynamic\":\n                return options.stylize(\"hex'\".concat(hex.slice(2), \"'\"), \"string\");\n            }\n\n          case \"address\":\n            return options.stylize(this.result.value.asAddress, \"number\");\n\n          case \"string\":\n            {\n              let coercedResult = this.result;\n\n              switch (coercedResult.value.kind) {\n                case \"valid\":\n                  return util_1.default.inspect(coercedResult.value.asString, options);\n\n                case \"malformed\":\n                  //note: this will turn malformed utf-8 into replacement characters (U+FFFD)\n                  //note we need to cut off the 0x prefix\n                  return util_1.default.inspect(Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString());\n              }\n            }\n\n          case \"array\":\n            {\n              let coercedResult = this.result;\n\n              if (coercedResult.reference !== undefined) {\n                return formatCircular(coercedResult.reference, options);\n              }\n\n              return util_1.default.inspect(coercedResult.value.map(element => new ResultInspector(element)), options);\n            }\n\n          case \"mapping\":\n            return util_1.default.inspect(new Map(this.result.value.map(({\n              key,\n              value\n            }) => [new ResultInspector(key), new ResultInspector(value)])), options);\n\n          case \"struct\":\n            {\n              let coercedResult = this.result;\n\n              if (coercedResult.reference !== undefined) {\n                return formatCircular(coercedResult.reference, options);\n              }\n\n              return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(({\n                name,\n                value\n              }) => ({\n                [name]: new ResultInspector(value)\n              }))), options);\n            }\n\n          case \"userDefinedValueType\":\n            {\n              const typeName = Format.Types.typeStringWithoutLocation(this.result.type);\n              const coercedResult = this.result;\n              const inspectOfUnderlying = util_1.default.inspect(new ResultInspector(coercedResult.value), options);\n              return \"\".concat(typeName, \".wrap(\").concat(inspectOfUnderlying, \")\"); //note only the underlying part is stylized\n            }\n\n          case \"tuple\":\n            {\n              let coercedResult = this.result; //if everything is named, do same as with struct.\n              //if not, just do an array.\n              //(good behavior in the mixed case is hard, unfortunately)\n\n              if (coercedResult.value.every(({\n                name\n              }) => name)) {\n                return util_1.default.inspect(Object.assign({}, ...coercedResult.value.map(({\n                  name,\n                  value\n                }) => ({\n                  [name]: new ResultInspector(value)\n                }))), options);\n              } else {\n                return util_1.default.inspect(coercedResult.value.map(({\n                  value\n                }) => new ResultInspector(value)), options);\n              }\n            }\n\n          case \"type\":\n            {\n              switch (this.result.type.type.typeClass) {\n                case \"contract\":\n                  //same as struct case but w/o circularity check\n                  return util_1.default.inspect(Object.assign({}, ...this.result.value.map(({\n                    name,\n                    value\n                  }) => ({\n                    [name]: new ResultInspector(value)\n                  }))), options);\n\n                case \"enum\":\n                  {\n                    return enumTypeName(this.result.type.type);\n                  }\n              }\n            }\n\n          case \"magic\":\n            return util_1.default.inspect(Object.assign({}, ...Object.entries(this.result.value).map(([key, value]) => ({\n              [key]: new ResultInspector(value)\n            }))), options);\n\n          case \"enum\":\n            {\n              return enumFullName(this.result); //not stylized\n            }\n\n          case \"contract\":\n            {\n              return util_1.default.inspect(new ContractInfoInspector(this.result.value), options);\n            }\n\n          case \"function\":\n            switch (this.result.type.visibility) {\n              case \"external\":\n                {\n                  let coercedResult = this.result;\n                  let contractString = util_1.default.inspect(new ContractInfoInspector(coercedResult.value.contract), Object.assign(Object.assign({}, cleanStylize(options)), {\n                    colors: false\n                  }));\n                  let firstLine;\n\n                  switch (coercedResult.value.kind) {\n                    case \"known\":\n                      firstLine = \"[Function: \".concat(coercedResult.value.abi.name, \" of\");\n                      break;\n\n                    case \"invalid\":\n                    case \"unknown\":\n                      firstLine = \"[Function: Unknown selector \".concat(coercedResult.value.selector, \" of\");\n                      break;\n                  }\n\n                  let secondLine = \"\".concat(contractString, \"]\");\n                  let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \"; //now, put it together\n\n                  return options.stylize(firstLine + breakingSpace + secondLine, \"special\");\n                }\n\n              case \"internal\":\n                {\n                  let coercedResult = this.result;\n\n                  switch (coercedResult.value.kind) {\n                    case \"function\":\n                      if (coercedResult.value.definedIn) {\n                        return options.stylize(\"[Function: \".concat(coercedResult.value.definedIn.typeName, \".\").concat(coercedResult.value.name, \"]\"), \"special\");\n                      } else {\n                        return options.stylize(\"[Function: \".concat(coercedResult.value.name, \"]\"), \"special\");\n                      }\n\n                    case \"exception\":\n                      return coercedResult.value.deployedProgramCounter === 0 ? options.stylize(\"[Function: <zero>]\", \"special\") : options.stylize(\"[Function: <uninitialized>]\", \"special\");\n\n                    case \"unknown\":\n                      let firstLine = \"[Function: decoding not supported (raw info:\";\n                      let secondLine = \"deployed PC=\".concat(coercedResult.value.deployedProgramCounter, \", constructor PC=\").concat(coercedResult.value.constructorProgramCounter, \")]\");\n                      let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \"; //now, put it together\n\n                      return options.stylize(firstLine + breakingSpace + secondLine, \"special\");\n                  }\n                }\n            }\n\n        }\n\n      case \"error\":\n        {\n          debug(\"this.result: %O\", this.result);\n          let errorResult = this.result; //the hell?? why couldn't it make this inference??\n\n          switch (errorResult.error.kind) {\n            case \"WrappedError\":\n              return util_1.default.inspect(new ResultInspector(errorResult.error.error), options);\n\n            case \"UintPaddingError\":\n              return \"Uint has incorrect padding (expected padding: \".concat(errorResult.error.paddingType, \") (raw value \").concat(errorResult.error.raw, \")\");\n\n            case \"IntPaddingError\":\n              return \"Int has incorrect padding (expected padding: \".concat(errorResult.error.paddingType, \") (raw value \").concat(errorResult.error.raw, \")\");\n\n            case \"UintPaddingError\":\n              return \"Ufixed has (expected padding: \".concat(errorResult.error.paddingType, \") (raw value \").concat(errorResult.error.raw, \")\");\n\n            case \"FixedPaddingError\":\n              return \"Fixed has incorrect padding (expected padding: \".concat(errorResult.error.paddingType, \") (raw value \").concat(errorResult.error.raw, \")\");\n\n            case \"BoolOutOfRangeError\":\n              return \"Invalid boolean (numeric value \".concat(errorResult.error.rawAsBN.toString(), \")\");\n\n            case \"BoolPaddingError\":\n              return \"Boolean has incorrect padding (expected padding: \".concat(errorResult.error.paddingType, \") (raw value \").concat(errorResult.error.raw, \")\");\n\n            case \"BytesPaddingError\":\n              return \"Bytestring has extra trailing bytes (padding error) (raw value \".concat(errorResult.error.raw, \")\");\n\n            case \"AddressPaddingError\":\n              return \"Address has incorrect padding (expected padding: \".concat(errorResult.error.paddingType, \") (raw value \").concat(errorResult.error.raw, \")\");\n\n            case \"EnumOutOfRangeError\":\n              return \"Invalid \".concat(enumTypeName(errorResult.error.type), \" (numeric value \").concat(errorResult.error.rawAsBN.toString(), \")\");\n\n            case \"EnumPaddingError\":\n              return \"Enum \".concat(enumTypeName(errorResult.error.type), \" has incorrect padding (expected padding: \").concat(errorResult.error.paddingType, \") (raw value \").concat(errorResult.error.raw, \")\");\n\n            case \"EnumNotFoundDecodingError\":\n              return \"Unknown enum type \".concat(enumTypeName(errorResult.error.type), \" of id \").concat(errorResult.error.type.id, \" (numeric value \").concat(errorResult.error.rawAsBN.toString(), \")\");\n\n            case \"ContractPaddingError\":\n              return \"Contract address has incorrect padding (expected padding: \".concat(errorResult.error.paddingType, \") (raw value \").concat(errorResult.error.raw, \")\");\n\n            case \"FunctionExternalNonStackPaddingError\":\n              return \"External function has incorrect padding (expected padding: \".concat(errorResult.error.paddingType, \") (raw value \").concat(errorResult.error.raw, \")\");\n\n            case \"FunctionExternalStackPaddingError\":\n              return \"External function address or selector has extra leading bytes (padding error) (raw address \".concat(errorResult.error.rawAddress, \", raw selector \").concat(errorResult.error.rawSelector, \")\");\n\n            case \"FunctionInternalPaddingError\":\n              return \"Internal function has incorrect padding (expected padding: \".concat(errorResult.error.paddingType, \") (raw value \").concat(errorResult.error.raw, \")\");\n\n            case \"NoSuchInternalFunctionError\":\n              return \"Invalid function (Deployed PC=\".concat(errorResult.error.deployedProgramCounter, \", constructor PC=\").concat(errorResult.error.constructorProgramCounter, \") of contract \").concat(errorResult.error.context.typeName);\n\n            case \"DeployedFunctionInConstructorError\":\n              return \"Deployed-style function (PC=\".concat(errorResult.error.deployedProgramCounter, \") in constructor\");\n\n            case \"MalformedInternalFunctionError\":\n              return \"Malformed internal function w/constructor PC only (value: \".concat(errorResult.error.constructorProgramCounter, \")\");\n\n            case \"IndexedReferenceTypeError\":\n              //for this one we'll bother with some line-wrapping\n              let firstLine = \"Cannot decode indexed parameter of reference type \".concat(errorResult.error.type.typeClass);\n              let secondLine = \"(raw value \".concat(errorResult.error.raw, \")\");\n              let breakingSpace = firstLine.length + secondLine.length + 1 > options.breakLength ? \"\\n\" : \" \";\n              return firstLine + breakingSpace + secondLine;\n\n            case \"OverlongArraysAndStringsNotImplementedError\":\n              return \"Array or string is too long (length \".concat(errorResult.error.lengthAsBN.toString(), \"); decoding is not supported\");\n\n            case \"OverlargePointersNotImplementedError\":\n              return \"Pointer is too large (value \".concat(errorResult.error.pointerAsBN.toString(), \"); decoding is not supported\");\n\n            case \"UserDefinedTypeNotFoundError\":\n            case \"UnsupportedConstantError\":\n            case \"UnusedImmutableError\":\n            case \"ReadErrorStack\":\n            case \"ReadErrorStorage\":\n            case \"ReadErrorBytes\":\n              return Exception.message(errorResult.error);\n            //yay, these five are already defined!\n          }\n        }\n    }\n  }\n\n}\n\nexports.ResultInspector = ResultInspector; //these get their own class to deal with a minor complication\n\nclass ContractInfoInspector {\n  constructor(value) {\n    this.value = value;\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.value.kind) {\n      case \"known\":\n        return options.stylize(this.value.address, \"number\") + \" (\".concat(this.value.class.typeName, \")\");\n\n      case \"unknown\":\n        return options.stylize(this.value.address, \"number\") + \" of unknown class\";\n    }\n  }\n\n}\n\nfunction enumTypeName(enumType) {\n  return (enumType.kind === \"local\" ? enumType.definingContractName + \".\" : \"\") + enumType.typeName;\n} //this function will be used in the future for displaying circular\n//structures\n\n\nfunction formatCircular(loopLength, options) {\n  return options.stylize(\"[Circular (=up \".concat(loopLength, \")]\"), \"special\");\n}\n\nfunction enumFullName(value) {\n  switch (value.type.kind) {\n    case \"local\":\n      return \"\".concat(value.type.definingContractName, \".\").concat(value.type.typeName, \".\").concat(value.value.name);\n\n    case \"global\":\n      return \"\".concat(value.type.typeName, \".\").concat(value.value.name);\n  }\n}\n/**\n * WARNING! Do NOT use this function in real code unless you\n * absolutely have to!  Using it in controlled tests is fine,\n * but do NOT use it in real code if you have any better option!\n * See [[unsafeNativize]] for why!\n */\n\n\nfunction unsafeNativizeVariables(variables) {\n  return Object.assign({}, ...Object.entries(variables).map(([name, value]) => {\n    try {\n      return {\n        [name]: unsafeNativize(value)\n      };\n    } catch (_) {\n      return undefined; //I guess??\n    }\n  }));\n}\n\nexports.unsafeNativizeVariables = unsafeNativizeVariables; //HACK! Avoid using!\n\n/**\n * WARNING! Do NOT use this function in real code unless you absolutely have\n * to!  Using it in controlled tests is fine, but do NOT use it in real code if\n * you have any better option!\n *\n * This function is a giant hack.  It will throw exceptions on numbers that\n * don't fit in a Javascript number.  It loses various information.  It was\n * only ever written to support our hacked-together watch expression system,\n * and later repurposed to make testing easier.\n *\n * If you are not doing something as horrible as evaluating user-inputted\n * Javascript expressions meant to operate upon Solidity variables, then you\n * probably have a better option than using this in real code!\n *\n * (For instance, if you just want to nicely print individual values, without\n * attempting to first operate on them via Javascript expressions, we have the\n * [[ResultInspector]] class, which can be used with Node's\n * [util.inspect()](https://nodejs.org/api/util.html#util_util_inspect_object_options)\n * to do exactly that.)\n *\n * Remember, the decoder output format was made to be machine-readable.  It\n * shouldn't be too hard for you to process.  If it comes to it, copy-paste\n * this code and dehackify it for your use case, which hopefully is more\n * manageable than the one that caused us to write this.\n */\n\nfunction unsafeNativize(result) {\n  return unsafeNativizeWithTable(result, []);\n}\n\nexports.unsafeNativize = unsafeNativize;\n\nfunction unsafeNativizeWithTable(result, seenSoFar) {\n  if (result.kind === \"error\") {\n    debug(\"ErrorResult: %O\", result);\n\n    switch (result.error.kind) {\n      case \"BoolOutOfRangeError\":\n        return true;\n\n      default:\n        return undefined;\n    }\n  } //NOTE: for simplicity, only arrays & structs will call unsafeNativizeWithTable;\n  //other containers will just call unsafeNativize because they can get away with it\n  //(only things that can *be* circular need unsafeNativizeWithTable, not things that\n  //can merely *contain* circularities)\n\n\n  switch (result.type.typeClass) {\n    case \"uint\":\n    case \"int\":\n      return result.value.asBN.toNumber();\n    //WARNING\n\n    case \"bool\":\n      return result.value.asBoolean;\n\n    case \"bytes\":\n      return result.value.asHex;\n\n    case \"address\":\n      return result.value.asAddress;\n\n    case \"string\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.value.kind) {\n          case \"valid\":\n            return coercedResult.value.asString;\n\n          case \"malformed\":\n            // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n            // note we need to cut off the 0x prefix\n            return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n        }\n      }\n\n    case \"fixed\":\n    case \"ufixed\":\n      //HACK: Big doesn't have a toNumber() method, so we convert to string and then parse with Number\n      //NOTE: we don't bother setting the magic variables Big.NE or Big.PE first, as the choice of\n      //notation shouldn't affect the result (can you believe I have to write this? @_@)\n      return Number(result.value.asBig.toString());\n    //WARNING\n\n    case \"array\":\n      {\n        let coercedResult = result;\n\n        if (coercedResult.reference === undefined) {\n          //we need to do some pointer stuff here, so let's first create our new\n          //object we'll be pointing to\n          //[we don't want to alter the original accidentally so let's clone a bit]\n          let output = [...coercedResult.value]; //now, we can't use a map here, or we'll screw things up!\n          //we want to *mutate* output, not replace it with a new object\n\n          for (let index in output) {\n            output[index] = unsafeNativizeWithTable(output[index], [output, ...seenSoFar]);\n          }\n\n          return output;\n        } else {\n          return seenSoFar[coercedResult.reference - 1];\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        return unsafeNativize(result.value);\n      }\n\n    case \"mapping\":\n      return Object.assign({}, ...result.value.map(({\n        key,\n        value\n      }) => ({\n        [unsafeNativize(key).toString()]: unsafeNativize(value)\n      })));\n\n    case \"struct\":\n      {\n        let coercedResult = result;\n\n        if (coercedResult.reference === undefined) {\n          //we need to do some pointer stuff here, so let's first create our new\n          //object we'll be pointing to\n          let output = Object.assign({}, ...result.value.map(({\n            name,\n            value\n          }) => ({\n            [name]: value //we *don't* nativize yet!\n\n          }))); //now, we can't use a map here, or we'll screw things up!\n          //we want to *mutate* output, not replace it with a new object\n\n          for (let name in output) {\n            output[name] = unsafeNativizeWithTable(output[name], [output, ...seenSoFar]);\n          }\n\n          return output;\n        } else {\n          return seenSoFar[coercedResult.reference - 1];\n        }\n      }\n\n    case \"type\":\n      switch (result.type.type.typeClass) {\n        case \"contract\":\n          return Object.assign({}, ...result.value.map(({\n            name,\n            value\n          }) => ({\n            [name]: unsafeNativize(value)\n          })));\n\n        case \"enum\":\n          return Object.assign({}, ...result.value.map(enumValue => ({\n            [enumValue.value.name]: unsafeNativize(enumValue)\n          })));\n      }\n\n    case \"tuple\":\n      return result.value.map(({\n        value\n      }) => unsafeNativize(value));\n\n    case \"magic\":\n      return Object.assign({}, ...Object.entries(result.value).map(([key, value]) => ({\n        [key]: unsafeNativize(value)\n      })));\n\n    case \"enum\":\n      return enumFullName(result);\n\n    case \"contract\":\n      return result.value.address;\n    //we no longer include additional info\n\n    case \"function\":\n      switch (result.type.visibility) {\n        case \"external\":\n          {\n            let coercedResult = result;\n\n            switch (coercedResult.value.kind) {\n              case \"known\":\n                return \"\".concat(coercedResult.value.contract.class.typeName, \"(\").concat(coercedResult.value.contract.address, \").\").concat(coercedResult.value.abi.name);\n\n              case \"invalid\":\n                return \"\".concat(coercedResult.value.contract.class.typeName, \"(\").concat(coercedResult.value.contract.address, \").call(\").concat(coercedResult.value.selector, \"...)\");\n\n              case \"unknown\":\n                return \"\".concat(coercedResult.value.contract.address, \".call(\").concat(coercedResult.value.selector, \"...)\");\n            }\n          }\n\n        case \"internal\":\n          {\n            let coercedResult = result;\n\n            switch (coercedResult.value.kind) {\n              case \"function\":\n                if (coercedResult.value.definedIn) {\n                  return \"\".concat(coercedResult.value.definedIn.typeName, \".\").concat(coercedResult.value.name);\n                } else {\n                  return coercedResult.value.name;\n                }\n\n              case \"exception\":\n                return coercedResult.value.deployedProgramCounter === 0 ? \"<zero>\" : \"<uninitialized>\";\n\n              case \"unknown\":\n                return \"<decoding not supported>\";\n            }\n          }\n      }\n\n  }\n}","map":null,"metadata":{},"sourceType":"script"}