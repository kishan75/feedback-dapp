{"ast":null,"code":"/**\n * @namespace faker.finance\n */\nvar Finance = function (faker) {\n  var ibanLib = require(\"./iban\");\n\n  var Helpers = faker.helpers,\n      self = this;\n  /**\n   * account\n   *\n   * @method faker.finance.account\n   * @param {number} length\n   */\n\n  self.account = function (length) {\n    length = length || 8;\n    var template = '';\n\n    for (var i = 0; i < length; i++) {\n      template = template + '#';\n    }\n\n    length = null;\n    return Helpers.replaceSymbolWithNumber(template);\n  };\n  /**\n   * accountName\n   *\n   * @method faker.finance.accountName\n   */\n\n\n  self.accountName = function () {\n    return [Helpers.randomize(faker.definitions.finance.account_type), 'Account'].join(' ');\n  };\n  /**\n   * routingNumber\n   *\n   * @method faker.finance.routingNumber\n   */\n\n\n  self.routingNumber = function () {\n    var routingNumber = Helpers.replaceSymbolWithNumber('########'); // Modules 10 straight summation.\n\n    var sum = 0;\n\n    for (var i = 0; i < routingNumber.length; i += 3) {\n      sum += Number(routingNumber[i]) * 3;\n      sum += Number(routingNumber[i + 1]) * 7;\n      sum += Number(routingNumber[i + 2]) || 0;\n    }\n\n    return routingNumber + (Math.ceil(sum / 10) * 10 - sum);\n  };\n  /**\n   * mask\n   *\n   * @method faker.finance.mask\n   * @param {number} length\n   * @param {boolean} parens\n   * @param {boolean} ellipsis\n   */\n\n\n  self.mask = function (length, parens, ellipsis) {\n    //set defaults\n    length = length == 0 || !length || typeof length == 'undefined' ? 4 : length;\n    parens = parens === null ? true : parens;\n    ellipsis = ellipsis === null ? true : ellipsis; //create a template for length\n\n    var template = '';\n\n    for (var i = 0; i < length; i++) {\n      template = template + '#';\n    } //prefix with ellipsis\n\n\n    template = ellipsis ? ['...', template].join('') : template;\n    template = parens ? ['(', template, ')'].join('') : template; //generate random numbers\n\n    template = Helpers.replaceSymbolWithNumber(template);\n    return template;\n  }; //min and max take in minimum and maximum amounts, dec is the decimal place you want rounded to, symbol is $, €, £, etc\n  //NOTE: this returns a string representation of the value, if you want a number use parseFloat and no symbol\n\n  /**\n   * amount\n   *\n   * @method faker.finance.amount\n   * @param {number} min\n   * @param {number} max\n   * @param {number} dec\n   * @param {string} symbol\n   *\n   * @return {string}\n   */\n\n\n  self.amount = function (min, max, dec, symbol, autoFormat) {\n    min = min || 0;\n    max = max || 1000;\n    dec = dec === undefined ? 2 : dec;\n    symbol = symbol || '';\n    const randValue = faker.datatype.number({\n      max: max,\n      min: min,\n      precision: Math.pow(10, -dec)\n    });\n    var formattedString;\n\n    if (autoFormat) {\n      formattedString = randValue.toLocaleString(undefined, {\n        minimumFractionDigits: dec\n      });\n    } else {\n      formattedString = randValue.toFixed(dec);\n    }\n\n    return symbol + formattedString;\n  };\n  /**\n   * transactionType\n   *\n   * @method faker.finance.transactionType\n   */\n\n\n  self.transactionType = function () {\n    return Helpers.randomize(faker.definitions.finance.transaction_type);\n  };\n  /**\n   * currencyCode\n   *\n   * @method faker.finance.currencyCode\n   */\n\n\n  self.currencyCode = function () {\n    return faker.random.objectElement(faker.definitions.finance.currency)['code'];\n  };\n  /**\n   * currencyName\n   *\n   * @method faker.finance.currencyName\n   */\n\n\n  self.currencyName = function () {\n    return faker.random.objectElement(faker.definitions.finance.currency, 'key');\n  };\n  /**\n   * currencySymbol\n   *\n   * @method faker.finance.currencySymbol\n   */\n\n\n  self.currencySymbol = function () {\n    var symbol;\n\n    while (!symbol) {\n      symbol = faker.random.objectElement(faker.definitions.finance.currency)['symbol'];\n    }\n\n    return symbol;\n  };\n  /**\n   * bitcoinAddress\n   *\n   * @method  faker.finance.bitcoinAddress\n   */\n\n\n  self.bitcoinAddress = function () {\n    var addressLength = faker.datatype.number({\n      min: 25,\n      max: 34\n    });\n    var address = faker.random.arrayElement(['1', '3']);\n\n    for (var i = 0; i < addressLength - 1; i++) address += faker.random.arrayElement('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'.split(''));\n\n    return address;\n  };\n  /**\n   * litecoinAddress\n   *\n   * @method  faker.finance.litecoinAddress\n   */\n\n\n  self.litecoinAddress = function () {\n    var addressLength = faker.datatype.number({\n      min: 26,\n      max: 33\n    });\n    var address = faker.random.arrayElement(['L', 'M', '3']);\n\n    for (var i = 0; i < addressLength - 1; i++) address += faker.random.arrayElement('123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ'.split(''));\n\n    return address;\n  };\n  /**\n   * Credit card number\n   * @method faker.finance.creditCardNumber\n   * @param {string} provider | scheme\n  */\n\n\n  self.creditCardNumber = function (provider) {\n    provider = provider || \"\";\n    var format, formats;\n    var localeFormat = faker.definitions.finance.credit_card;\n\n    if (provider in localeFormat) {\n      formats = localeFormat[provider]; // there chould be multiple formats\n\n      if (typeof formats === \"string\") {\n        format = formats;\n      } else {\n        format = faker.random.arrayElement(formats);\n      }\n    } else if (provider.match(/#/)) {\n      // The user chose an optional scheme\n      format = provider;\n    } else {\n      // Choose a random provider\n      if (typeof localeFormat === 'string') {\n        format = localeFormat;\n      } else if (typeof localeFormat === \"object\") {\n        // Credit cards are in a object structure\n        formats = faker.random.objectElement(localeFormat, \"value\"); // There chould be multiple formats\n\n        if (typeof formats === \"string\") {\n          format = formats;\n        } else {\n          format = faker.random.arrayElement(formats);\n        }\n      }\n    }\n\n    format = format.replace(/\\//g, \"\");\n    return Helpers.replaceCreditCardSymbols(format);\n  };\n  /**\n   * Credit card CVV\n   * @method faker.finance.creditCardCVV\n  */\n\n\n  self.creditCardCVV = function () {\n    var cvv = \"\";\n\n    for (var i = 0; i < 3; i++) {\n      cvv += faker.datatype.number({\n        max: 9\n      }).toString();\n    }\n\n    return cvv;\n  };\n  /**\n   * ethereumAddress\n   *\n   * @method  faker.finance.ethereumAddress\n   */\n\n\n  self.ethereumAddress = function () {\n    var address = faker.datatype.hexaDecimal(40).toLowerCase();\n    return address;\n  };\n  /**\n   * iban\n   *\n   * @param {boolean} [formatted=false] - Return a formatted version of the generated IBAN.\n   * @param {string} [countryCode] - The country code from which you want to generate an IBAN, if none is provided a random country will be used.\n   * @throws Will throw an error if the passed country code is not supported.\n   *\n   * @method  faker.finance.iban\n   */\n\n\n  self.iban = function (formatted, countryCode) {\n    var ibanFormat;\n\n    if (countryCode) {\n      var findFormat = function (currentFormat) {\n        return currentFormat.country === countryCode;\n      };\n\n      ibanFormat = ibanLib.formats.find(findFormat);\n    } else {\n      ibanFormat = faker.random.arrayElement(ibanLib.formats);\n    }\n\n    if (!ibanFormat) {\n      throw new Error('Country code ' + countryCode + ' not supported.');\n    }\n\n    var s = \"\";\n    var count = 0;\n\n    for (var b = 0; b < ibanFormat.bban.length; b++) {\n      var bban = ibanFormat.bban[b];\n      var c = bban.count;\n      count += bban.count;\n\n      while (c > 0) {\n        if (bban.type == \"a\") {\n          s += faker.random.arrayElement(ibanLib.alpha);\n        } else if (bban.type == \"c\") {\n          if (faker.datatype.number(100) < 80) {\n            s += faker.datatype.number(9);\n          } else {\n            s += faker.random.arrayElement(ibanLib.alpha);\n          }\n        } else {\n          if (c >= 3 && faker.datatype.number(100) < 30) {\n            if (faker.datatype.boolean()) {\n              s += faker.random.arrayElement(ibanLib.pattern100);\n              c -= 2;\n            } else {\n              s += faker.random.arrayElement(ibanLib.pattern10);\n              c--;\n            }\n          } else {\n            s += faker.datatype.number(9);\n          }\n        }\n\n        c--;\n      }\n\n      s = s.substring(0, count);\n    }\n\n    var checksum = 98 - ibanLib.mod97(ibanLib.toDigitString(s + ibanFormat.country + \"00\"));\n\n    if (checksum < 10) {\n      checksum = \"0\" + checksum;\n    }\n\n    var iban = ibanFormat.country + checksum + s;\n    return formatted ? iban.match(/.{1,4}/g).join(\" \") : iban;\n  };\n  /**\n   * bic\n   *\n   * @method  faker.finance.bic\n   */\n\n\n  self.bic = function () {\n    var vowels = [\"A\", \"E\", \"I\", \"O\", \"U\"];\n    var prob = faker.datatype.number(100);\n    return Helpers.replaceSymbols(\"???\") + faker.random.arrayElement(vowels) + faker.random.arrayElement(ibanLib.iso3166) + Helpers.replaceSymbols(\"?\") + \"1\" + (prob < 10 ? Helpers.replaceSymbols(\"?\" + faker.random.arrayElement(vowels) + \"?\") : prob < 40 ? Helpers.replaceSymbols(\"###\") : \"\");\n  };\n  /**\n   * description\n   *\n   * @method  faker.finance.transactionDescription\n   */\n\n\n  self.transactionDescription = function () {\n    var transaction = Helpers.createTransaction();\n    var account = transaction.account;\n    var amount = transaction.amount;\n    var transactionType = transaction.type;\n    var company = transaction.business;\n    var card = faker.finance.mask();\n    var currency = faker.finance.currencyCode();\n    return transactionType + \" transaction at \" + company + \" using card ending with ***\" + card + \" for \" + currency + \" \" + amount + \" in account ***\" + account;\n  };\n};\n\nmodule['exports'] = Finance;","map":null,"metadata":{},"sourceType":"script"}