{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.equalSlots = exports.slotAddress = exports.storageLengthToBytes = exports.isWordsLength = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:storage:utils\");\n\nconst Evm = __importStar(require(\"../evm\"));\n\nconst MappingKey = __importStar(require(\"../mapping-key\"));\n\nfunction isWordsLength(size) {\n  return size.words !== undefined;\n}\n\nexports.isWordsLength = isWordsLength;\n\nfunction storageLengthToBytes(size) {\n  if (isWordsLength(size)) {\n    debug(\"size.words %d\", size.words);\n    return size.words * Evm.Utils.WORD_SIZE;\n  } else {\n    return size.bytes;\n  }\n}\n\nexports.storageLengthToBytes = storageLengthToBytes;\n/**\n * convert a slot to a word corresponding to actual storage address\n *\n * if `slot` is an array, return hash of array values.\n * if `slot` array is nested, recurse on sub-arrays\n *\n * @param slot - number or possibly-nested array of numbers\n */\n\nfunction slotAddress(slot) {\n  if (slot.key !== undefined && slot.path !== undefined) {\n    // mapping reference\n    return Evm.Utils.keccak256(MappingKey.Encode.mappingKeyAsHex(slot.key), slotAddress(slot.path)).add(slot.offset);\n  } else if (slot.path !== undefined) {\n    const pathAddress = slotAddress(slot.path);\n    const path = slot.hashPath ? Evm.Utils.keccak256(pathAddress) : pathAddress;\n    return path.add(slot.offset);\n  } else {\n    return slot.offset;\n  }\n}\n\nexports.slotAddress = slotAddress; //note: this function compares slots mostly by structure,\n//rather than by their numerical value\n\nfunction equalSlots(slot1, slot2) {\n  if (!slot1 || !slot2) {\n    return !slot1 && !slot2; //if either is undefined, it's true only if both are\n  }\n\n  if (!slot1.offset.eq(slot2.offset)) {\n    return false;\n  }\n\n  if (slot1.hashPath !== slot2.hashPath) {\n    return false;\n  }\n\n  if (!equalSlots(slot1.path, slot2.path)) {\n    return false;\n  } //to compare keys, we'll just compare their hex encodings\n  //(yes, that leaves some wiggle room, as it could consider different\n  //*types* of keys to be equal, but if keys are the only difference then\n  //that should determine those types, so it shouldn't be a problem)\n\n\n  if (!slot1.key || !slot2.key) {\n    //first, though, they likely don't *have* keys\n    return !slot1.key && !slot2.key;\n  } //if they do have keys, though...\n\n\n  return Evm.Utils.equalData(MappingKey.Encode.encodeMappingKey(slot1.key), MappingKey.Encode.encodeMappingKey(slot2.key));\n}\n\nexports.equalSlots = equalSlots;","map":null,"metadata":{},"sourceType":"script"}