{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:decode\");\n\nconst AstConstant = __importStar(require(\"./ast-constant\"));\n\nconst AbiData = __importStar(require(\"./abi-data\"));\n\nconst Compiler = __importStar(require(\"./compiler\"));\n\nconst Format = __importStar(require(\"./format\"));\n\nconst Basic = __importStar(require(\"./basic\"));\n\nconst Memory = __importStar(require(\"./memory\"));\n\nconst Special = __importStar(require(\"./special\"));\n\nconst Stack = __importStar(require(\"./stack\"));\n\nconst Storage = __importStar(require(\"./storage\"));\n\nconst Topic = __importStar(require(\"./topic\"));\n\nfunction* decode(dataType, pointer, info, options = {}) {\n  return Format.Utils.Circularity.tie((yield* decodeDispatch(dataType, pointer, info, options)));\n}\n\nexports.default = decode;\n\nfunction* decodeDispatch(dataType, pointer, info, options = {}) {\n  debug(\"type %O\", dataType);\n  debug(\"pointer %O\", pointer);\n\n  switch (pointer.location) {\n    case \"storage\":\n      return yield* Storage.Decode.decodeStorage(dataType, pointer, info);\n\n    case \"stack\":\n      return yield* Stack.Decode.decodeStack(dataType, pointer, info);\n\n    case \"stackliteral\":\n      return yield* Stack.Decode.decodeLiteral(dataType, pointer, info);\n\n    case \"definition\":\n      return yield* AstConstant.Decode.decodeConstant(dataType, pointer, info);\n\n    case \"special\":\n      return yield* Special.Decode.decodeSpecial(dataType, pointer, info);\n\n    case \"calldata\":\n    case \"eventdata\":\n    case \"returndata\":\n      return yield* AbiData.Decode.decodeAbi(dataType, pointer, info, options);\n\n    case \"eventtopic\":\n      return yield* Topic.Decode.decodeTopic(dataType, pointer, info, options);\n\n    case \"code\":\n    case \"nowhere\":\n      //currently only basic types can go in code, so we'll dispatch directly to decodeBasic\n      //(if it's a nowhere pointer, this will return an error result, of course)\n      //(also, Solidity <0.8.9 would always zero-pad immutables regardless of type,\n      //so we have to set the padding mode appropriately to allow for this)\n      return yield* Basic.Decode.decodeBasic(dataType, pointer, info, Object.assign(Object.assign({}, options), {\n        paddingMode: \"defaultOrZero\"\n      }));\n\n    case \"memory\":\n      //this case -- decoding something that resides *directly* in memory,\n      //rather than located via a pointer -- only comes up when decoding immutables\n      //in a constructor.  thus, we turn on the forceRightPadding option on Solidity\n      //versions prior to 0.8.9, because before then all immutables would be right-padded\n      //while in memory\n      switch (Compiler.Utils.solidityFamily(info.currentContext.compiler)) {\n        case \"0.5.x\":\n        case \"0.8.x\":\n        case \"0.8.7+\":\n          return yield* Memory.Decode.decodeMemory(dataType, pointer, info, Object.assign(Object.assign({}, options), {\n            paddingMode: \"right\"\n          }));\n\n        default:\n          return yield* Memory.Decode.decodeMemory(dataType, pointer, info, options);\n      }\n\n  }\n}","map":null,"metadata":{},"sourceType":"script"}