{"ast":null,"code":"'use strict';\n\nconst Tokenizer = require('../tokenizer');\n\nconst OpenElementStack = require('./open-element-stack');\n\nconst FormattingElementList = require('./formatting-element-list');\n\nconst LocationInfoParserMixin = require('../extensions/location-info/parser-mixin');\n\nconst ErrorReportingParserMixin = require('../extensions/error-reporting/parser-mixin');\n\nconst Mixin = require('../utils/mixin');\n\nconst defaultTreeAdapter = require('../tree-adapters/default');\n\nconst mergeOptions = require('../utils/merge-options');\n\nconst doctype = require('../common/doctype');\n\nconst foreignContent = require('../common/foreign-content');\n\nconst ERR = require('../common/error-codes');\n\nconst unicode = require('../common/unicode');\n\nconst HTML = require('../common/html'); //Aliases\n\n\nconst $ = HTML.TAG_NAMES;\nconst NS = HTML.NAMESPACES;\nconst ATTRS = HTML.ATTRS;\nconst DEFAULT_OPTIONS = {\n  scriptingEnabled: true,\n  sourceCodeLocationInfo: false,\n  onParseError: null,\n  treeAdapter: defaultTreeAdapter\n}; //Misc constants\n\nconst HIDDEN_INPUT_TYPE = 'hidden'; //Adoption agency loops iteration count\n\nconst AA_OUTER_LOOP_ITER = 8;\nconst AA_INNER_LOOP_ITER = 3; //Insertion modes\n\nconst INITIAL_MODE = 'INITIAL_MODE';\nconst BEFORE_HTML_MODE = 'BEFORE_HTML_MODE';\nconst BEFORE_HEAD_MODE = 'BEFORE_HEAD_MODE';\nconst IN_HEAD_MODE = 'IN_HEAD_MODE';\nconst IN_HEAD_NO_SCRIPT_MODE = 'IN_HEAD_NO_SCRIPT_MODE';\nconst AFTER_HEAD_MODE = 'AFTER_HEAD_MODE';\nconst IN_BODY_MODE = 'IN_BODY_MODE';\nconst TEXT_MODE = 'TEXT_MODE';\nconst IN_TABLE_MODE = 'IN_TABLE_MODE';\nconst IN_TABLE_TEXT_MODE = 'IN_TABLE_TEXT_MODE';\nconst IN_CAPTION_MODE = 'IN_CAPTION_MODE';\nconst IN_COLUMN_GROUP_MODE = 'IN_COLUMN_GROUP_MODE';\nconst IN_TABLE_BODY_MODE = 'IN_TABLE_BODY_MODE';\nconst IN_ROW_MODE = 'IN_ROW_MODE';\nconst IN_CELL_MODE = 'IN_CELL_MODE';\nconst IN_SELECT_MODE = 'IN_SELECT_MODE';\nconst IN_SELECT_IN_TABLE_MODE = 'IN_SELECT_IN_TABLE_MODE';\nconst IN_TEMPLATE_MODE = 'IN_TEMPLATE_MODE';\nconst AFTER_BODY_MODE = 'AFTER_BODY_MODE';\nconst IN_FRAMESET_MODE = 'IN_FRAMESET_MODE';\nconst AFTER_FRAMESET_MODE = 'AFTER_FRAMESET_MODE';\nconst AFTER_AFTER_BODY_MODE = 'AFTER_AFTER_BODY_MODE';\nconst AFTER_AFTER_FRAMESET_MODE = 'AFTER_AFTER_FRAMESET_MODE'; //Insertion mode reset map\n\nconst INSERTION_MODE_RESET_MAP = {\n  [$.TR]: IN_ROW_MODE,\n  [$.TBODY]: IN_TABLE_BODY_MODE,\n  [$.THEAD]: IN_TABLE_BODY_MODE,\n  [$.TFOOT]: IN_TABLE_BODY_MODE,\n  [$.CAPTION]: IN_CAPTION_MODE,\n  [$.COLGROUP]: IN_COLUMN_GROUP_MODE,\n  [$.TABLE]: IN_TABLE_MODE,\n  [$.BODY]: IN_BODY_MODE,\n  [$.FRAMESET]: IN_FRAMESET_MODE\n}; //Template insertion mode switch map\n\nconst TEMPLATE_INSERTION_MODE_SWITCH_MAP = {\n  [$.CAPTION]: IN_TABLE_MODE,\n  [$.COLGROUP]: IN_TABLE_MODE,\n  [$.TBODY]: IN_TABLE_MODE,\n  [$.TFOOT]: IN_TABLE_MODE,\n  [$.THEAD]: IN_TABLE_MODE,\n  [$.COL]: IN_COLUMN_GROUP_MODE,\n  [$.TR]: IN_TABLE_BODY_MODE,\n  [$.TD]: IN_ROW_MODE,\n  [$.TH]: IN_ROW_MODE\n}; //Token handlers map for insertion modes\n\nconst TOKEN_HANDLERS = {\n  [INITIAL_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,\n    [Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,\n    [Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,\n    [Tokenizer.EOF_TOKEN]: tokenInInitialMode\n  },\n  [BEFORE_HTML_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,\n    [Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,\n    [Tokenizer.EOF_TOKEN]: tokenBeforeHtml\n  },\n  [BEFORE_HEAD_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n    [Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,\n    [Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,\n    [Tokenizer.EOF_TOKEN]: tokenBeforeHead\n  },\n  [IN_HEAD_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: tokenInHead,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n    [Tokenizer.START_TAG_TOKEN]: startTagInHead,\n    [Tokenizer.END_TAG_TOKEN]: endTagInHead,\n    [Tokenizer.EOF_TOKEN]: tokenInHead\n  },\n  [IN_HEAD_NO_SCRIPT_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n    [Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,\n    [Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,\n    [Tokenizer.EOF_TOKEN]: tokenInHeadNoScript\n  },\n  [AFTER_HEAD_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,\n    [Tokenizer.START_TAG_TOKEN]: startTagAfterHead,\n    [Tokenizer.END_TAG_TOKEN]: endTagAfterHead,\n    [Tokenizer.EOF_TOKEN]: tokenAfterHead\n  },\n  [IN_BODY_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagInBody,\n    [Tokenizer.END_TAG_TOKEN]: endTagInBody,\n    [Tokenizer.EOF_TOKEN]: eofInBody\n  },\n  [TEXT_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.COMMENT_TOKEN]: ignoreToken,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: ignoreToken,\n    [Tokenizer.END_TAG_TOKEN]: endTagInText,\n    [Tokenizer.EOF_TOKEN]: eofInText\n  },\n  [IN_TABLE_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: characterInTable,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagInTable,\n    [Tokenizer.END_TAG_TOKEN]: endTagInTable,\n    [Tokenizer.EOF_TOKEN]: eofInBody\n  },\n  [IN_TABLE_TEXT_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: characterInTableText,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,\n    [Tokenizer.COMMENT_TOKEN]: tokenInTableText,\n    [Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,\n    [Tokenizer.START_TAG_TOKEN]: tokenInTableText,\n    [Tokenizer.END_TAG_TOKEN]: tokenInTableText,\n    [Tokenizer.EOF_TOKEN]: tokenInTableText\n  },\n  [IN_CAPTION_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagInCaption,\n    [Tokenizer.END_TAG_TOKEN]: endTagInCaption,\n    [Tokenizer.EOF_TOKEN]: eofInBody\n  },\n  [IN_COLUMN_GROUP_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,\n    [Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,\n    [Tokenizer.EOF_TOKEN]: eofInBody\n  },\n  [IN_TABLE_BODY_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: characterInTable,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagInTableBody,\n    [Tokenizer.END_TAG_TOKEN]: endTagInTableBody,\n    [Tokenizer.EOF_TOKEN]: eofInBody\n  },\n  [IN_ROW_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: characterInTable,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagInRow,\n    [Tokenizer.END_TAG_TOKEN]: endTagInRow,\n    [Tokenizer.EOF_TOKEN]: eofInBody\n  },\n  [IN_CELL_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagInCell,\n    [Tokenizer.END_TAG_TOKEN]: endTagInCell,\n    [Tokenizer.EOF_TOKEN]: eofInBody\n  },\n  [IN_SELECT_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagInSelect,\n    [Tokenizer.END_TAG_TOKEN]: endTagInSelect,\n    [Tokenizer.EOF_TOKEN]: eofInBody\n  },\n  [IN_SELECT_IN_TABLE_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,\n    [Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,\n    [Tokenizer.EOF_TOKEN]: eofInBody\n  },\n  [IN_TEMPLATE_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: characterInBody,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagInTemplate,\n    [Tokenizer.END_TAG_TOKEN]: endTagInTemplate,\n    [Tokenizer.EOF_TOKEN]: eofInTemplate\n  },\n  [AFTER_BODY_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n    [Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagAfterBody,\n    [Tokenizer.END_TAG_TOKEN]: endTagAfterBody,\n    [Tokenizer.EOF_TOKEN]: stopParsing\n  },\n  [IN_FRAMESET_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagInFrameset,\n    [Tokenizer.END_TAG_TOKEN]: endTagInFrameset,\n    [Tokenizer.EOF_TOKEN]: stopParsing\n  },\n  [AFTER_FRAMESET_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,\n    [Tokenizer.COMMENT_TOKEN]: appendComment,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,\n    [Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,\n    [Tokenizer.EOF_TOKEN]: stopParsing\n  },\n  [AFTER_AFTER_BODY_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n    [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,\n    [Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,\n    [Tokenizer.EOF_TOKEN]: stopParsing\n  },\n  [AFTER_AFTER_FRAMESET_MODE]: {\n    [Tokenizer.CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,\n    [Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,\n    [Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,\n    [Tokenizer.DOCTYPE_TOKEN]: ignoreToken,\n    [Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,\n    [Tokenizer.END_TAG_TOKEN]: ignoreToken,\n    [Tokenizer.EOF_TOKEN]: stopParsing\n  }\n}; //Parser\n\nclass Parser {\n  constructor(options) {\n    this.options = mergeOptions(DEFAULT_OPTIONS, options);\n    this.treeAdapter = this.options.treeAdapter;\n    this.pendingScript = null;\n\n    if (this.options.sourceCodeLocationInfo) {\n      Mixin.install(this, LocationInfoParserMixin);\n    }\n\n    if (this.options.onParseError) {\n      Mixin.install(this, ErrorReportingParserMixin, {\n        onParseError: this.options.onParseError\n      });\n    }\n  } // API\n\n\n  parse(html) {\n    const document = this.treeAdapter.createDocument();\n\n    this._bootstrap(document, null);\n\n    this.tokenizer.write(html, true);\n\n    this._runParsingLoop(null);\n\n    return document;\n  }\n\n  parseFragment(html, fragmentContext) {\n    //NOTE: use <template> element as a fragment context if context element was not provided,\n    //so we will parse in \"forgiving\" manner\n    if (!fragmentContext) {\n      fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);\n    } //NOTE: create fake element which will be used as 'document' for fragment parsing.\n    //This is important for jsdom there 'document' can't be recreated, therefore\n    //fragment parsing causes messing of the main `document`.\n\n\n    const documentMock = this.treeAdapter.createElement('documentmock', NS.HTML, []);\n\n    this._bootstrap(documentMock, fragmentContext);\n\n    if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {\n      this._pushTmplInsertionMode(IN_TEMPLATE_MODE);\n    }\n\n    this._initTokenizerForFragmentParsing();\n\n    this._insertFakeRootElement();\n\n    this._resetInsertionMode();\n\n    this._findFormInFragmentContext();\n\n    this.tokenizer.write(html, true);\n\n    this._runParsingLoop(null);\n\n    const rootElement = this.treeAdapter.getFirstChild(documentMock);\n    const fragment = this.treeAdapter.createDocumentFragment();\n\n    this._adoptNodes(rootElement, fragment);\n\n    return fragment;\n  } //Bootstrap parser\n\n\n  _bootstrap(document, fragmentContext) {\n    this.tokenizer = new Tokenizer(this.options);\n    this.stopped = false;\n    this.insertionMode = INITIAL_MODE;\n    this.originalInsertionMode = '';\n    this.document = document;\n    this.fragmentContext = fragmentContext;\n    this.headElement = null;\n    this.formElement = null;\n    this.openElements = new OpenElementStack(this.document, this.treeAdapter);\n    this.activeFormattingElements = new FormattingElementList(this.treeAdapter);\n    this.tmplInsertionModeStack = [];\n    this.tmplInsertionModeStackTop = -1;\n    this.currentTmplInsertionMode = null;\n    this.pendingCharacterTokens = [];\n    this.hasNonWhitespacePendingCharacterToken = false;\n    this.framesetOk = true;\n    this.skipNextNewLine = false;\n    this.fosterParentingEnabled = false;\n  } //Errors\n\n\n  _err() {} // NOTE: err reporting is noop by default. Enabled by mixin.\n  //Parsing loop\n\n\n  _runParsingLoop(scriptHandler) {\n    while (!this.stopped) {\n      this._setupTokenizerCDATAMode();\n\n      const token = this.tokenizer.getNextToken();\n\n      if (token.type === Tokenizer.HIBERNATION_TOKEN) {\n        break;\n      }\n\n      if (this.skipNextNewLine) {\n        this.skipNextNewLine = false;\n\n        if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\\n') {\n          if (token.chars.length === 1) {\n            continue;\n          }\n\n          token.chars = token.chars.substr(1);\n        }\n      }\n\n      this._processInputToken(token);\n\n      if (scriptHandler && this.pendingScript) {\n        break;\n      }\n    }\n  }\n\n  runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {\n    this._runParsingLoop(scriptHandler);\n\n    if (scriptHandler && this.pendingScript) {\n      const script = this.pendingScript;\n      this.pendingScript = null;\n      scriptHandler(script);\n      return;\n    }\n\n    if (writeCallback) {\n      writeCallback();\n    }\n  } //Text parsing\n\n\n  _setupTokenizerCDATAMode() {\n    const current = this._getAdjustedCurrentElement();\n\n    this.tokenizer.allowCDATA = current && current !== this.document && this.treeAdapter.getNamespaceURI(current) !== NS.HTML && !this._isIntegrationPoint(current);\n  }\n\n  _switchToTextParsing(currentToken, nextTokenizerState) {\n    this._insertElement(currentToken, NS.HTML);\n\n    this.tokenizer.state = nextTokenizerState;\n    this.originalInsertionMode = this.insertionMode;\n    this.insertionMode = TEXT_MODE;\n  }\n\n  switchToPlaintextParsing() {\n    this.insertionMode = TEXT_MODE;\n    this.originalInsertionMode = IN_BODY_MODE;\n    this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;\n  } //Fragment parsing\n\n\n  _getAdjustedCurrentElement() {\n    return this.openElements.stackTop === 0 && this.fragmentContext ? this.fragmentContext : this.openElements.current;\n  }\n\n  _findFormInFragmentContext() {\n    let node = this.fragmentContext;\n\n    do {\n      if (this.treeAdapter.getTagName(node) === $.FORM) {\n        this.formElement = node;\n        break;\n      }\n\n      node = this.treeAdapter.getParentNode(node);\n    } while (node);\n  }\n\n  _initTokenizerForFragmentParsing() {\n    if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {\n      const tn = this.treeAdapter.getTagName(this.fragmentContext);\n\n      if (tn === $.TITLE || tn === $.TEXTAREA) {\n        this.tokenizer.state = Tokenizer.MODE.RCDATA;\n      } else if (tn === $.STYLE || tn === $.XMP || tn === $.IFRAME || tn === $.NOEMBED || tn === $.NOFRAMES || tn === $.NOSCRIPT) {\n        this.tokenizer.state = Tokenizer.MODE.RAWTEXT;\n      } else if (tn === $.SCRIPT) {\n        this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;\n      } else if (tn === $.PLAINTEXT) {\n        this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;\n      }\n    }\n  } //Tree mutation\n\n\n  _setDocumentType(token) {\n    const name = token.name || '';\n    const publicId = token.publicId || '';\n    const systemId = token.systemId || '';\n    this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);\n  }\n\n  _attachElementToTree(element) {\n    if (this._shouldFosterParentOnInsertion()) {\n      this._fosterParentElement(element);\n    } else {\n      const parent = this.openElements.currentTmplContent || this.openElements.current;\n      this.treeAdapter.appendChild(parent, element);\n    }\n  }\n\n  _appendElement(token, namespaceURI) {\n    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);\n\n    this._attachElementToTree(element);\n  }\n\n  _insertElement(token, namespaceURI) {\n    const element = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);\n\n    this._attachElementToTree(element);\n\n    this.openElements.push(element);\n  }\n\n  _insertFakeElement(tagName) {\n    const element = this.treeAdapter.createElement(tagName, NS.HTML, []);\n\n    this._attachElementToTree(element);\n\n    this.openElements.push(element);\n  }\n\n  _insertTemplate(token) {\n    const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);\n    const content = this.treeAdapter.createDocumentFragment();\n    this.treeAdapter.setTemplateContent(tmpl, content);\n\n    this._attachElementToTree(tmpl);\n\n    this.openElements.push(tmpl);\n  }\n\n  _insertFakeRootElement() {\n    const element = this.treeAdapter.createElement($.HTML, NS.HTML, []);\n    this.treeAdapter.appendChild(this.openElements.current, element);\n    this.openElements.push(element);\n  }\n\n  _appendCommentNode(token, parent) {\n    const commentNode = this.treeAdapter.createCommentNode(token.data);\n    this.treeAdapter.appendChild(parent, commentNode);\n  }\n\n  _insertCharacters(token) {\n    if (this._shouldFosterParentOnInsertion()) {\n      this._fosterParentText(token.chars);\n    } else {\n      const parent = this.openElements.currentTmplContent || this.openElements.current;\n      this.treeAdapter.insertText(parent, token.chars);\n    }\n  }\n\n  _adoptNodes(donor, recipient) {\n    for (let child = this.treeAdapter.getFirstChild(donor); child; child = this.treeAdapter.getFirstChild(donor)) {\n      this.treeAdapter.detachNode(child);\n      this.treeAdapter.appendChild(recipient, child);\n    }\n  } //Token processing\n\n\n  _shouldProcessTokenInForeignContent(token) {\n    const current = this._getAdjustedCurrentElement();\n\n    if (!current || current === this.document) {\n      return false;\n    }\n\n    const ns = this.treeAdapter.getNamespaceURI(current);\n\n    if (ns === NS.HTML) {\n      return false;\n    }\n\n    if (this.treeAdapter.getTagName(current) === $.ANNOTATION_XML && ns === NS.MATHML && token.type === Tokenizer.START_TAG_TOKEN && token.tagName === $.SVG) {\n      return false;\n    }\n\n    const isCharacterToken = token.type === Tokenizer.CHARACTER_TOKEN || token.type === Tokenizer.NULL_CHARACTER_TOKEN || token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;\n    const isMathMLTextStartTag = token.type === Tokenizer.START_TAG_TOKEN && token.tagName !== $.MGLYPH && token.tagName !== $.MALIGNMARK;\n\n    if ((isMathMLTextStartTag || isCharacterToken) && this._isIntegrationPoint(current, NS.MATHML)) {\n      return false;\n    }\n\n    if ((token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) && this._isIntegrationPoint(current, NS.HTML)) {\n      return false;\n    }\n\n    return token.type !== Tokenizer.EOF_TOKEN;\n  }\n\n  _processToken(token) {\n    TOKEN_HANDLERS[this.insertionMode][token.type](this, token);\n  }\n\n  _processTokenInBodyMode(token) {\n    TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);\n  }\n\n  _processTokenInForeignContent(token) {\n    if (token.type === Tokenizer.CHARACTER_TOKEN) {\n      characterInForeignContent(this, token);\n    } else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {\n      nullCharacterInForeignContent(this, token);\n    } else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {\n      insertCharacters(this, token);\n    } else if (token.type === Tokenizer.COMMENT_TOKEN) {\n      appendComment(this, token);\n    } else if (token.type === Tokenizer.START_TAG_TOKEN) {\n      startTagInForeignContent(this, token);\n    } else if (token.type === Tokenizer.END_TAG_TOKEN) {\n      endTagInForeignContent(this, token);\n    }\n  }\n\n  _processInputToken(token) {\n    if (this._shouldProcessTokenInForeignContent(token)) {\n      this._processTokenInForeignContent(token);\n    } else {\n      this._processToken(token);\n    }\n\n    if (token.type === Tokenizer.START_TAG_TOKEN && token.selfClosing && !token.ackSelfClosing) {\n      this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);\n    }\n  } //Integration points\n\n\n  _isIntegrationPoint(element, foreignNS) {\n    const tn = this.treeAdapter.getTagName(element);\n    const ns = this.treeAdapter.getNamespaceURI(element);\n    const attrs = this.treeAdapter.getAttrList(element);\n    return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);\n  } //Active formatting elements reconstruction\n\n\n  _reconstructActiveFormattingElements() {\n    const listLength = this.activeFormattingElements.length;\n\n    if (listLength) {\n      let unopenIdx = listLength;\n      let entry = null;\n\n      do {\n        unopenIdx--;\n        entry = this.activeFormattingElements.entries[unopenIdx];\n\n        if (entry.type === FormattingElementList.MARKER_ENTRY || this.openElements.contains(entry.element)) {\n          unopenIdx++;\n          break;\n        }\n      } while (unopenIdx > 0);\n\n      for (let i = unopenIdx; i < listLength; i++) {\n        entry = this.activeFormattingElements.entries[i];\n\n        this._insertElement(entry.token, this.treeAdapter.getNamespaceURI(entry.element));\n\n        entry.element = this.openElements.current;\n      }\n    }\n  } //Close elements\n\n\n  _closeTableCell() {\n    this.openElements.generateImpliedEndTags();\n    this.openElements.popUntilTableCellPopped();\n    this.activeFormattingElements.clearToLastMarker();\n    this.insertionMode = IN_ROW_MODE;\n  }\n\n  _closePElement() {\n    this.openElements.generateImpliedEndTagsWithExclusion($.P);\n    this.openElements.popUntilTagNamePopped($.P);\n  } //Insertion modes\n\n\n  _resetInsertionMode() {\n    for (let i = this.openElements.stackTop, last = false; i >= 0; i--) {\n      let element = this.openElements.items[i];\n\n      if (i === 0) {\n        last = true;\n\n        if (this.fragmentContext) {\n          element = this.fragmentContext;\n        }\n      }\n\n      const tn = this.treeAdapter.getTagName(element);\n      const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];\n\n      if (newInsertionMode) {\n        this.insertionMode = newInsertionMode;\n        break;\n      } else if (!last && (tn === $.TD || tn === $.TH)) {\n        this.insertionMode = IN_CELL_MODE;\n        break;\n      } else if (!last && tn === $.HEAD) {\n        this.insertionMode = IN_HEAD_MODE;\n        break;\n      } else if (tn === $.SELECT) {\n        this._resetInsertionModeForSelect(i);\n\n        break;\n      } else if (tn === $.TEMPLATE) {\n        this.insertionMode = this.currentTmplInsertionMode;\n        break;\n      } else if (tn === $.HTML) {\n        this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;\n        break;\n      } else if (last) {\n        this.insertionMode = IN_BODY_MODE;\n        break;\n      }\n    }\n  }\n\n  _resetInsertionModeForSelect(selectIdx) {\n    if (selectIdx > 0) {\n      for (let i = selectIdx - 1; i > 0; i--) {\n        const ancestor = this.openElements.items[i];\n        const tn = this.treeAdapter.getTagName(ancestor);\n\n        if (tn === $.TEMPLATE) {\n          break;\n        } else if (tn === $.TABLE) {\n          this.insertionMode = IN_SELECT_IN_TABLE_MODE;\n          return;\n        }\n      }\n    }\n\n    this.insertionMode = IN_SELECT_MODE;\n  }\n\n  _pushTmplInsertionMode(mode) {\n    this.tmplInsertionModeStack.push(mode);\n    this.tmplInsertionModeStackTop++;\n    this.currentTmplInsertionMode = mode;\n  }\n\n  _popTmplInsertionMode() {\n    this.tmplInsertionModeStack.pop();\n    this.tmplInsertionModeStackTop--;\n    this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];\n  } //Foster parenting\n\n\n  _isElementCausesFosterParenting(element) {\n    const tn = this.treeAdapter.getTagName(element);\n    return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;\n  }\n\n  _shouldFosterParentOnInsertion() {\n    return this.fosterParentingEnabled && this._isElementCausesFosterParenting(this.openElements.current);\n  }\n\n  _findFosterParentingLocation() {\n    const location = {\n      parent: null,\n      beforeElement: null\n    };\n\n    for (let i = this.openElements.stackTop; i >= 0; i--) {\n      const openElement = this.openElements.items[i];\n      const tn = this.treeAdapter.getTagName(openElement);\n      const ns = this.treeAdapter.getNamespaceURI(openElement);\n\n      if (tn === $.TEMPLATE && ns === NS.HTML) {\n        location.parent = this.treeAdapter.getTemplateContent(openElement);\n        break;\n      } else if (tn === $.TABLE) {\n        location.parent = this.treeAdapter.getParentNode(openElement);\n\n        if (location.parent) {\n          location.beforeElement = openElement;\n        } else {\n          location.parent = this.openElements.items[i - 1];\n        }\n\n        break;\n      }\n    }\n\n    if (!location.parent) {\n      location.parent = this.openElements.items[0];\n    }\n\n    return location;\n  }\n\n  _fosterParentElement(element) {\n    const location = this._findFosterParentingLocation();\n\n    if (location.beforeElement) {\n      this.treeAdapter.insertBefore(location.parent, element, location.beforeElement);\n    } else {\n      this.treeAdapter.appendChild(location.parent, element);\n    }\n  }\n\n  _fosterParentText(chars) {\n    const location = this._findFosterParentingLocation();\n\n    if (location.beforeElement) {\n      this.treeAdapter.insertTextBefore(location.parent, chars, location.beforeElement);\n    } else {\n      this.treeAdapter.insertText(location.parent, chars);\n    }\n  } //Special elements\n\n\n  _isSpecialElement(element) {\n    const tn = this.treeAdapter.getTagName(element);\n    const ns = this.treeAdapter.getNamespaceURI(element);\n    return HTML.SPECIAL_ELEMENTS[ns][tn];\n  }\n\n}\n\nmodule.exports = Parser; //Adoption agency algorithm\n//(see: http://www.whatwg.org/specs/web-apps/current-work/multipage/tree-construction.html#adoptionAgency)\n//------------------------------------------------------------------\n//Steps 5-8 of the algorithm\n\nfunction aaObtainFormattingElementEntry(p, token) {\n  let formattingElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName(token.tagName);\n\n  if (formattingElementEntry) {\n    if (!p.openElements.contains(formattingElementEntry.element)) {\n      p.activeFormattingElements.removeEntry(formattingElementEntry);\n      formattingElementEntry = null;\n    } else if (!p.openElements.hasInScope(token.tagName)) {\n      formattingElementEntry = null;\n    }\n  } else {\n    genericEndTagInBody(p, token);\n  }\n\n  return formattingElementEntry;\n} //Steps 9 and 10 of the algorithm\n\n\nfunction aaObtainFurthestBlock(p, formattingElementEntry) {\n  let furthestBlock = null;\n\n  for (let i = p.openElements.stackTop; i >= 0; i--) {\n    const element = p.openElements.items[i];\n\n    if (element === formattingElementEntry.element) {\n      break;\n    }\n\n    if (p._isSpecialElement(element)) {\n      furthestBlock = element;\n    }\n  }\n\n  if (!furthestBlock) {\n    p.openElements.popUntilElementPopped(formattingElementEntry.element);\n    p.activeFormattingElements.removeEntry(formattingElementEntry);\n  }\n\n  return furthestBlock;\n} //Step 13 of the algorithm\n\n\nfunction aaInnerLoop(p, furthestBlock, formattingElement) {\n  let lastElement = furthestBlock;\n  let nextElement = p.openElements.getCommonAncestor(furthestBlock);\n\n  for (let i = 0, element = nextElement; element !== formattingElement; i++, element = nextElement) {\n    //NOTE: store next element for the next loop iteration (it may be deleted from the stack by step 9.5)\n    nextElement = p.openElements.getCommonAncestor(element);\n    const elementEntry = p.activeFormattingElements.getElementEntry(element);\n    const counterOverflow = elementEntry && i >= AA_INNER_LOOP_ITER;\n    const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;\n\n    if (shouldRemoveFromOpenElements) {\n      if (counterOverflow) {\n        p.activeFormattingElements.removeEntry(elementEntry);\n      }\n\n      p.openElements.remove(element);\n    } else {\n      element = aaRecreateElementFromEntry(p, elementEntry);\n\n      if (lastElement === furthestBlock) {\n        p.activeFormattingElements.bookmark = elementEntry;\n      }\n\n      p.treeAdapter.detachNode(lastElement);\n      p.treeAdapter.appendChild(element, lastElement);\n      lastElement = element;\n    }\n  }\n\n  return lastElement;\n} //Step 13.7 of the algorithm\n\n\nfunction aaRecreateElementFromEntry(p, elementEntry) {\n  const ns = p.treeAdapter.getNamespaceURI(elementEntry.element);\n  const newElement = p.treeAdapter.createElement(elementEntry.token.tagName, ns, elementEntry.token.attrs);\n  p.openElements.replace(elementEntry.element, newElement);\n  elementEntry.element = newElement;\n  return newElement;\n} //Step 14 of the algorithm\n\n\nfunction aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement) {\n  if (p._isElementCausesFosterParenting(commonAncestor)) {\n    p._fosterParentElement(lastElement);\n  } else {\n    const tn = p.treeAdapter.getTagName(commonAncestor);\n    const ns = p.treeAdapter.getNamespaceURI(commonAncestor);\n\n    if (tn === $.TEMPLATE && ns === NS.HTML) {\n      commonAncestor = p.treeAdapter.getTemplateContent(commonAncestor);\n    }\n\n    p.treeAdapter.appendChild(commonAncestor, lastElement);\n  }\n} //Steps 15-19 of the algorithm\n\n\nfunction aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry) {\n  const ns = p.treeAdapter.getNamespaceURI(formattingElementEntry.element);\n  const token = formattingElementEntry.token;\n  const newElement = p.treeAdapter.createElement(token.tagName, ns, token.attrs);\n\n  p._adoptNodes(furthestBlock, newElement);\n\n  p.treeAdapter.appendChild(furthestBlock, newElement);\n  p.activeFormattingElements.insertElementAfterBookmark(newElement, formattingElementEntry.token);\n  p.activeFormattingElements.removeEntry(formattingElementEntry);\n  p.openElements.remove(formattingElementEntry.element);\n  p.openElements.insertAfter(furthestBlock, newElement);\n} //Algorithm entry point\n\n\nfunction callAdoptionAgency(p, token) {\n  let formattingElementEntry;\n\n  for (let i = 0; i < AA_OUTER_LOOP_ITER; i++) {\n    formattingElementEntry = aaObtainFormattingElementEntry(p, token, formattingElementEntry);\n\n    if (!formattingElementEntry) {\n      break;\n    }\n\n    const furthestBlock = aaObtainFurthestBlock(p, formattingElementEntry);\n\n    if (!furthestBlock) {\n      break;\n    }\n\n    p.activeFormattingElements.bookmark = formattingElementEntry;\n    const lastElement = aaInnerLoop(p, furthestBlock, formattingElementEntry.element);\n    const commonAncestor = p.openElements.getCommonAncestor(formattingElementEntry.element);\n    p.treeAdapter.detachNode(lastElement);\n    aaInsertLastNodeInCommonAncestor(p, commonAncestor, lastElement);\n    aaReplaceFormattingElement(p, furthestBlock, formattingElementEntry);\n  }\n} //Generic token handlers\n//------------------------------------------------------------------\n\n\nfunction ignoreToken() {//NOTE: do nothing =)\n}\n\nfunction misplacedDoctype(p) {\n  p._err(ERR.misplacedDoctype);\n}\n\nfunction appendComment(p, token) {\n  p._appendCommentNode(token, p.openElements.currentTmplContent || p.openElements.current);\n}\n\nfunction appendCommentToRootHtmlElement(p, token) {\n  p._appendCommentNode(token, p.openElements.items[0]);\n}\n\nfunction appendCommentToDocument(p, token) {\n  p._appendCommentNode(token, p.document);\n}\n\nfunction insertCharacters(p, token) {\n  p._insertCharacters(token);\n}\n\nfunction stopParsing(p) {\n  p.stopped = true;\n} // The \"initial\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction doctypeInInitialMode(p, token) {\n  p._setDocumentType(token);\n\n  const mode = token.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype.getDocumentMode(token);\n\n  if (!doctype.isConforming(token)) {\n    p._err(ERR.nonConformingDoctype);\n  }\n\n  p.treeAdapter.setDocumentMode(p.document, mode);\n  p.insertionMode = BEFORE_HTML_MODE;\n}\n\nfunction tokenInInitialMode(p, token) {\n  p._err(ERR.missingDoctype, {\n    beforeToken: true\n  });\n\n  p.treeAdapter.setDocumentMode(p.document, HTML.DOCUMENT_MODE.QUIRKS);\n  p.insertionMode = BEFORE_HTML_MODE;\n\n  p._processToken(token);\n} // The \"before html\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagBeforeHtml(p, token) {\n  if (token.tagName === $.HTML) {\n    p._insertElement(token, NS.HTML);\n\n    p.insertionMode = BEFORE_HEAD_MODE;\n  } else {\n    tokenBeforeHtml(p, token);\n  }\n}\n\nfunction endTagBeforeHtml(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR) {\n    tokenBeforeHtml(p, token);\n  }\n}\n\nfunction tokenBeforeHtml(p, token) {\n  p._insertFakeRootElement();\n\n  p.insertionMode = BEFORE_HEAD_MODE;\n\n  p._processToken(token);\n} // The \"before head\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagBeforeHead(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HTML) {\n    startTagInBody(p, token);\n  } else if (tn === $.HEAD) {\n    p._insertElement(token, NS.HTML);\n\n    p.headElement = p.openElements.current;\n    p.insertionMode = IN_HEAD_MODE;\n  } else {\n    tokenBeforeHead(p, token);\n  }\n}\n\nfunction endTagBeforeHead(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR) {\n    tokenBeforeHead(p, token);\n  } else {\n    p._err(ERR.endTagWithoutMatchingOpenElement);\n  }\n}\n\nfunction tokenBeforeHead(p, token) {\n  p._insertFakeElement($.HEAD);\n\n  p.headElement = p.openElements.current;\n  p.insertionMode = IN_HEAD_MODE;\n\n  p._processToken(token);\n} // The \"in head\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagInHead(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HTML) {\n    startTagInBody(p, token);\n  } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META) {\n    p._appendElement(token, NS.HTML);\n\n    token.ackSelfClosing = true;\n  } else if (tn === $.TITLE) {\n    p._switchToTextParsing(token, Tokenizer.MODE.RCDATA);\n  } else if (tn === $.NOSCRIPT) {\n    if (p.options.scriptingEnabled) {\n      p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n    } else {\n      p._insertElement(token, NS.HTML);\n\n      p.insertionMode = IN_HEAD_NO_SCRIPT_MODE;\n    }\n  } else if (tn === $.NOFRAMES || tn === $.STYLE) {\n    p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n  } else if (tn === $.SCRIPT) {\n    p._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);\n  } else if (tn === $.TEMPLATE) {\n    p._insertTemplate(token, NS.HTML);\n\n    p.activeFormattingElements.insertMarker();\n    p.framesetOk = false;\n    p.insertionMode = IN_TEMPLATE_MODE;\n\n    p._pushTmplInsertionMode(IN_TEMPLATE_MODE);\n  } else if (tn === $.HEAD) {\n    p._err(ERR.misplacedStartTagForHeadElement);\n  } else {\n    tokenInHead(p, token);\n  }\n}\n\nfunction endTagInHead(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HEAD) {\n    p.openElements.pop();\n    p.insertionMode = AFTER_HEAD_MODE;\n  } else if (tn === $.BODY || tn === $.BR || tn === $.HTML) {\n    tokenInHead(p, token);\n  } else if (tn === $.TEMPLATE) {\n    if (p.openElements.tmplCount > 0) {\n      p.openElements.generateImpliedEndTagsThoroughly();\n\n      if (p.openElements.currentTagName !== $.TEMPLATE) {\n        p._err(ERR.closingOfElementWithOpenChildElements);\n      }\n\n      p.openElements.popUntilTagNamePopped($.TEMPLATE);\n      p.activeFormattingElements.clearToLastMarker();\n\n      p._popTmplInsertionMode();\n\n      p._resetInsertionMode();\n    } else {\n      p._err(ERR.endTagWithoutMatchingOpenElement);\n    }\n  } else {\n    p._err(ERR.endTagWithoutMatchingOpenElement);\n  }\n}\n\nfunction tokenInHead(p, token) {\n  p.openElements.pop();\n  p.insertionMode = AFTER_HEAD_MODE;\n\n  p._processToken(token);\n} // The \"in head no script\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagInHeadNoScript(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HTML) {\n    startTagInBody(p, token);\n  } else if (tn === $.BASEFONT || tn === $.BGSOUND || tn === $.HEAD || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.STYLE) {\n    startTagInHead(p, token);\n  } else if (tn === $.NOSCRIPT) {\n    p._err(ERR.nestedNoscriptInHead);\n  } else {\n    tokenInHeadNoScript(p, token);\n  }\n}\n\nfunction endTagInHeadNoScript(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.NOSCRIPT) {\n    p.openElements.pop();\n    p.insertionMode = IN_HEAD_MODE;\n  } else if (tn === $.BR) {\n    tokenInHeadNoScript(p, token);\n  } else {\n    p._err(ERR.endTagWithoutMatchingOpenElement);\n  }\n}\n\nfunction tokenInHeadNoScript(p, token) {\n  const errCode = token.type === Tokenizer.EOF_TOKEN ? ERR.openElementsLeftAfterEof : ERR.disallowedContentInNoscriptInHead;\n\n  p._err(errCode);\n\n  p.openElements.pop();\n  p.insertionMode = IN_HEAD_MODE;\n\n  p._processToken(token);\n} // The \"after head\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagAfterHead(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HTML) {\n    startTagInBody(p, token);\n  } else if (tn === $.BODY) {\n    p._insertElement(token, NS.HTML);\n\n    p.framesetOk = false;\n    p.insertionMode = IN_BODY_MODE;\n  } else if (tn === $.FRAMESET) {\n    p._insertElement(token, NS.HTML);\n\n    p.insertionMode = IN_FRAMESET_MODE;\n  } else if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {\n    p._err(ERR.abandonedHeadElementChild);\n\n    p.openElements.push(p.headElement);\n    startTagInHead(p, token);\n    p.openElements.remove(p.headElement);\n  } else if (tn === $.HEAD) {\n    p._err(ERR.misplacedStartTagForHeadElement);\n  } else {\n    tokenAfterHead(p, token);\n  }\n}\n\nfunction endTagAfterHead(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.BODY || tn === $.HTML || tn === $.BR) {\n    tokenAfterHead(p, token);\n  } else if (tn === $.TEMPLATE) {\n    endTagInHead(p, token);\n  } else {\n    p._err(ERR.endTagWithoutMatchingOpenElement);\n  }\n}\n\nfunction tokenAfterHead(p, token) {\n  p._insertFakeElement($.BODY);\n\n  p.insertionMode = IN_BODY_MODE;\n\n  p._processToken(token);\n} // The \"in body\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction whitespaceCharacterInBody(p, token) {\n  p._reconstructActiveFormattingElements();\n\n  p._insertCharacters(token);\n}\n\nfunction characterInBody(p, token) {\n  p._reconstructActiveFormattingElements();\n\n  p._insertCharacters(token);\n\n  p.framesetOk = false;\n}\n\nfunction htmlStartTagInBody(p, token) {\n  if (p.openElements.tmplCount === 0) {\n    p.treeAdapter.adoptAttributes(p.openElements.items[0], token.attrs);\n  }\n}\n\nfunction bodyStartTagInBody(p, token) {\n  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();\n\n  if (bodyElement && p.openElements.tmplCount === 0) {\n    p.framesetOk = false;\n    p.treeAdapter.adoptAttributes(bodyElement, token.attrs);\n  }\n}\n\nfunction framesetStartTagInBody(p, token) {\n  const bodyElement = p.openElements.tryPeekProperlyNestedBodyElement();\n\n  if (p.framesetOk && bodyElement) {\n    p.treeAdapter.detachNode(bodyElement);\n    p.openElements.popAllUpToHtmlElement();\n\n    p._insertElement(token, NS.HTML);\n\n    p.insertionMode = IN_FRAMESET_MODE;\n  }\n}\n\nfunction addressStartTagInBody(p, token) {\n  if (p.openElements.hasInButtonScope($.P)) {\n    p._closePElement();\n  }\n\n  p._insertElement(token, NS.HTML);\n}\n\nfunction numberedHeaderStartTagInBody(p, token) {\n  if (p.openElements.hasInButtonScope($.P)) {\n    p._closePElement();\n  }\n\n  const tn = p.openElements.currentTagName;\n\n  if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {\n    p.openElements.pop();\n  }\n\n  p._insertElement(token, NS.HTML);\n}\n\nfunction preStartTagInBody(p, token) {\n  if (p.openElements.hasInButtonScope($.P)) {\n    p._closePElement();\n  }\n\n  p._insertElement(token, NS.HTML); //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move\n  //on to the next one. (Newlines at the start of pre blocks are ignored as an authoring convenience.)\n\n\n  p.skipNextNewLine = true;\n  p.framesetOk = false;\n}\n\nfunction formStartTagInBody(p, token) {\n  const inTemplate = p.openElements.tmplCount > 0;\n\n  if (!p.formElement || inTemplate) {\n    if (p.openElements.hasInButtonScope($.P)) {\n      p._closePElement();\n    }\n\n    p._insertElement(token, NS.HTML);\n\n    if (!inTemplate) {\n      p.formElement = p.openElements.current;\n    }\n  }\n}\n\nfunction listItemStartTagInBody(p, token) {\n  p.framesetOk = false;\n  const tn = token.tagName;\n\n  for (let i = p.openElements.stackTop; i >= 0; i--) {\n    const element = p.openElements.items[i];\n    const elementTn = p.treeAdapter.getTagName(element);\n    let closeTn = null;\n\n    if (tn === $.LI && elementTn === $.LI) {\n      closeTn = $.LI;\n    } else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {\n      closeTn = elementTn;\n    }\n\n    if (closeTn) {\n      p.openElements.generateImpliedEndTagsWithExclusion(closeTn);\n      p.openElements.popUntilTagNamePopped(closeTn);\n      break;\n    }\n\n    if (elementTn !== $.ADDRESS && elementTn !== $.DIV && elementTn !== $.P && p._isSpecialElement(element)) {\n      break;\n    }\n  }\n\n  if (p.openElements.hasInButtonScope($.P)) {\n    p._closePElement();\n  }\n\n  p._insertElement(token, NS.HTML);\n}\n\nfunction plaintextStartTagInBody(p, token) {\n  if (p.openElements.hasInButtonScope($.P)) {\n    p._closePElement();\n  }\n\n  p._insertElement(token, NS.HTML);\n\n  p.tokenizer.state = Tokenizer.MODE.PLAINTEXT;\n}\n\nfunction buttonStartTagInBody(p, token) {\n  if (p.openElements.hasInScope($.BUTTON)) {\n    p.openElements.generateImpliedEndTags();\n    p.openElements.popUntilTagNamePopped($.BUTTON);\n  }\n\n  p._reconstructActiveFormattingElements();\n\n  p._insertElement(token, NS.HTML);\n\n  p.framesetOk = false;\n}\n\nfunction aStartTagInBody(p, token) {\n  const activeElementEntry = p.activeFormattingElements.getElementEntryInScopeWithTagName($.A);\n\n  if (activeElementEntry) {\n    callAdoptionAgency(p, token);\n    p.openElements.remove(activeElementEntry.element);\n    p.activeFormattingElements.removeEntry(activeElementEntry);\n  }\n\n  p._reconstructActiveFormattingElements();\n\n  p._insertElement(token, NS.HTML);\n\n  p.activeFormattingElements.pushElement(p.openElements.current, token);\n}\n\nfunction bStartTagInBody(p, token) {\n  p._reconstructActiveFormattingElements();\n\n  p._insertElement(token, NS.HTML);\n\n  p.activeFormattingElements.pushElement(p.openElements.current, token);\n}\n\nfunction nobrStartTagInBody(p, token) {\n  p._reconstructActiveFormattingElements();\n\n  if (p.openElements.hasInScope($.NOBR)) {\n    callAdoptionAgency(p, token);\n\n    p._reconstructActiveFormattingElements();\n  }\n\n  p._insertElement(token, NS.HTML);\n\n  p.activeFormattingElements.pushElement(p.openElements.current, token);\n}\n\nfunction appletStartTagInBody(p, token) {\n  p._reconstructActiveFormattingElements();\n\n  p._insertElement(token, NS.HTML);\n\n  p.activeFormattingElements.insertMarker();\n  p.framesetOk = false;\n}\n\nfunction tableStartTagInBody(p, token) {\n  if (p.treeAdapter.getDocumentMode(p.document) !== HTML.DOCUMENT_MODE.QUIRKS && p.openElements.hasInButtonScope($.P)) {\n    p._closePElement();\n  }\n\n  p._insertElement(token, NS.HTML);\n\n  p.framesetOk = false;\n  p.insertionMode = IN_TABLE_MODE;\n}\n\nfunction areaStartTagInBody(p, token) {\n  p._reconstructActiveFormattingElements();\n\n  p._appendElement(token, NS.HTML);\n\n  p.framesetOk = false;\n  token.ackSelfClosing = true;\n}\n\nfunction inputStartTagInBody(p, token) {\n  p._reconstructActiveFormattingElements();\n\n  p._appendElement(token, NS.HTML);\n\n  const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);\n\n  if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {\n    p.framesetOk = false;\n  }\n\n  token.ackSelfClosing = true;\n}\n\nfunction paramStartTagInBody(p, token) {\n  p._appendElement(token, NS.HTML);\n\n  token.ackSelfClosing = true;\n}\n\nfunction hrStartTagInBody(p, token) {\n  if (p.openElements.hasInButtonScope($.P)) {\n    p._closePElement();\n  }\n\n  p._appendElement(token, NS.HTML);\n\n  p.framesetOk = false;\n  token.ackSelfClosing = true;\n}\n\nfunction imageStartTagInBody(p, token) {\n  token.tagName = $.IMG;\n  areaStartTagInBody(p, token);\n}\n\nfunction textareaStartTagInBody(p, token) {\n  p._insertElement(token, NS.HTML); //NOTE: If the next token is a U+000A LINE FEED (LF) character token, then ignore that token and move\n  //on to the next one. (Newlines at the start of textarea elements are ignored as an authoring convenience.)\n\n\n  p.skipNextNewLine = true;\n  p.tokenizer.state = Tokenizer.MODE.RCDATA;\n  p.originalInsertionMode = p.insertionMode;\n  p.framesetOk = false;\n  p.insertionMode = TEXT_MODE;\n}\n\nfunction xmpStartTagInBody(p, token) {\n  if (p.openElements.hasInButtonScope($.P)) {\n    p._closePElement();\n  }\n\n  p._reconstructActiveFormattingElements();\n\n  p.framesetOk = false;\n\n  p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n}\n\nfunction iframeStartTagInBody(p, token) {\n  p.framesetOk = false;\n\n  p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n} //NOTE: here we assume that we always act as an user agent with enabled plugins, so we parse\n//<noembed> as a rawtext.\n\n\nfunction noembedStartTagInBody(p, token) {\n  p._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);\n}\n\nfunction selectStartTagInBody(p, token) {\n  p._reconstructActiveFormattingElements();\n\n  p._insertElement(token, NS.HTML);\n\n  p.framesetOk = false;\n\n  if (p.insertionMode === IN_TABLE_MODE || p.insertionMode === IN_CAPTION_MODE || p.insertionMode === IN_TABLE_BODY_MODE || p.insertionMode === IN_ROW_MODE || p.insertionMode === IN_CELL_MODE) {\n    p.insertionMode = IN_SELECT_IN_TABLE_MODE;\n  } else {\n    p.insertionMode = IN_SELECT_MODE;\n  }\n}\n\nfunction optgroupStartTagInBody(p, token) {\n  if (p.openElements.currentTagName === $.OPTION) {\n    p.openElements.pop();\n  }\n\n  p._reconstructActiveFormattingElements();\n\n  p._insertElement(token, NS.HTML);\n}\n\nfunction rbStartTagInBody(p, token) {\n  if (p.openElements.hasInScope($.RUBY)) {\n    p.openElements.generateImpliedEndTags();\n  }\n\n  p._insertElement(token, NS.HTML);\n}\n\nfunction rtStartTagInBody(p, token) {\n  if (p.openElements.hasInScope($.RUBY)) {\n    p.openElements.generateImpliedEndTagsWithExclusion($.RTC);\n  }\n\n  p._insertElement(token, NS.HTML);\n}\n\nfunction menuStartTagInBody(p, token) {\n  if (p.openElements.hasInButtonScope($.P)) {\n    p._closePElement();\n  }\n\n  p._insertElement(token, NS.HTML);\n}\n\nfunction mathStartTagInBody(p, token) {\n  p._reconstructActiveFormattingElements();\n\n  foreignContent.adjustTokenMathMLAttrs(token);\n  foreignContent.adjustTokenXMLAttrs(token);\n\n  if (token.selfClosing) {\n    p._appendElement(token, NS.MATHML);\n  } else {\n    p._insertElement(token, NS.MATHML);\n  }\n\n  token.ackSelfClosing = true;\n}\n\nfunction svgStartTagInBody(p, token) {\n  p._reconstructActiveFormattingElements();\n\n  foreignContent.adjustTokenSVGAttrs(token);\n  foreignContent.adjustTokenXMLAttrs(token);\n\n  if (token.selfClosing) {\n    p._appendElement(token, NS.SVG);\n  } else {\n    p._insertElement(token, NS.SVG);\n  }\n\n  token.ackSelfClosing = true;\n}\n\nfunction genericStartTagInBody(p, token) {\n  p._reconstructActiveFormattingElements();\n\n  p._insertElement(token, NS.HTML);\n} //OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.\n//It's faster than using dictionary.\n\n\nfunction startTagInBody(p, token) {\n  const tn = token.tagName;\n\n  switch (tn.length) {\n    case 1:\n      if (tn === $.I || tn === $.S || tn === $.B || tn === $.U) {\n        bStartTagInBody(p, token);\n      } else if (tn === $.P) {\n        addressStartTagInBody(p, token);\n      } else if (tn === $.A) {\n        aStartTagInBody(p, token);\n      } else {\n        genericStartTagInBody(p, token);\n      }\n\n      break;\n\n    case 2:\n      if (tn === $.DL || tn === $.OL || tn === $.UL) {\n        addressStartTagInBody(p, token);\n      } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {\n        numberedHeaderStartTagInBody(p, token);\n      } else if (tn === $.LI || tn === $.DD || tn === $.DT) {\n        listItemStartTagInBody(p, token);\n      } else if (tn === $.EM || tn === $.TT) {\n        bStartTagInBody(p, token);\n      } else if (tn === $.BR) {\n        areaStartTagInBody(p, token);\n      } else if (tn === $.HR) {\n        hrStartTagInBody(p, token);\n      } else if (tn === $.RB) {\n        rbStartTagInBody(p, token);\n      } else if (tn === $.RT || tn === $.RP) {\n        rtStartTagInBody(p, token);\n      } else if (tn !== $.TH && tn !== $.TD && tn !== $.TR) {\n        genericStartTagInBody(p, token);\n      }\n\n      break;\n\n    case 3:\n      if (tn === $.DIV || tn === $.DIR || tn === $.NAV) {\n        addressStartTagInBody(p, token);\n      } else if (tn === $.PRE) {\n        preStartTagInBody(p, token);\n      } else if (tn === $.BIG) {\n        bStartTagInBody(p, token);\n      } else if (tn === $.IMG || tn === $.WBR) {\n        areaStartTagInBody(p, token);\n      } else if (tn === $.XMP) {\n        xmpStartTagInBody(p, token);\n      } else if (tn === $.SVG) {\n        svgStartTagInBody(p, token);\n      } else if (tn === $.RTC) {\n        rbStartTagInBody(p, token);\n      } else if (tn !== $.COL) {\n        genericStartTagInBody(p, token);\n      }\n\n      break;\n\n    case 4:\n      if (tn === $.HTML) {\n        htmlStartTagInBody(p, token);\n      } else if (tn === $.BASE || tn === $.LINK || tn === $.META) {\n        startTagInHead(p, token);\n      } else if (tn === $.BODY) {\n        bodyStartTagInBody(p, token);\n      } else if (tn === $.MAIN || tn === $.MENU) {\n        addressStartTagInBody(p, token);\n      } else if (tn === $.FORM) {\n        formStartTagInBody(p, token);\n      } else if (tn === $.CODE || tn === $.FONT) {\n        bStartTagInBody(p, token);\n      } else if (tn === $.NOBR) {\n        nobrStartTagInBody(p, token);\n      } else if (tn === $.AREA) {\n        areaStartTagInBody(p, token);\n      } else if (tn === $.MATH) {\n        mathStartTagInBody(p, token);\n      } else if (tn === $.MENU) {\n        menuStartTagInBody(p, token);\n      } else if (tn !== $.HEAD) {\n        genericStartTagInBody(p, token);\n      }\n\n      break;\n\n    case 5:\n      if (tn === $.STYLE || tn === $.TITLE) {\n        startTagInHead(p, token);\n      } else if (tn === $.ASIDE) {\n        addressStartTagInBody(p, token);\n      } else if (tn === $.SMALL) {\n        bStartTagInBody(p, token);\n      } else if (tn === $.TABLE) {\n        tableStartTagInBody(p, token);\n      } else if (tn === $.EMBED) {\n        areaStartTagInBody(p, token);\n      } else if (tn === $.INPUT) {\n        inputStartTagInBody(p, token);\n      } else if (tn === $.PARAM || tn === $.TRACK) {\n        paramStartTagInBody(p, token);\n      } else if (tn === $.IMAGE) {\n        imageStartTagInBody(p, token);\n      } else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD) {\n        genericStartTagInBody(p, token);\n      }\n\n      break;\n\n    case 6:\n      if (tn === $.SCRIPT) {\n        startTagInHead(p, token);\n      } else if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {\n        addressStartTagInBody(p, token);\n      } else if (tn === $.BUTTON) {\n        buttonStartTagInBody(p, token);\n      } else if (tn === $.STRIKE || tn === $.STRONG) {\n        bStartTagInBody(p, token);\n      } else if (tn === $.APPLET || tn === $.OBJECT) {\n        appletStartTagInBody(p, token);\n      } else if (tn === $.KEYGEN) {\n        areaStartTagInBody(p, token);\n      } else if (tn === $.SOURCE) {\n        paramStartTagInBody(p, token);\n      } else if (tn === $.IFRAME) {\n        iframeStartTagInBody(p, token);\n      } else if (tn === $.SELECT) {\n        selectStartTagInBody(p, token);\n      } else if (tn === $.OPTION) {\n        optgroupStartTagInBody(p, token);\n      } else {\n        genericStartTagInBody(p, token);\n      }\n\n      break;\n\n    case 7:\n      if (tn === $.BGSOUND) {\n        startTagInHead(p, token);\n      } else if (tn === $.DETAILS || tn === $.ADDRESS || tn === $.ARTICLE || tn === $.SECTION || tn === $.SUMMARY) {\n        addressStartTagInBody(p, token);\n      } else if (tn === $.LISTING) {\n        preStartTagInBody(p, token);\n      } else if (tn === $.MARQUEE) {\n        appletStartTagInBody(p, token);\n      } else if (tn === $.NOEMBED) {\n        noembedStartTagInBody(p, token);\n      } else if (tn !== $.CAPTION) {\n        genericStartTagInBody(p, token);\n      }\n\n      break;\n\n    case 8:\n      if (tn === $.BASEFONT) {\n        startTagInHead(p, token);\n      } else if (tn === $.FRAMESET) {\n        framesetStartTagInBody(p, token);\n      } else if (tn === $.FIELDSET) {\n        addressStartTagInBody(p, token);\n      } else if (tn === $.TEXTAREA) {\n        textareaStartTagInBody(p, token);\n      } else if (tn === $.TEMPLATE) {\n        startTagInHead(p, token);\n      } else if (tn === $.NOSCRIPT) {\n        if (p.options.scriptingEnabled) {\n          noembedStartTagInBody(p, token);\n        } else {\n          genericStartTagInBody(p, token);\n        }\n      } else if (tn === $.OPTGROUP) {\n        optgroupStartTagInBody(p, token);\n      } else if (tn !== $.COLGROUP) {\n        genericStartTagInBody(p, token);\n      }\n\n      break;\n\n    case 9:\n      if (tn === $.PLAINTEXT) {\n        plaintextStartTagInBody(p, token);\n      } else {\n        genericStartTagInBody(p, token);\n      }\n\n      break;\n\n    case 10:\n      if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {\n        addressStartTagInBody(p, token);\n      } else {\n        genericStartTagInBody(p, token);\n      }\n\n      break;\n\n    default:\n      genericStartTagInBody(p, token);\n  }\n}\n\nfunction bodyEndTagInBody(p) {\n  if (p.openElements.hasInScope($.BODY)) {\n    p.insertionMode = AFTER_BODY_MODE;\n  }\n}\n\nfunction htmlEndTagInBody(p, token) {\n  if (p.openElements.hasInScope($.BODY)) {\n    p.insertionMode = AFTER_BODY_MODE;\n\n    p._processToken(token);\n  }\n}\n\nfunction addressEndTagInBody(p, token) {\n  const tn = token.tagName;\n\n  if (p.openElements.hasInScope(tn)) {\n    p.openElements.generateImpliedEndTags();\n    p.openElements.popUntilTagNamePopped(tn);\n  }\n}\n\nfunction formEndTagInBody(p) {\n  const inTemplate = p.openElements.tmplCount > 0;\n  const formElement = p.formElement;\n\n  if (!inTemplate) {\n    p.formElement = null;\n  }\n\n  if ((formElement || inTemplate) && p.openElements.hasInScope($.FORM)) {\n    p.openElements.generateImpliedEndTags();\n\n    if (inTemplate) {\n      p.openElements.popUntilTagNamePopped($.FORM);\n    } else {\n      p.openElements.remove(formElement);\n    }\n  }\n}\n\nfunction pEndTagInBody(p) {\n  if (!p.openElements.hasInButtonScope($.P)) {\n    p._insertFakeElement($.P);\n  }\n\n  p._closePElement();\n}\n\nfunction liEndTagInBody(p) {\n  if (p.openElements.hasInListItemScope($.LI)) {\n    p.openElements.generateImpliedEndTagsWithExclusion($.LI);\n    p.openElements.popUntilTagNamePopped($.LI);\n  }\n}\n\nfunction ddEndTagInBody(p, token) {\n  const tn = token.tagName;\n\n  if (p.openElements.hasInScope(tn)) {\n    p.openElements.generateImpliedEndTagsWithExclusion(tn);\n    p.openElements.popUntilTagNamePopped(tn);\n  }\n}\n\nfunction numberedHeaderEndTagInBody(p) {\n  if (p.openElements.hasNumberedHeaderInScope()) {\n    p.openElements.generateImpliedEndTags();\n    p.openElements.popUntilNumberedHeaderPopped();\n  }\n}\n\nfunction appletEndTagInBody(p, token) {\n  const tn = token.tagName;\n\n  if (p.openElements.hasInScope(tn)) {\n    p.openElements.generateImpliedEndTags();\n    p.openElements.popUntilTagNamePopped(tn);\n    p.activeFormattingElements.clearToLastMarker();\n  }\n}\n\nfunction brEndTagInBody(p) {\n  p._reconstructActiveFormattingElements();\n\n  p._insertFakeElement($.BR);\n\n  p.openElements.pop();\n  p.framesetOk = false;\n}\n\nfunction genericEndTagInBody(p, token) {\n  const tn = token.tagName;\n\n  for (let i = p.openElements.stackTop; i > 0; i--) {\n    const element = p.openElements.items[i];\n\n    if (p.treeAdapter.getTagName(element) === tn) {\n      p.openElements.generateImpliedEndTagsWithExclusion(tn);\n      p.openElements.popUntilElementPopped(element);\n      break;\n    }\n\n    if (p._isSpecialElement(element)) {\n      break;\n    }\n  }\n} //OPTIMIZATION: Integer comparisons are low-cost, so we can use very fast tag name length filters here.\n//It's faster than using dictionary.\n\n\nfunction endTagInBody(p, token) {\n  const tn = token.tagName;\n\n  switch (tn.length) {\n    case 1:\n      if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U) {\n        callAdoptionAgency(p, token);\n      } else if (tn === $.P) {\n        pEndTagInBody(p, token);\n      } else {\n        genericEndTagInBody(p, token);\n      }\n\n      break;\n\n    case 2:\n      if (tn === $.DL || tn === $.UL || tn === $.OL) {\n        addressEndTagInBody(p, token);\n      } else if (tn === $.LI) {\n        liEndTagInBody(p, token);\n      } else if (tn === $.DD || tn === $.DT) {\n        ddEndTagInBody(p, token);\n      } else if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {\n        numberedHeaderEndTagInBody(p, token);\n      } else if (tn === $.BR) {\n        brEndTagInBody(p, token);\n      } else if (tn === $.EM || tn === $.TT) {\n        callAdoptionAgency(p, token);\n      } else {\n        genericEndTagInBody(p, token);\n      }\n\n      break;\n\n    case 3:\n      if (tn === $.BIG) {\n        callAdoptionAgency(p, token);\n      } else if (tn === $.DIR || tn === $.DIV || tn === $.NAV || tn === $.PRE) {\n        addressEndTagInBody(p, token);\n      } else {\n        genericEndTagInBody(p, token);\n      }\n\n      break;\n\n    case 4:\n      if (tn === $.BODY) {\n        bodyEndTagInBody(p, token);\n      } else if (tn === $.HTML) {\n        htmlEndTagInBody(p, token);\n      } else if (tn === $.FORM) {\n        formEndTagInBody(p, token);\n      } else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR) {\n        callAdoptionAgency(p, token);\n      } else if (tn === $.MAIN || tn === $.MENU) {\n        addressEndTagInBody(p, token);\n      } else {\n        genericEndTagInBody(p, token);\n      }\n\n      break;\n\n    case 5:\n      if (tn === $.ASIDE) {\n        addressEndTagInBody(p, token);\n      } else if (tn === $.SMALL) {\n        callAdoptionAgency(p, token);\n      } else {\n        genericEndTagInBody(p, token);\n      }\n\n      break;\n\n    case 6:\n      if (tn === $.CENTER || tn === $.FIGURE || tn === $.FOOTER || tn === $.HEADER || tn === $.HGROUP || tn === $.DIALOG) {\n        addressEndTagInBody(p, token);\n      } else if (tn === $.APPLET || tn === $.OBJECT) {\n        appletEndTagInBody(p, token);\n      } else if (tn === $.STRIKE || tn === $.STRONG) {\n        callAdoptionAgency(p, token);\n      } else {\n        genericEndTagInBody(p, token);\n      }\n\n      break;\n\n    case 7:\n      if (tn === $.ADDRESS || tn === $.ARTICLE || tn === $.DETAILS || tn === $.SECTION || tn === $.SUMMARY || tn === $.LISTING) {\n        addressEndTagInBody(p, token);\n      } else if (tn === $.MARQUEE) {\n        appletEndTagInBody(p, token);\n      } else {\n        genericEndTagInBody(p, token);\n      }\n\n      break;\n\n    case 8:\n      if (tn === $.FIELDSET) {\n        addressEndTagInBody(p, token);\n      } else if (tn === $.TEMPLATE) {\n        endTagInHead(p, token);\n      } else {\n        genericEndTagInBody(p, token);\n      }\n\n      break;\n\n    case 10:\n      if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {\n        addressEndTagInBody(p, token);\n      } else {\n        genericEndTagInBody(p, token);\n      }\n\n      break;\n\n    default:\n      genericEndTagInBody(p, token);\n  }\n}\n\nfunction eofInBody(p, token) {\n  if (p.tmplInsertionModeStackTop > -1) {\n    eofInTemplate(p, token);\n  } else {\n    p.stopped = true;\n  }\n} // The \"text\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction endTagInText(p, token) {\n  if (token.tagName === $.SCRIPT) {\n    p.pendingScript = p.openElements.current;\n  }\n\n  p.openElements.pop();\n  p.insertionMode = p.originalInsertionMode;\n}\n\nfunction eofInText(p, token) {\n  p._err(ERR.eofInElementThatCanContainOnlyText);\n\n  p.openElements.pop();\n  p.insertionMode = p.originalInsertionMode;\n\n  p._processToken(token);\n} // The \"in table\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction characterInTable(p, token) {\n  const curTn = p.openElements.currentTagName;\n\n  if (curTn === $.TABLE || curTn === $.TBODY || curTn === $.TFOOT || curTn === $.THEAD || curTn === $.TR) {\n    p.pendingCharacterTokens = [];\n    p.hasNonWhitespacePendingCharacterToken = false;\n    p.originalInsertionMode = p.insertionMode;\n    p.insertionMode = IN_TABLE_TEXT_MODE;\n\n    p._processToken(token);\n  } else {\n    tokenInTable(p, token);\n  }\n}\n\nfunction captionStartTagInTable(p, token) {\n  p.openElements.clearBackToTableContext();\n  p.activeFormattingElements.insertMarker();\n\n  p._insertElement(token, NS.HTML);\n\n  p.insertionMode = IN_CAPTION_MODE;\n}\n\nfunction colgroupStartTagInTable(p, token) {\n  p.openElements.clearBackToTableContext();\n\n  p._insertElement(token, NS.HTML);\n\n  p.insertionMode = IN_COLUMN_GROUP_MODE;\n}\n\nfunction colStartTagInTable(p, token) {\n  p.openElements.clearBackToTableContext();\n\n  p._insertFakeElement($.COLGROUP);\n\n  p.insertionMode = IN_COLUMN_GROUP_MODE;\n\n  p._processToken(token);\n}\n\nfunction tbodyStartTagInTable(p, token) {\n  p.openElements.clearBackToTableContext();\n\n  p._insertElement(token, NS.HTML);\n\n  p.insertionMode = IN_TABLE_BODY_MODE;\n}\n\nfunction tdStartTagInTable(p, token) {\n  p.openElements.clearBackToTableContext();\n\n  p._insertFakeElement($.TBODY);\n\n  p.insertionMode = IN_TABLE_BODY_MODE;\n\n  p._processToken(token);\n}\n\nfunction tableStartTagInTable(p, token) {\n  if (p.openElements.hasInTableScope($.TABLE)) {\n    p.openElements.popUntilTagNamePopped($.TABLE);\n\n    p._resetInsertionMode();\n\n    p._processToken(token);\n  }\n}\n\nfunction inputStartTagInTable(p, token) {\n  const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);\n\n  if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {\n    p._appendElement(token, NS.HTML);\n  } else {\n    tokenInTable(p, token);\n  }\n\n  token.ackSelfClosing = true;\n}\n\nfunction formStartTagInTable(p, token) {\n  if (!p.formElement && p.openElements.tmplCount === 0) {\n    p._insertElement(token, NS.HTML);\n\n    p.formElement = p.openElements.current;\n    p.openElements.pop();\n  }\n}\n\nfunction startTagInTable(p, token) {\n  const tn = token.tagName;\n\n  switch (tn.length) {\n    case 2:\n      if (tn === $.TD || tn === $.TH || tn === $.TR) {\n        tdStartTagInTable(p, token);\n      } else {\n        tokenInTable(p, token);\n      }\n\n      break;\n\n    case 3:\n      if (tn === $.COL) {\n        colStartTagInTable(p, token);\n      } else {\n        tokenInTable(p, token);\n      }\n\n      break;\n\n    case 4:\n      if (tn === $.FORM) {\n        formStartTagInTable(p, token);\n      } else {\n        tokenInTable(p, token);\n      }\n\n      break;\n\n    case 5:\n      if (tn === $.TABLE) {\n        tableStartTagInTable(p, token);\n      } else if (tn === $.STYLE) {\n        startTagInHead(p, token);\n      } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {\n        tbodyStartTagInTable(p, token);\n      } else if (tn === $.INPUT) {\n        inputStartTagInTable(p, token);\n      } else {\n        tokenInTable(p, token);\n      }\n\n      break;\n\n    case 6:\n      if (tn === $.SCRIPT) {\n        startTagInHead(p, token);\n      } else {\n        tokenInTable(p, token);\n      }\n\n      break;\n\n    case 7:\n      if (tn === $.CAPTION) {\n        captionStartTagInTable(p, token);\n      } else {\n        tokenInTable(p, token);\n      }\n\n      break;\n\n    case 8:\n      if (tn === $.COLGROUP) {\n        colgroupStartTagInTable(p, token);\n      } else if (tn === $.TEMPLATE) {\n        startTagInHead(p, token);\n      } else {\n        tokenInTable(p, token);\n      }\n\n      break;\n\n    default:\n      tokenInTable(p, token);\n  }\n}\n\nfunction endTagInTable(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.TABLE) {\n    if (p.openElements.hasInTableScope($.TABLE)) {\n      p.openElements.popUntilTagNamePopped($.TABLE);\n\n      p._resetInsertionMode();\n    }\n  } else if (tn === $.TEMPLATE) {\n    endTagInHead(p, token);\n  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {\n    tokenInTable(p, token);\n  }\n}\n\nfunction tokenInTable(p, token) {\n  const savedFosterParentingState = p.fosterParentingEnabled;\n  p.fosterParentingEnabled = true;\n\n  p._processTokenInBodyMode(token);\n\n  p.fosterParentingEnabled = savedFosterParentingState;\n} // The \"in table text\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction whitespaceCharacterInTableText(p, token) {\n  p.pendingCharacterTokens.push(token);\n}\n\nfunction characterInTableText(p, token) {\n  p.pendingCharacterTokens.push(token);\n  p.hasNonWhitespacePendingCharacterToken = true;\n}\n\nfunction tokenInTableText(p, token) {\n  let i = 0;\n\n  if (p.hasNonWhitespacePendingCharacterToken) {\n    for (; i < p.pendingCharacterTokens.length; i++) {\n      tokenInTable(p, p.pendingCharacterTokens[i]);\n    }\n  } else {\n    for (; i < p.pendingCharacterTokens.length; i++) {\n      p._insertCharacters(p.pendingCharacterTokens[i]);\n    }\n  }\n\n  p.insertionMode = p.originalInsertionMode;\n\n  p._processToken(token);\n} // The \"in caption\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagInCaption(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {\n    if (p.openElements.hasInTableScope($.CAPTION)) {\n      p.openElements.generateImpliedEndTags();\n      p.openElements.popUntilTagNamePopped($.CAPTION);\n      p.activeFormattingElements.clearToLastMarker();\n      p.insertionMode = IN_TABLE_MODE;\n\n      p._processToken(token);\n    }\n  } else {\n    startTagInBody(p, token);\n  }\n}\n\nfunction endTagInCaption(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.CAPTION || tn === $.TABLE) {\n    if (p.openElements.hasInTableScope($.CAPTION)) {\n      p.openElements.generateImpliedEndTags();\n      p.openElements.popUntilTagNamePopped($.CAPTION);\n      p.activeFormattingElements.clearToLastMarker();\n      p.insertionMode = IN_TABLE_MODE;\n\n      if (tn === $.TABLE) {\n        p._processToken(token);\n      }\n    }\n  } else if (tn !== $.BODY && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML && tn !== $.TBODY && tn !== $.TD && tn !== $.TFOOT && tn !== $.TH && tn !== $.THEAD && tn !== $.TR) {\n    endTagInBody(p, token);\n  }\n} // The \"in column group\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagInColumnGroup(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HTML) {\n    startTagInBody(p, token);\n  } else if (tn === $.COL) {\n    p._appendElement(token, NS.HTML);\n\n    token.ackSelfClosing = true;\n  } else if (tn === $.TEMPLATE) {\n    startTagInHead(p, token);\n  } else {\n    tokenInColumnGroup(p, token);\n  }\n}\n\nfunction endTagInColumnGroup(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.COLGROUP) {\n    if (p.openElements.currentTagName === $.COLGROUP) {\n      p.openElements.pop();\n      p.insertionMode = IN_TABLE_MODE;\n    }\n  } else if (tn === $.TEMPLATE) {\n    endTagInHead(p, token);\n  } else if (tn !== $.COL) {\n    tokenInColumnGroup(p, token);\n  }\n}\n\nfunction tokenInColumnGroup(p, token) {\n  if (p.openElements.currentTagName === $.COLGROUP) {\n    p.openElements.pop();\n    p.insertionMode = IN_TABLE_MODE;\n\n    p._processToken(token);\n  }\n} // The \"in table body\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagInTableBody(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.TR) {\n    p.openElements.clearBackToTableBodyContext();\n\n    p._insertElement(token, NS.HTML);\n\n    p.insertionMode = IN_ROW_MODE;\n  } else if (tn === $.TH || tn === $.TD) {\n    p.openElements.clearBackToTableBodyContext();\n\n    p._insertFakeElement($.TR);\n\n    p.insertionMode = IN_ROW_MODE;\n\n    p._processToken(token);\n  } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {\n    if (p.openElements.hasTableBodyContextInTableScope()) {\n      p.openElements.clearBackToTableBodyContext();\n      p.openElements.pop();\n      p.insertionMode = IN_TABLE_MODE;\n\n      p._processToken(token);\n    }\n  } else {\n    startTagInTable(p, token);\n  }\n}\n\nfunction endTagInTableBody(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {\n    if (p.openElements.hasInTableScope(tn)) {\n      p.openElements.clearBackToTableBodyContext();\n      p.openElements.pop();\n      p.insertionMode = IN_TABLE_MODE;\n    }\n  } else if (tn === $.TABLE) {\n    if (p.openElements.hasTableBodyContextInTableScope()) {\n      p.openElements.clearBackToTableBodyContext();\n      p.openElements.pop();\n      p.insertionMode = IN_TABLE_MODE;\n\n      p._processToken(token);\n    }\n  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR) {\n    endTagInTable(p, token);\n  }\n} // The \"in row\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagInRow(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.TH || tn === $.TD) {\n    p.openElements.clearBackToTableRowContext();\n\n    p._insertElement(token, NS.HTML);\n\n    p.insertionMode = IN_CELL_MODE;\n    p.activeFormattingElements.insertMarker();\n  } else if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {\n    if (p.openElements.hasInTableScope($.TR)) {\n      p.openElements.clearBackToTableRowContext();\n      p.openElements.pop();\n      p.insertionMode = IN_TABLE_BODY_MODE;\n\n      p._processToken(token);\n    }\n  } else {\n    startTagInTable(p, token);\n  }\n}\n\nfunction endTagInRow(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.TR) {\n    if (p.openElements.hasInTableScope($.TR)) {\n      p.openElements.clearBackToTableRowContext();\n      p.openElements.pop();\n      p.insertionMode = IN_TABLE_BODY_MODE;\n    }\n  } else if (tn === $.TABLE) {\n    if (p.openElements.hasInTableScope($.TR)) {\n      p.openElements.clearBackToTableRowContext();\n      p.openElements.pop();\n      p.insertionMode = IN_TABLE_BODY_MODE;\n\n      p._processToken(token);\n    }\n  } else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {\n    if (p.openElements.hasInTableScope(tn) || p.openElements.hasInTableScope($.TR)) {\n      p.openElements.clearBackToTableRowContext();\n      p.openElements.pop();\n      p.insertionMode = IN_TABLE_BODY_MODE;\n\n      p._processToken(token);\n    }\n  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP || tn !== $.HTML && tn !== $.TD && tn !== $.TH) {\n    endTagInTable(p, token);\n  }\n} // The \"in cell\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagInCell(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.CAPTION || tn === $.COL || tn === $.COLGROUP || tn === $.TBODY || tn === $.TD || tn === $.TFOOT || tn === $.TH || tn === $.THEAD || tn === $.TR) {\n    if (p.openElements.hasInTableScope($.TD) || p.openElements.hasInTableScope($.TH)) {\n      p._closeTableCell();\n\n      p._processToken(token);\n    }\n  } else {\n    startTagInBody(p, token);\n  }\n}\n\nfunction endTagInCell(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.TD || tn === $.TH) {\n    if (p.openElements.hasInTableScope(tn)) {\n      p.openElements.generateImpliedEndTags();\n      p.openElements.popUntilTagNamePopped(tn);\n      p.activeFormattingElements.clearToLastMarker();\n      p.insertionMode = IN_ROW_MODE;\n    }\n  } else if (tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR) {\n    if (p.openElements.hasInTableScope(tn)) {\n      p._closeTableCell();\n\n      p._processToken(token);\n    }\n  } else if (tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP && tn !== $.HTML) {\n    endTagInBody(p, token);\n  }\n} // The \"in select\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagInSelect(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HTML) {\n    startTagInBody(p, token);\n  } else if (tn === $.OPTION) {\n    if (p.openElements.currentTagName === $.OPTION) {\n      p.openElements.pop();\n    }\n\n    p._insertElement(token, NS.HTML);\n  } else if (tn === $.OPTGROUP) {\n    if (p.openElements.currentTagName === $.OPTION) {\n      p.openElements.pop();\n    }\n\n    if (p.openElements.currentTagName === $.OPTGROUP) {\n      p.openElements.pop();\n    }\n\n    p._insertElement(token, NS.HTML);\n  } else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {\n    if (p.openElements.hasInSelectScope($.SELECT)) {\n      p.openElements.popUntilTagNamePopped($.SELECT);\n\n      p._resetInsertionMode();\n\n      if (tn !== $.SELECT) {\n        p._processToken(token);\n      }\n    }\n  } else if (tn === $.SCRIPT || tn === $.TEMPLATE) {\n    startTagInHead(p, token);\n  }\n}\n\nfunction endTagInSelect(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.OPTGROUP) {\n    const prevOpenElement = p.openElements.items[p.openElements.stackTop - 1];\n    const prevOpenElementTn = prevOpenElement && p.treeAdapter.getTagName(prevOpenElement);\n\n    if (p.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {\n      p.openElements.pop();\n    }\n\n    if (p.openElements.currentTagName === $.OPTGROUP) {\n      p.openElements.pop();\n    }\n  } else if (tn === $.OPTION) {\n    if (p.openElements.currentTagName === $.OPTION) {\n      p.openElements.pop();\n    }\n  } else if (tn === $.SELECT && p.openElements.hasInSelectScope($.SELECT)) {\n    p.openElements.popUntilTagNamePopped($.SELECT);\n\n    p._resetInsertionMode();\n  } else if (tn === $.TEMPLATE) {\n    endTagInHead(p, token);\n  }\n} //12.2.5.4.17 The \"in select in table\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagInSelectInTable(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {\n    p.openElements.popUntilTagNamePopped($.SELECT);\n\n    p._resetInsertionMode();\n\n    p._processToken(token);\n  } else {\n    startTagInSelect(p, token);\n  }\n}\n\nfunction endTagInSelectInTable(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.CAPTION || tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR || tn === $.TD || tn === $.TH) {\n    if (p.openElements.hasInTableScope(tn)) {\n      p.openElements.popUntilTagNamePopped($.SELECT);\n\n      p._resetInsertionMode();\n\n      p._processToken(token);\n    }\n  } else {\n    endTagInSelect(p, token);\n  }\n} // The \"in template\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagInTemplate(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.BASE || tn === $.BASEFONT || tn === $.BGSOUND || tn === $.LINK || tn === $.META || tn === $.NOFRAMES || tn === $.SCRIPT || tn === $.STYLE || tn === $.TEMPLATE || tn === $.TITLE) {\n    startTagInHead(p, token);\n  } else {\n    const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;\n\n    p._popTmplInsertionMode();\n\n    p._pushTmplInsertionMode(newInsertionMode);\n\n    p.insertionMode = newInsertionMode;\n\n    p._processToken(token);\n  }\n}\n\nfunction endTagInTemplate(p, token) {\n  if (token.tagName === $.TEMPLATE) {\n    endTagInHead(p, token);\n  }\n}\n\nfunction eofInTemplate(p, token) {\n  if (p.openElements.tmplCount > 0) {\n    p.openElements.popUntilTagNamePopped($.TEMPLATE);\n    p.activeFormattingElements.clearToLastMarker();\n\n    p._popTmplInsertionMode();\n\n    p._resetInsertionMode();\n\n    p._processToken(token);\n  } else {\n    p.stopped = true;\n  }\n} // The \"after body\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagAfterBody(p, token) {\n  if (token.tagName === $.HTML) {\n    startTagInBody(p, token);\n  } else {\n    tokenAfterBody(p, token);\n  }\n}\n\nfunction endTagAfterBody(p, token) {\n  if (token.tagName === $.HTML) {\n    if (!p.fragmentContext) {\n      p.insertionMode = AFTER_AFTER_BODY_MODE;\n    }\n  } else {\n    tokenAfterBody(p, token);\n  }\n}\n\nfunction tokenAfterBody(p, token) {\n  p.insertionMode = IN_BODY_MODE;\n\n  p._processToken(token);\n} // The \"in frameset\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagInFrameset(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HTML) {\n    startTagInBody(p, token);\n  } else if (tn === $.FRAMESET) {\n    p._insertElement(token, NS.HTML);\n  } else if (tn === $.FRAME) {\n    p._appendElement(token, NS.HTML);\n\n    token.ackSelfClosing = true;\n  } else if (tn === $.NOFRAMES) {\n    startTagInHead(p, token);\n  }\n}\n\nfunction endTagInFrameset(p, token) {\n  if (token.tagName === $.FRAMESET && !p.openElements.isRootHtmlElementCurrent()) {\n    p.openElements.pop();\n\n    if (!p.fragmentContext && p.openElements.currentTagName !== $.FRAMESET) {\n      p.insertionMode = AFTER_FRAMESET_MODE;\n    }\n  }\n} // The \"after frameset\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagAfterFrameset(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HTML) {\n    startTagInBody(p, token);\n  } else if (tn === $.NOFRAMES) {\n    startTagInHead(p, token);\n  }\n}\n\nfunction endTagAfterFrameset(p, token) {\n  if (token.tagName === $.HTML) {\n    p.insertionMode = AFTER_AFTER_FRAMESET_MODE;\n  }\n} // The \"after after body\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagAfterAfterBody(p, token) {\n  if (token.tagName === $.HTML) {\n    startTagInBody(p, token);\n  } else {\n    tokenAfterAfterBody(p, token);\n  }\n}\n\nfunction tokenAfterAfterBody(p, token) {\n  p.insertionMode = IN_BODY_MODE;\n\n  p._processToken(token);\n} // The \"after after frameset\" insertion mode\n//------------------------------------------------------------------\n\n\nfunction startTagAfterAfterFrameset(p, token) {\n  const tn = token.tagName;\n\n  if (tn === $.HTML) {\n    startTagInBody(p, token);\n  } else if (tn === $.NOFRAMES) {\n    startTagInHead(p, token);\n  }\n} // The rules for parsing tokens in foreign content\n//------------------------------------------------------------------\n\n\nfunction nullCharacterInForeignContent(p, token) {\n  token.chars = unicode.REPLACEMENT_CHARACTER;\n\n  p._insertCharacters(token);\n}\n\nfunction characterInForeignContent(p, token) {\n  p._insertCharacters(token);\n\n  p.framesetOk = false;\n}\n\nfunction startTagInForeignContent(p, token) {\n  if (foreignContent.causesExit(token) && !p.fragmentContext) {\n    while (p.treeAdapter.getNamespaceURI(p.openElements.current) !== NS.HTML && !p._isIntegrationPoint(p.openElements.current)) {\n      p.openElements.pop();\n    }\n\n    p._processToken(token);\n  } else {\n    const current = p._getAdjustedCurrentElement();\n\n    const currentNs = p.treeAdapter.getNamespaceURI(current);\n\n    if (currentNs === NS.MATHML) {\n      foreignContent.adjustTokenMathMLAttrs(token);\n    } else if (currentNs === NS.SVG) {\n      foreignContent.adjustTokenSVGTagName(token);\n      foreignContent.adjustTokenSVGAttrs(token);\n    }\n\n    foreignContent.adjustTokenXMLAttrs(token);\n\n    if (token.selfClosing) {\n      p._appendElement(token, currentNs);\n    } else {\n      p._insertElement(token, currentNs);\n    }\n\n    token.ackSelfClosing = true;\n  }\n}\n\nfunction endTagInForeignContent(p, token) {\n  for (let i = p.openElements.stackTop; i > 0; i--) {\n    const element = p.openElements.items[i];\n\n    if (p.treeAdapter.getNamespaceURI(element) === NS.HTML) {\n      p._processToken(token);\n\n      break;\n    }\n\n    if (p.treeAdapter.getTagName(element).toLowerCase() === token.tagName) {\n      p.openElements.popUntilElementPopped(element);\n      break;\n    }\n  }\n}","map":null,"metadata":{},"sourceType":"script"}