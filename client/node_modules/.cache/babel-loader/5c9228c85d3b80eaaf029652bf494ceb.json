{"ast":null,"code":"import { PreconditionFailure } from '../precondition/PreconditionFailure.js';\nimport { runIdToFrequency } from './IRawProperty.js';\nimport { readConfigureGlobal } from '../runner/configuration/GlobalParameters.js';\nimport { convertToNext } from '../arbitrary/definition/Converters.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { noUndefinedAsContext, UndefinedContextPlaceholder } from '../../arbitrary/_internals/helpers/NoUndefinedAsContext.js';\nexport class Property {\n  constructor(rawArb, predicate) {\n    this.predicate = predicate;\n\n    const _ref = readConfigureGlobal() || {},\n          _ref$beforeEach = _ref.beforeEach,\n          beforeEach = _ref$beforeEach === void 0 ? Property.dummyHook : _ref$beforeEach,\n          _ref$afterEach = _ref.afterEach,\n          afterEach = _ref$afterEach === void 0 ? Property.dummyHook : _ref$afterEach,\n          asyncBeforeEach = _ref.asyncBeforeEach,\n          asyncAfterEach = _ref.asyncAfterEach;\n\n    if (asyncBeforeEach !== undefined) {\n      throw Error('\"asyncBeforeEach\" can\\'t be set when running synchronous properties');\n    }\n\n    if (asyncAfterEach !== undefined) {\n      throw Error('\"asyncAfterEach\" can\\'t be set when running synchronous properties');\n    }\n\n    this.beforeEachHook = beforeEach;\n    this.afterEachHook = afterEach;\n    this.arb = convertToNext(rawArb);\n  }\n\n  isAsync() {\n    return false;\n  }\n\n  generate(mrng, runId) {\n    const value = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : undefined);\n    return noUndefinedAsContext(value);\n  }\n\n  shrink(value) {\n    if (value.context === undefined && !this.arb.canShrinkWithoutContext(value.value_)) {\n      return Stream.nil();\n    }\n\n    const safeContext = value.context !== UndefinedContextPlaceholder ? value.context : undefined;\n    return this.arb.shrink(value.value_, safeContext).map(noUndefinedAsContext);\n  }\n\n  run(v) {\n    this.beforeEachHook();\n\n    try {\n      const output = this.predicate(v);\n      return output == null || output === true ? null : 'Property failed by returning false';\n    } catch (err) {\n      if (PreconditionFailure.isFailure(err)) return err;\n      if (err instanceof Error && err.stack) return \"\".concat(err, \"\\n\\nStack trace: \").concat(err.stack);\n      return \"\".concat(err);\n    } finally {\n      this.afterEachHook();\n    }\n  }\n\n  beforeEach(hookFunction) {\n    const previousBeforeEachHook = this.beforeEachHook;\n\n    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);\n\n    return this;\n  }\n\n  afterEach(hookFunction) {\n    const previousAfterEachHook = this.afterEachHook;\n\n    this.afterEachHook = () => hookFunction(previousAfterEachHook);\n\n    return this;\n  }\n\n}\n\nProperty.dummyHook = () => {};","map":null,"metadata":{},"sourceType":"module"}