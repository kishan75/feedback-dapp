{"ast":null,"code":"const _require = require(\"@truffle/interface-adapter\"),\n      Web3Shim = _require.Web3Shim,\n      createInterfaceAdapter = _require.createInterfaceAdapter;\n\nconst utils = require(\"../utils\");\n\nconst execute = require(\"../execute\");\n\nconst bootstrap = require(\"./bootstrap\");\n\nconst debug = require(\"debug\")(\"contract:contract:constructorMethods\");\n\nconst OS = require(\"os\");\n\nmodule.exports = Contract => ({\n  configureNetwork({\n    networkType,\n    provider\n  } = {}) {\n    // otherwise use existing value as default (at most one of these)\n    networkType = networkType || this.networkType;\n    provider = provider || this.currentProvider; // recreate interfaceadapter\n\n    this.interfaceAdapter = createInterfaceAdapter({\n      networkType,\n      provider\n    });\n\n    if (this.web3) {\n      // update existing\n      this.web3.setNetworkType(networkType);\n      this.web3.setProvider(provider);\n    } else {\n      // create new\n      this.web3 = new Web3Shim({\n        networkType,\n        provider\n      });\n    } // save properties\n\n\n    this.currentProvider = provider;\n    this.networkType = networkType;\n  },\n\n  setProvider(provider) {\n    if (!provider) {\n      throw new Error(\"Invalid provider passed to setProvider(); provider is \".concat(provider));\n    }\n\n    this.configureNetwork({\n      provider\n    });\n  },\n\n  new() {\n    utils.checkProvider(this);\n\n    if (!this.bytecode || this.bytecode === \"0x\") {\n      throw new Error(\"\".concat(this.contractName, \" error: contract binary not set. Can't deploy new instance.\\n\") + \"This contract may be abstract, not implement an abstract parent's methods completely\\n\" + \"or not invoke an inherited contract's constructor correctly\\n\");\n    }\n\n    var constructorABI = this.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.deploy.call(this, constructorABI)(...arguments);\n  },\n\n  async at(address) {\n    if (address == null || typeof address !== \"string\" || address.length !== 42) {\n      throw new Error(\"Invalid address passed to \".concat(this.contractName, \".at(): \").concat(address));\n    }\n\n    await this.detectNetwork();\n    const onChainCode = await this.interfaceAdapter.getCode(address);\n    await utils.checkCode(onChainCode, this.contractName, address);\n    return new this(address);\n  },\n\n  async deployed() {\n    if (this.reloadJson) {\n      this.reloadJson(); //truffle test monkey-patches in this method\n    }\n\n    utils.checkProvider(this);\n    await this.detectNetwork();\n    utils.checkNetworkArtifactMatch(this);\n    utils.checkDeployment(this);\n    return new this(this.address);\n  },\n\n  defaults(class_defaults) {\n    if (this.class_defaults == null) {\n      this.class_defaults = {};\n    }\n\n    if (class_defaults == null) {\n      class_defaults = {};\n    }\n\n    Object.keys(class_defaults).forEach(key => {\n      const value = class_defaults[key];\n      this.class_defaults[key] = value;\n    });\n    return this.class_defaults;\n  },\n\n  hasNetwork(network_id) {\n    return this._json.networks[\"\".concat(network_id)] != null;\n  },\n\n  isDeployed() {\n    if (this.network_id == null) {\n      return false;\n    }\n\n    if (this._json.networks[this.network_id] == null) {\n      return false;\n    }\n\n    return !!this.network.address;\n  },\n\n  async detectNetwork() {\n    // guard interfaceAdapter!\n    if (this.interfaceAdapter == null) {\n      throw new Error(\"Provider not set or invalid\");\n    } // if artifacts already have a network_id and network configuration synced,\n    // use that network and use latest block gasLimit\n\n\n    if (this.network_id && this.networks[this.network_id] != null) {\n      const _ref = await this.interfaceAdapter.getBlock(\"latest\"),\n            gasLimit = _ref.gasLimit;\n\n      return {\n        id: this.network_id,\n        blockLimit: gasLimit\n      };\n    } // since artifacts don't have a network_id synced with a network configuration,\n    // poll chain for network_id and sync artifacts\n\n\n    const chainNetworkID = await this.interfaceAdapter.getNetworkId();\n\n    const _ref2 = await this.interfaceAdapter.getBlock(\"latest\"),\n          gasLimit = _ref2.gasLimit;\n\n    return await utils.setInstanceNetworkID(this, chainNetworkID, gasLimit);\n  },\n\n  setNetwork(network_id) {\n    if (!network_id) return;\n    this.network_id = \"\".concat(network_id);\n  },\n\n  setNetworkType(networkType = \"ethereum\") {\n    this.configureNetwork({\n      networkType\n    });\n  },\n\n  setWallet(wallet) {\n    this.configureNetwork();\n    this.web3.eth.accounts.wallet = wallet;\n  },\n\n  // Overrides the deployed address to null.\n  // You must call this explicitly so you don't inadvertently do this otherwise.\n  resetAddress() {\n    delete this.network.address;\n  },\n\n  // accepts 4 input formats\n  //  - (<name>, <address>)\n  //  - (<contractType>) - must have a deployed instance with an address\n  //  - (<contractInstance>)\n  //  - ({ <libName>: <address>, <libName2>: <address2>, ... })\n  link(name, address) {\n    switch (typeof name) {\n      case \"string\":\n        // Case: Contract.link(<libraryName>, <address>)\n        if (this._json.networks[this.network_id] == null) {\n          this._json.networks[this.network_id] = {\n            events: {},\n            links: {}\n          };\n        }\n\n        this.network.links[name] = address;\n        return;\n\n      case \"function\":\n        // Case: Contract.link(<contractType>)\n        const contract = name;\n\n        if (contract.isDeployed() === false) {\n          throw new Error(\"Cannot link contract without an address.\");\n        }\n\n        this.link(contract.contractName, contract.address); // Merge events so this contract knows about library's events\n\n        Object.keys(contract.events).forEach(topic => {\n          this.network.events[topic] = contract.events[topic];\n        });\n        return;\n\n      case \"object\":\n        // 2 Cases:\n        //   - Contract.link({<libraryName>: <address>, ... })\n        //   - Contract.link(<instance>)\n        const obj = name;\n\n        if (obj.constructor && typeof obj.constructor.contractName === \"string\" && obj.address) {\n          // obj is a Truffle contract instance\n          this.link(obj.constructor.contractName, obj.address);\n        } else {\n          // obj is of the form { <libraryName>: <address>, ... }\n          Object.keys(obj).forEach(name => this.link(name, obj[name]));\n        }\n\n        return;\n\n      default:\n        const invalidInput = \"Input to the link method is in the incorrect\" + \" format. Input must be one of the following:\".concat(OS.EOL) + \"    - a library name and address                 > (\\\"MyLibrary\\\", \" + \"\\\"0x123456789...\\\")\".concat(OS.EOL) + \"    - a contract type                            > \" + \"(MyContract)\".concat(OS.EOL) + \"    - a contract instance                        > \" + \"(myContract)\".concat(OS.EOL) + \"    - an object with library names and addresses > ({ <libName>: \" + \"<address>, <libName2>: <address2>, ... })\".concat(OS.EOL);\n        throw new Error(invalidInput);\n    }\n  },\n\n  // Note, this function can be called with two input types:\n  // 1. Object with a bunch of data; this data will be merged with the json data of contract being cloned.\n  // 2. network id; this will clone the contract and set a specific network id upon cloning.\n  clone(json) {\n    json = json || {};\n\n    const temp = function TruffleContract() {\n      this.constructor = temp;\n      return Contract.apply(this, arguments);\n    };\n\n    temp.prototype = Object.create(this.prototype);\n    let network_id; // If we have a network id passed\n\n    if (typeof json !== \"object\") {\n      network_id = json;\n      json = this._json;\n    }\n\n    json = utils.merge({}, this._json || {}, json);\n    temp._constructorMethods = this._constructorMethods;\n    temp._properties = this._properties;\n    temp._property_values = {};\n    temp._json = json;\n    bootstrap(temp);\n    temp.class_defaults = temp.prototype.defaults || {};\n\n    if (network_id) {\n      temp.setNetwork(network_id);\n    }\n\n    if (this.currentProvider) {\n      temp.configureNetwork({\n        provider: this.currentProvider,\n        networkType: this.networkType\n      });\n    } // Copy over custom key/values to the contract class\n\n\n    Object.keys(json).forEach(key => {\n      if (key.indexOf(\"x-\") !== 0) return;\n      temp[key] = json[key];\n    });\n    return temp;\n  },\n\n  addProp(key, fn) {\n    const getter = () => {\n      if (fn.get != null) {\n        return fn.get.call(this);\n      }\n\n      return this._property_values[key] || fn.call(this);\n    };\n\n    const setter = val => {\n      if (fn.set != null) {\n        fn.set.call(this, val);\n        return;\n      } // If there's not a setter, then the property is immutable.\n\n\n      throw new Error(\"\".concat(key, \" property is immutable\"));\n    };\n\n    const definition = {};\n    definition.enumerable = false;\n    definition.configurable = false;\n    definition.get = getter;\n    definition.set = setter;\n    Object.defineProperty(this, key, definition);\n  },\n\n  toJSON() {\n    return this._json;\n  },\n\n  decodeLogs: utils.decodeLogs\n});","map":null,"metadata":{},"sourceType":"script"}