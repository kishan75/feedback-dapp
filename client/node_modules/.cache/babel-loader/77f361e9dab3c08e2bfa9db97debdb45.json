{"ast":null,"code":"\"use strict\";\n/**\n * Contains the types for type objects, and some\n * functions for working with them.\n *\n * @category Main Format\n *\n * @packageDocumentation\n */\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isContractDefinedType = exports.typeStringWithoutLocation = exports.typeString = exports.specifyLocation = exports.fullType = exports.isReferenceType = exports.forgetCompilations = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:format:types\");\n\nfunction forgetCompilations(typesByCompilation) {\n  return Object.assign({}, ...Object.values(typesByCompilation).map(({\n    types\n  }) => types));\n}\n\nexports.forgetCompilations = forgetCompilations;\n\nfunction isUserDefinedType(anyType) {\n  const userDefinedTypes = [\"contract\", \"enum\", \"struct\", \"userDefinedValueType\"];\n  return userDefinedTypes.includes(anyType.typeClass);\n}\n\nfunction isReferenceType(anyType) {\n  const alwaysReferenceTypes = [\"array\", \"mapping\", \"struct\", \"string\"];\n\n  if (alwaysReferenceTypes.includes(anyType.typeClass)) {\n    return true;\n  } else if (anyType.typeClass === \"bytes\") {\n    return anyType.kind === \"dynamic\";\n  } else {\n    return false;\n  }\n}\n\nexports.isReferenceType = isReferenceType; //one could define a counterpart function that stripped all unnecessary information\n//from the type object, but at the moment I see no need for that\n\nfunction fullType(basicType, userDefinedTypes) {\n  if (!isUserDefinedType(basicType)) {\n    return basicType;\n  }\n\n  let id = basicType.id;\n  let storedType = userDefinedTypes[id];\n\n  if (!storedType) {\n    return basicType;\n  }\n\n  let returnType = Object.assign(Object.assign({}, basicType), storedType);\n\n  if (isReferenceType(basicType) && basicType.location !== undefined) {\n    returnType = specifyLocation(returnType, basicType.location);\n  }\n\n  return returnType;\n}\n\nexports.fullType = fullType; //the location argument here always forces, so passing undefined *will* force undefined\n\nfunction specifyLocation(dataType, location) {\n  if (isReferenceType(dataType)) {\n    switch (dataType.typeClass) {\n      case \"string\":\n      case \"bytes\":\n        return Object.assign(Object.assign({}, dataType), {\n          location\n        });\n\n      case \"array\":\n        return Object.assign(Object.assign({}, dataType), {\n          location,\n          baseType: specifyLocation(dataType.baseType, location)\n        });\n\n      case \"mapping\":\n        let newLocation = location === \"storage\" ? \"storage\" : undefined;\n        return Object.assign(Object.assign({}, dataType), {\n          location: newLocation,\n          valueType: specifyLocation(dataType.valueType, newLocation)\n        });\n\n      case \"struct\":\n        let returnType = Object.assign(Object.assign({}, dataType), {\n          location\n        });\n\n        if (returnType.memberTypes) {\n          returnType.memberTypes = returnType.memberTypes.map(({\n            name: memberName,\n            type: memberType\n          }) => ({\n            name: memberName,\n            type: specifyLocation(memberType, location)\n          }));\n        }\n\n        return returnType;\n    }\n  } else {\n    return dataType;\n  }\n}\n\nexports.specifyLocation = specifyLocation; //NOTE: the following two functions might not be exactly right for weird internal stuff,\n//or for ABI-only stuff.  (E.g. for internal stuff sometimes it records whether things\n//are pointers or not??  we don't track that so we can't recreate that)\n//But what can you do.\n\nfunction typeString(dataType) {\n  let baseString = typeStringWithoutLocation(dataType);\n\n  if (isReferenceType(dataType) && dataType.location) {\n    return baseString + \" \" + dataType.location;\n  } else {\n    return baseString;\n  }\n}\n\nexports.typeString = typeString;\n\nfunction typeStringWithoutLocation(dataType) {\n  switch (dataType.typeClass) {\n    case \"uint\":\n      return dataType.typeHint || \"uint\".concat(dataType.bits);\n\n    case \"int\":\n      return dataType.typeHint || \"int\".concat(dataType.bits);\n\n    case \"bool\":\n      return dataType.typeHint || \"bool\";\n\n    case \"bytes\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return \"bytes\";\n\n        case \"static\":\n          return \"bytes\".concat(dataType.length);\n      }\n\n    case \"address\":\n      switch (dataType.kind) {\n        case \"general\":\n          return dataType.typeHint || \"address\";\n        //I guess?\n\n        case \"specific\":\n          return dataType.payable ? \"address payable\" : \"address\";\n      }\n\n    case \"string\":\n      return dataType.typeHint || \"string\";\n\n    case \"fixed\":\n      return dataType.typeHint || \"fixed\".concat(dataType.bits, \"x\").concat(dataType.places);\n\n    case \"ufixed\":\n      return dataType.typeHint || \"ufixed\".concat(dataType.bits, \"x\").concat(dataType.places);\n\n    case \"array\":\n      if (dataType.typeHint) {\n        return dataType.typeHint;\n      }\n\n      switch (dataType.kind) {\n        case \"dynamic\":\n          return \"\".concat(typeStringWithoutLocation(dataType.baseType), \"[]\");\n\n        case \"static\":\n          return \"\".concat(typeStringWithoutLocation(dataType.baseType), \"[\").concat(dataType.length, \"]\");\n      }\n\n    case \"mapping\":\n      return \"mapping(\".concat(typeStringWithoutLocation(dataType.keyType), \" => \").concat(typeStringWithoutLocation(dataType.valueType), \")\");\n\n    case \"struct\":\n    case \"enum\":\n      //combining these cases for simplicity\n      switch (dataType.kind) {\n        case \"local\":\n          return \"\".concat(dataType.typeClass, \" \").concat(dataType.definingContractName, \".\").concat(dataType.typeName);\n\n        case \"global\":\n          return \"\".concat(dataType.typeClass, \" \").concat(dataType.typeName);\n      }\n\n      break;\n    //to satisfy TS :P\n\n    case \"userDefinedValueType\":\n      //differs from struct & enum in that typeClass is omitted\n      switch (dataType.kind) {\n        case \"local\":\n          return \"\".concat(dataType.definingContractName, \".\").concat(dataType.typeName);\n\n        case \"global\":\n          return \"\".concat(dataType.typeName);\n      }\n\n      break;\n    //to satisfy TS :P\n\n    case \"tuple\":\n      return dataType.typeHint || \"tuple(\" + dataType.memberTypes.map(memberType => typeString(memberType.type)).join(\",\") + \")\";\n    //note that we do include location and do not put spaces\n\n    case \"contract\":\n      return dataType.contractKind + \" \" + dataType.typeName;\n\n    case \"magic\":\n      //no, this is not transposed!\n      const variableNames = {\n        message: \"msg\",\n        transaction: \"tx\",\n        block: \"block\"\n      };\n      return variableNames[dataType.variable];\n\n    case \"type\":\n      return \"type(\".concat(typeString(dataType.type), \")\");\n\n    case \"function\":\n      let visibilityString;\n\n      switch (dataType.visibility) {\n        case \"external\":\n          if (dataType.kind === \"general\") {\n            if (dataType.typeHint) {\n              return dataType.typeHint;\n            } else {\n              return \"function external\"; //I guess???\n            }\n          }\n\n          visibilityString = \" external\"; //note the deliberate space!\n\n          break;\n\n        case \"internal\":\n          visibilityString = \"\";\n          break;\n      }\n\n      let mutabilityString = dataType.mutability === \"nonpayable\" ? \"\" : \" \" + dataType.mutability; //again, note the deliberate space\n\n      let inputList = dataType.inputParameterTypes.map(typeString).join(\",\"); //note that we do include location, and do not put spaces\n\n      let outputList = dataType.outputParameterTypes.map(typeString).join(\",\");\n      let inputString = \"function(\".concat(inputList, \")\");\n      let outputString = outputList === \"\" ? \"\" : \" returns (\".concat(outputList, \")\"); //again, note the deliberate space\n\n      return inputString + mutabilityString + visibilityString + outputString;\n  }\n}\n\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\n\nfunction isContractDefinedType(anyType) {\n  const contractDefinedTypes = [\"enum\", \"struct\", \"userDefinedValueType\"];\n  return contractDefinedTypes.includes(anyType.typeClass) && anyType.kind === \"local\";\n}\n\nexports.isContractDefinedType = isContractDefinedType;","map":null,"metadata":{},"sourceType":"script"}