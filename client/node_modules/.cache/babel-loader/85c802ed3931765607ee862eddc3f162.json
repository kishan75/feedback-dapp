{"ast":null,"code":"import { PreconditionFailure } from '../precondition/PreconditionFailure.js';\nimport { runIdToFrequency } from './IRawProperty.js';\nimport { readConfigureGlobal } from '../runner/configuration/GlobalParameters.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { convertToNext } from '../arbitrary/definition/Converters.js';\nimport { noUndefinedAsContext, UndefinedContextPlaceholder } from '../../arbitrary/_internals/helpers/NoUndefinedAsContext.js';\nexport class AsyncProperty {\n  constructor(rawArb, predicate) {\n    this.predicate = predicate;\n\n    const _ref = readConfigureGlobal() || {},\n          asyncBeforeEach = _ref.asyncBeforeEach,\n          asyncAfterEach = _ref.asyncAfterEach,\n          beforeEach = _ref.beforeEach,\n          afterEach = _ref.afterEach;\n\n    if (asyncBeforeEach !== undefined && beforeEach !== undefined) {\n      throw Error('Global \"asyncBeforeEach\" and \"beforeEach\" parameters can\\'t be set at the same time when running async properties');\n    }\n\n    if (asyncAfterEach !== undefined && afterEach !== undefined) {\n      throw Error('Global \"asyncAfterEach\" and \"afterEach\" parameters can\\'t be set at the same time when running async properties');\n    }\n\n    this.beforeEachHook = asyncBeforeEach || beforeEach || AsyncProperty.dummyHook;\n    this.afterEachHook = asyncAfterEach || afterEach || AsyncProperty.dummyHook;\n    this.arb = convertToNext(rawArb);\n  }\n\n  isAsync() {\n    return true;\n  }\n\n  generate(mrng, runId) {\n    const value = this.arb.generate(mrng, runId != null ? runIdToFrequency(runId) : undefined);\n    return noUndefinedAsContext(value);\n  }\n\n  shrink(value) {\n    if (value.context === undefined && !this.arb.canShrinkWithoutContext(value.value_)) {\n      return Stream.nil();\n    }\n\n    const safeContext = value.context !== UndefinedContextPlaceholder ? value.context : undefined;\n    return this.arb.shrink(value.value_, safeContext).map(noUndefinedAsContext);\n  }\n\n  async run(v) {\n    await this.beforeEachHook();\n\n    try {\n      const output = await this.predicate(v);\n      return output == null || output === true ? null : 'Property failed by returning false';\n    } catch (err) {\n      if (PreconditionFailure.isFailure(err)) return err;\n      if (err instanceof Error && err.stack) return \"\".concat(err, \"\\n\\nStack trace: \").concat(err.stack);\n      return \"\".concat(err);\n    } finally {\n      await this.afterEachHook();\n    }\n  }\n\n  beforeEach(hookFunction) {\n    const previousBeforeEachHook = this.beforeEachHook;\n\n    this.beforeEachHook = () => hookFunction(previousBeforeEachHook);\n\n    return this;\n  }\n\n  afterEach(hookFunction) {\n    const previousAfterEachHook = this.afterEachHook;\n\n    this.afterEachHook = () => hookFunction(previousAfterEachHook);\n\n    return this;\n  }\n\n}\n\nAsyncProperty.dummyHook = () => {};","map":null,"metadata":{},"sourceType":"module"}