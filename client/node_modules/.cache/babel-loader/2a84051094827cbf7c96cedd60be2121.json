{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar _slicedToArray = require(\"F:\\\\BlockChain\\\\Projects\\\\feedback-dapp\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.definitionToStoredType = exports.definitionToType = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:ast:import\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst Compiler = __importStar(require(\"../../compiler\"));\n\nconst Utils = __importStar(require(\"../utils\"));\n\nconst import_1 = require(\"../../contexts/import\"); //NOTE: the following function will *not* work for arbitrary nodes! It will,\n//however, work well enough for what we need.  I.e., it will:\n//1. work when given the actual variable definition as the node,\n//2. work when given an elementary type as the node,\n//3. work when given a user-defined type as the node,\n//4. produce something of the correct size in all cases.\n//Use beyond that is at your own risk!\n//NOTE: set forceLocation to *null* to force no location. leave it undefined\n//to not force a location.\n\n\nfunction definitionToType(definition, compilationId, compiler, forceLocation) {\n  let typeClass = Utils.typeClass(definition);\n  let typeHint = Utils.typeStringWithoutLocation(definition);\n\n  switch (typeClass) {\n    case \"bool\":\n      return {\n        typeClass,\n        typeHint\n      };\n\n    case \"address\":\n      {\n        switch (Compiler.Utils.solidityFamily(compiler)) {\n          case \"unknown\": //I guess?\n\n          case \"pre-0.5.0\":\n            return {\n              typeClass,\n              kind: \"general\",\n              typeHint\n            };\n\n          default:\n            return {\n              typeClass,\n              kind: \"specific\",\n              payable: Utils.typeIdentifier(definition) === \"t_address_payable\"\n            };\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"uint\":\n      {\n        let bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          typeHint\n        };\n      }\n\n    case \"int\":\n      {\n        //typeScript won't let me group these for some reason\n        let bytes = Utils.specifiedSize(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          typeHint\n        };\n      }\n\n    case \"fixed\":\n      {\n        //typeScript won't let me group these for some reason\n        let bytes = Utils.specifiedSize(definition);\n        let places = Utils.decimalPlaces(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          places,\n          typeHint\n        };\n      }\n\n    case \"ufixed\":\n      {\n        let bytes = Utils.specifiedSize(definition);\n        let places = Utils.decimalPlaces(definition);\n        return {\n          typeClass,\n          bits: bytes * 8,\n          places,\n          typeHint\n        };\n      }\n\n    case \"string\":\n      {\n        if (forceLocation === null) {\n          return {\n            typeClass,\n            typeHint\n          };\n        }\n\n        let location = forceLocation || Utils.referenceType(definition);\n        return {\n          typeClass,\n          location,\n          typeHint\n        };\n      }\n\n    case \"bytes\":\n      {\n        let length = Utils.specifiedSize(definition);\n\n        if (length !== null) {\n          return {\n            typeClass,\n            kind: \"static\",\n            length,\n            typeHint\n          };\n        } else {\n          if (forceLocation === null) {\n            return {\n              typeClass,\n              kind: \"dynamic\",\n              typeHint\n            };\n          }\n\n          let location = forceLocation || Utils.referenceType(definition);\n          return {\n            typeClass,\n            kind: \"dynamic\",\n            location,\n            typeHint\n          };\n        }\n      }\n\n    case \"array\":\n      {\n        let baseDefinition = Utils.baseDefinition(definition);\n        let baseType = definitionToType(baseDefinition, compilationId, compiler, forceLocation);\n        let location = forceLocation || Utils.referenceType(definition);\n\n        if (Utils.isDynamicArray(definition)) {\n          if (forceLocation !== null) {\n            return {\n              typeClass,\n              baseType,\n              kind: \"dynamic\",\n              location,\n              typeHint\n            };\n          } else {\n            return {\n              typeClass,\n              baseType,\n              kind: \"dynamic\",\n              typeHint\n            };\n          }\n        } else {\n          let length = new bn_js_1.default(Utils.staticLengthAsString(definition));\n\n          if (forceLocation !== null) {\n            return {\n              typeClass,\n              baseType,\n              kind: \"static\",\n              length,\n              location,\n              typeHint\n            };\n          } else {\n            return {\n              typeClass,\n              baseType,\n              kind: \"static\",\n              length,\n              typeHint\n            };\n          }\n        }\n      }\n\n    case \"mapping\":\n      {\n        let keyDefinition = Utils.keyDefinition(definition); //note that we can skip the scopes argument here! that's only needed when\n        //a general node, rather than a declaration, is being passed in\n\n        let keyType = definitionToType(keyDefinition, compilationId, compiler, null); //suppress the location on the key type (it'll be given as memory but\n        //this is meaningless)\n        //also, we have to tell TypeScript ourselves that this will be an elementary\n        //type; it has no way of knowing that\n\n        debug(\"definition: %O\", definition);\n        let valueDefinition = Utils.valueDefinition(definition);\n        let valueType = definitionToType(valueDefinition, compilationId, compiler, forceLocation);\n\n        if (forceLocation === null) {\n          return {\n            typeClass,\n            keyType,\n            valueType\n          };\n        }\n\n        return {\n          typeClass,\n          keyType,\n          valueType,\n          location: \"storage\"\n        };\n      }\n\n    case \"function\":\n      {\n        //WARNING! This case will not work unless given the actual\n        //definition!  It should return something *roughly* usable, though.\n        let visibility = Utils.visibility(definition); //undefined if bad node\n\n        let mutability = Utils.mutability(definition); //undefined if bad node\n\n        let _ref = Utils.parameters(definition) || [[], []],\n            _ref2 = _slicedToArray(_ref, 2),\n            inputParameters = _ref2[0],\n            outputParameters = _ref2[1]; //HACK\n        //note: don't force a location on these! use the listed location!\n\n\n        let inputParameterTypes = inputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n        let outputParameterTypes = outputParameters.map(parameter => definitionToType(parameter, compilationId, compiler));\n\n        switch (visibility) {\n          case \"internal\":\n            return {\n              typeClass,\n              visibility,\n              mutability,\n              inputParameterTypes,\n              outputParameterTypes\n            };\n\n          case \"external\":\n            return {\n              typeClass,\n              visibility,\n              kind: \"specific\",\n              mutability,\n              inputParameterTypes,\n              outputParameterTypes\n            };\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"struct\":\n      {\n        let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n        let qualifiedName = typeHint.match(/struct (.*)/)[1];\n        let definingContractName;\n        let typeName;\n\n        if (qualifiedName.includes(\".\")) {\n          var _qualifiedName$split = qualifiedName.split(\".\");\n\n          var _qualifiedName$split2 = _slicedToArray(_qualifiedName$split, 2);\n\n          definingContractName = _qualifiedName$split2[0];\n          typeName = _qualifiedName$split2[1];\n        } else {\n          typeName = qualifiedName; //leave definingContractName undefined\n        }\n\n        if (forceLocation === null) {\n          if (definingContractName) {\n            return {\n              typeClass,\n              kind: \"local\",\n              id,\n              typeName,\n              definingContractName\n            };\n          } else {\n            return {\n              typeClass,\n              kind: \"global\",\n              id,\n              typeName\n            };\n          }\n        }\n\n        let location = forceLocation || Utils.referenceType(definition);\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            location\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName,\n            location\n          };\n        }\n      }\n\n    case \"enum\":\n      {\n        let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n        let qualifiedName = typeHint.match(/enum (.*)/)[1];\n        let definingContractName;\n        let typeName;\n\n        if (qualifiedName.includes(\".\")) {\n          var _qualifiedName$split3 = qualifiedName.split(\".\");\n\n          var _qualifiedName$split4 = _slicedToArray(_qualifiedName$split3, 2);\n\n          definingContractName = _qualifiedName$split4[0];\n          typeName = _qualifiedName$split4[1];\n        } else {\n          typeName = qualifiedName; //leave definingContractName undefined\n        }\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName\n          };\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n        let definingContractName;\n        let typeName;\n\n        if (typeHint.includes(\".\")) {\n          var _typeHint$split = typeHint.split(\".\");\n\n          var _typeHint$split2 = _slicedToArray(_typeHint$split, 2);\n\n          definingContractName = _typeHint$split2[0];\n          typeName = _typeHint$split2[1];\n        } else {\n          typeName = typeHint; //leave definingContractName undefined\n        }\n\n        if (definingContractName) {\n          return {\n            typeClass,\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName\n          };\n        } else {\n          return {\n            typeClass,\n            kind: \"global\",\n            id,\n            typeName\n          };\n        }\n      }\n\n    case \"contract\":\n      {\n        let id = import_1.makeTypeId(Utils.typeId(definition), compilationId);\n        let typeName = typeHint.match(/(contract|library|interface) (.*)/)[2]; //note: we use the type string rather than the type identifier\n        //in order to avoid having to deal with the underscore problem\n\n        let contractKind = Utils.contractKind(definition);\n        return {\n          typeClass,\n          kind: \"native\",\n          id,\n          typeName,\n          contractKind\n        };\n      }\n\n    case \"magic\":\n      {\n        let typeIdentifier = Utils.typeIdentifier(definition);\n        let variable = typeIdentifier.match(/^t_magic_(.*)$/)[1];\n        return {\n          typeClass,\n          variable\n        };\n      }\n  }\n}\n\nexports.definitionToType = definitionToType; //whereas the above takes variable definitions, this takes the actual type\n//definition\n\nfunction definitionToStoredType(definition, compilationId, compiler, referenceDeclarations) {\n  switch (definition.nodeType) {\n    case \"StructDefinition\":\n      {\n        const _getDefiningInfo = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations),\n              id = _getDefiningInfo.id,\n              typeName = _getDefiningInfo.typeName,\n              definingContractName = _getDefiningInfo.definingContractName,\n              definingContract = _getDefiningInfo.definingContract;\n\n        const memberTypes = definition.members.map(member => ({\n          name: member.name,\n          type: definitionToType(member, compilationId, compiler, null)\n        }));\n\n        if (definingContract) {\n          return {\n            typeClass: \"struct\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            memberTypes\n          };\n        } else {\n          return {\n            typeClass: \"struct\",\n            kind: \"global\",\n            id,\n            typeName,\n            memberTypes\n          };\n        }\n      }\n\n    case \"EnumDefinition\":\n      {\n        const _getDefiningInfo2 = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations),\n              id = _getDefiningInfo2.id,\n              typeName = _getDefiningInfo2.typeName,\n              definingContractName = _getDefiningInfo2.definingContractName,\n              definingContract = _getDefiningInfo2.definingContract;\n\n        const options = definition.members.map(member => member.name);\n\n        if (definingContract) {\n          return {\n            typeClass: \"enum\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            options\n          };\n        } else {\n          return {\n            typeClass: \"enum\",\n            kind: \"global\",\n            id,\n            typeName,\n            options\n          };\n        }\n      }\n\n    case \"UserDefinedValueTypeDefinition\":\n      {\n        const _getDefiningInfo3 = getDefiningInfo(definition, compilationId, compiler, referenceDeclarations),\n              id = _getDefiningInfo3.id,\n              typeName = _getDefiningInfo3.typeName,\n              definingContractName = _getDefiningInfo3.definingContractName,\n              definingContract = _getDefiningInfo3.definingContract;\n\n        let underlyingType = definitionToType(definition.underlyingType, compilationId, compiler, null); //final null doesn't matter here\n\n        if (definingContract) {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"local\",\n            id,\n            typeName,\n            definingContractName,\n            definingContract,\n            underlyingType\n          };\n        } else {\n          return {\n            typeClass: \"userDefinedValueType\",\n            kind: \"global\",\n            id,\n            typeName,\n            underlyingType\n          };\n        }\n      }\n\n    case \"ContractDefinition\":\n      {\n        let id = import_1.makeTypeId(definition.id, compilationId);\n        let typeName = definition.name;\n        let contractKind = definition.contractKind;\n        let payable = Utils.isContractPayable(definition);\n        return {\n          typeClass: \"contract\",\n          kind: \"native\",\n          id,\n          typeName,\n          contractKind,\n          payable\n        };\n      }\n  }\n}\n\nexports.definitionToStoredType = definitionToStoredType;\n\nfunction getDefiningInfo(definition, compilationId, compiler, referenceDeclarations) {\n  const id = import_1.makeTypeId(definition.id, compilationId);\n  let definingContractName;\n  let typeName;\n\n  if (definition.canonicalName) {\n    if (definition.canonicalName.includes(\".\")) {\n      var _definition$canonical = definition.canonicalName.split(\".\");\n\n      var _definition$canonical2 = _slicedToArray(_definition$canonical, 2);\n\n      definingContractName = _definition$canonical2[0];\n      typeName = _definition$canonical2[1];\n    } else {\n      typeName = definition.canonicalName;\n    }\n  } else {\n    //due to a bug, in 0.8.8 UDVTs lack a canonicalName.\n    //so we'll set typeName based on name instead of canonicalName,\n    //and set definingContractName below based on definingContract.\n    //(this does mean that we'll mess up a bit if referenceDeclarations\n    //is not passed... but realistically that shouldn't come up?  really the\n    //same kind of hapepns for every type)\n    typeName = definition.name;\n  }\n\n  let definingContract = undefined;\n  ;\n\n  if (referenceDeclarations) {\n    let contractDefinition = Object.values(referenceDeclarations).find(node => node.nodeType === \"ContractDefinition\" && node.nodes.some(subNode => import_1.makeTypeId(subNode.id, compilationId) === id));\n\n    if (contractDefinition) {\n      definingContract = definitionToStoredType(contractDefinition, compilationId, compiler); //can skip reference declarations\n\n      if (!definingContractName) {\n        definingContractName = contractDefinition.name;\n      }\n    }\n  }\n\n  return {\n    definingContract,\n    definingContractName,\n    typeName,\n    id\n  };\n}","map":null,"metadata":{},"sourceType":"script"}