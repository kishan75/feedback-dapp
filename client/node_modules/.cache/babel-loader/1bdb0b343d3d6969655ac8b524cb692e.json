{"ast":null,"code":"// Tweaked version of nathan7's binary-parse-stream\n// (see https://github.com/nathan7/binary-parse-stream)\n// Uses NoFilter instead of the readable in the original.  Removes\n// the ability to read -1, which was odd and un-needed.\n// License for binary-parse-stream: MIT\n// binary-parse-stream is now unmaintained, so I'm going to rewrite it as\n// more modern JS so I can get tsc to help check types.\n'use strict';\n\nconst Stream = require('stream');\n\nconst NoFilter = require('nofilter');\n\nconst TransformStream = Stream.Transform;\n/**\n * BinaryParseStream is a TransformStream that consumes buffers and outputs\n * objects on the other end.  It expects your subclass to implement a `_parse`\n * method that is a generator.  When your generator yields a number, it'll be\n * fed a buffer of that length from the input.  When your generator returns,\n * the return value will be pushed to the output side.\n *\n * @class BinaryParseStream\n * @extends {TransformStream}\n */\n\nclass BinaryParseStream extends TransformStream {\n  constructor(options) {\n    super(options); // doesn't work to pass these in as opts, for some reason\n\n    this['_writableState'].objectMode = false;\n    this['_readableState'].objectMode = true;\n    this.bs = new NoFilter();\n\n    this.__restart();\n  }\n\n  _transform(fresh, encoding, cb) {\n    this.bs.write(fresh);\n\n    while (this.bs.length >= this.__needed) {\n      let ret;\n      const chunk = this.__needed === null ? undefined : this.bs.read(this.__needed);\n\n      try {\n        ret = this.__parser.next(chunk);\n      } catch (e) {\n        return cb(e);\n      }\n\n      if (this.__needed) {\n        this.__fresh = false;\n      }\n\n      if (!ret.done) {\n        this.__needed = ret.value || 0;\n      } else {\n        this.push(ret.value);\n\n        this.__restart();\n      }\n    }\n\n    return cb();\n  }\n  /**\n   * @abstract\n   */\n\n  /* istanbul ignore next */\n\n\n  *_parse() {\n    throw new Error('Must be implemented in subclass');\n  }\n\n  __restart() {\n    this.__needed = null;\n    this.__parser = this._parse();\n    this.__fresh = true;\n  }\n\n  _flush(cb) {\n    cb(this.__fresh ? null : new Error('unexpected end of input'));\n  }\n\n}\n\nmodule.exports = BinaryParseStream;","map":null,"metadata":{},"sourceType":"script"}