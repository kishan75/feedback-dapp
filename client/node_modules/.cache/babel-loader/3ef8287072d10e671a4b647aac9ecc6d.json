{"ast":null,"code":"import { stream } from '../../stream/Stream.js';\nimport { convertToNextProperty } from '../property/ConvertersProperty.js';\nimport { Property } from '../property/Property.generic.js';\nimport { UnbiasedProperty } from '../property/UnbiasedProperty.js';\nimport { readConfigureGlobal } from './configuration/GlobalParameters.js';\nimport { QualifiedParameters } from './configuration/QualifiedParameters.js';\nimport { toss } from './Tosser.js';\nimport { pathWalk } from './utils/PathWalker.js';\n\nfunction toProperty(generator, qParams) {\n  const prop = !Object.prototype.hasOwnProperty.call(generator, 'isAsync') ? new Property(generator, () => true) : convertToNextProperty(generator);\n  return qParams.unbiased === true ? new UnbiasedProperty(prop) : prop;\n}\n\nfunction streamSample(generator, params) {\n  const extendedParams = typeof params === 'number' ? Object.assign(Object.assign({}, readConfigureGlobal()), {\n    numRuns: params\n  }) : Object.assign(Object.assign({}, readConfigureGlobal()), params);\n  const qParams = QualifiedParameters.read(extendedParams);\n  const nextProperty = toProperty(generator, qParams);\n  const shrink = nextProperty.shrink.bind(nextProperty);\n  const tossedValues = stream(toss(nextProperty, qParams.seed, qParams.randomType, qParams.examples));\n\n  if (qParams.path.length === 0) {\n    return tossedValues.take(qParams.numRuns).map(s => s().value_);\n  }\n\n  return stream(pathWalk(qParams.path, tossedValues.map(s => s()), shrink)).take(qParams.numRuns).map(s => s.value_);\n}\n\nfunction sample(generator, params) {\n  return [...streamSample(generator, params)];\n}\n\nfunction statistics(generator, classify, params) {\n  const extendedParams = typeof params === 'number' ? Object.assign(Object.assign({}, readConfigureGlobal()), {\n    numRuns: params\n  }) : Object.assign(Object.assign({}, readConfigureGlobal()), params);\n  const qParams = QualifiedParameters.read(extendedParams);\n  const recorded = {};\n\n  for (const g of streamSample(generator, params)) {\n    const out = classify(g);\n    const categories = Array.isArray(out) ? out : [out];\n\n    for (const c of categories) {\n      recorded[c] = (recorded[c] || 0) + 1;\n    }\n  }\n\n  const data = Object.entries(recorded).sort((a, b) => b[1] - a[1]).map(i => [i[0], \"\".concat((i[1] * 100.0 / qParams.numRuns).toFixed(2), \"%\")]);\n  const longestName = data.map(i => i[0].length).reduce((p, c) => Math.max(p, c), 0);\n  const longestPercent = data.map(i => i[1].length).reduce((p, c) => Math.max(p, c), 0);\n\n  for (const item of data) {\n    qParams.logger(\"\".concat(item[0].padEnd(longestName, '.'), \"..\").concat(item[1].padStart(longestPercent, '.')));\n  }\n}\n\nexport { sample, statistics };","map":null,"metadata":{},"sourceType":"module"}