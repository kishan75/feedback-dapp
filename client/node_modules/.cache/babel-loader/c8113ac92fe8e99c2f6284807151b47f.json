{"ast":null,"code":"\"use strict\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Web3InterfaceAdapter = void 0;\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst shim_1 = require(\"../../shim\");\n\nclass Web3InterfaceAdapter {\n  constructor({\n    provider,\n    networkType\n  } = {}) {\n    this.web3 = new shim_1.Web3Shim({\n      provider,\n      networkType\n    });\n  }\n\n  getNetworkId() {\n    return this.web3.eth.net.getId();\n  }\n\n  getBlock(block) {\n    return this.web3.eth.getBlock(block);\n  }\n\n  getTransaction(tx) {\n    return this.web3.eth.getTransaction(tx);\n  }\n\n  getTransactionReceipt(tx) {\n    return this.web3.eth.getTransactionReceipt(tx);\n  }\n\n  getBalance(address) {\n    return this.web3.eth.getBalance(address);\n  }\n\n  getCode(address) {\n    return this.web3.eth.getCode(address);\n  }\n\n  getAccounts() {\n    return this.web3.eth.getAccounts();\n  }\n\n  estimateGas(transactionConfig, stacktrace = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // web3 does not error gracefully when gas estimation fails due to a revert,\n      // so in cases where we want to get past this (debugging/stacktracing), we must\n      // catch the error and return null instead\n      if (stacktrace === true) {\n        try {\n          const gasEstimate = yield this.web3.eth.estimateGas(transactionConfig);\n          return gasEstimate;\n        } catch (_a) {\n          return null;\n        }\n      } else {\n        return this.web3.eth.estimateGas(transactionConfig);\n      }\n    });\n  }\n\n  getBlockNumber() {\n    return this.web3.eth.getBlockNumber();\n  }\n\n  getTransactionCostReport(receipt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const tx = yield this.getTransaction(receipt.transactionHash);\n      const block = yield this.getBlock(receipt.blockNumber);\n      if (!block) return null;\n      const balance = yield this.getBalance(tx.from);\n      const gasPrice = new bn_js_1.default(tx.gasPrice);\n      const gas = new bn_js_1.default(receipt.gasUsed);\n      const value = new bn_js_1.default(tx.value);\n      const cost = gasPrice.mul(gas).add(value);\n      return {\n        timestamp: block.timestamp,\n        from: tx.from,\n        balance: shim_1.Web3Shim.utils.fromWei(balance, \"ether\"),\n        gasUnit: \"gwei\",\n        gasPrice: shim_1.Web3Shim.utils.fromWei(gasPrice, \"gwei\"),\n        gas,\n        valueUnit: \"ETH\",\n        value: shim_1.Web3Shim.utils.fromWei(value, \"ether\"),\n        cost\n      };\n    });\n  }\n\n  displayCost(value) {\n    return shim_1.Web3Shim.utils.fromWei(value, \"ether\");\n  }\n\n}\n\nexports.Web3InterfaceAdapter = Web3InterfaceAdapter;","map":null,"metadata":{},"sourceType":"script"}