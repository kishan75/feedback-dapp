{"ast":null,"code":"import { convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { CommandsIterable } from '../../check/model/commands/CommandsIterable.js';\nimport { CommandWrapper } from '../../check/model/commands/CommandWrapper.js';\nimport { ReplayPath } from '../../check/model/ReplayPath.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { oneof } from '../oneof.js';\nimport { restrictedIntegerArbitraryBuilder } from './builders/RestrictedIntegerArbitraryBuilder.js';\nexport class CommandsArbitrary extends NextArbitrary {\n  constructor(commandArbs, maxGeneratedCommands, maxCommands, sourceReplayPath, disableReplayLog) {\n    super();\n    this.sourceReplayPath = sourceReplayPath;\n    this.disableReplayLog = disableReplayLog;\n    this.oneCommandArb = convertToNext(oneof(...commandArbs).map(c => new CommandWrapper(c)));\n    this.lengthArb = convertToNext(restrictedIntegerArbitraryBuilder(0, maxGeneratedCommands, maxCommands));\n    this.replayPath = [];\n    this.replayPathPosition = 0;\n  }\n\n  metadataForReplay() {\n    return this.disableReplayLog ? '' : \"replayPath=\".concat(JSON.stringify(ReplayPath.stringify(this.replayPath)));\n  }\n\n  buildNextValueFor(items, shrunkOnce) {\n    const commands = items.map(item => item.value_);\n    const context = {\n      shrunkOnce,\n      items\n    };\n    return new NextValue(new CommandsIterable(commands, () => this.metadataForReplay()), context);\n  }\n\n  generate(mrng) {\n    const size = this.lengthArb.generate(mrng, undefined);\n    const sizeValue = size.value;\n    const items = Array(sizeValue);\n\n    for (let idx = 0; idx !== sizeValue; ++idx) {\n      const item = this.oneCommandArb.generate(mrng, undefined);\n      items[idx] = item;\n    }\n\n    this.replayPathPosition = 0;\n    return this.buildNextValueFor(items, false);\n  }\n\n  canShrinkWithoutContext(value) {\n    return false;\n  }\n\n  filterOnExecution(itemsRaw) {\n    const items = [];\n\n    for (const c of itemsRaw) {\n      if (c.value_.hasRan) {\n        this.replayPath.push(true);\n        items.push(c);\n      } else this.replayPath.push(false);\n    }\n\n    return items;\n  }\n\n  filterOnReplay(itemsRaw) {\n    return itemsRaw.filter((c, idx) => {\n      const state = this.replayPath[this.replayPathPosition + idx];\n      if (state === undefined) throw new Error(\"Too short replayPath\");\n      if (!state && c.value_.hasRan) throw new Error(\"Mismatch between replayPath and real execution\");\n      return state;\n    });\n  }\n\n  filterForShrinkImpl(itemsRaw) {\n    if (this.replayPathPosition === 0) {\n      this.replayPath = this.sourceReplayPath !== null ? ReplayPath.parse(this.sourceReplayPath) : [];\n    }\n\n    const items = this.replayPathPosition < this.replayPath.length ? this.filterOnReplay(itemsRaw) : this.filterOnExecution(itemsRaw);\n    this.replayPathPosition += itemsRaw.length;\n    return items;\n  }\n\n  shrink(_value, context) {\n    if (context === undefined) {\n      return Stream.nil();\n    }\n\n    const safeContext = context;\n    const shrunkOnce = safeContext.shrunkOnce;\n    const itemsRaw = safeContext.items;\n    const items = this.filterForShrinkImpl(itemsRaw);\n\n    if (items.length === 0) {\n      return Stream.nil();\n    }\n\n    const rootShrink = shrunkOnce ? Stream.nil() : new Stream([[]][Symbol.iterator]());\n    const nextShrinks = [];\n\n    for (let numToKeep = 0; numToKeep !== items.length; ++numToKeep) {\n      nextShrinks.push(makeLazy(() => {\n        const fixedStart = items.slice(0, numToKeep);\n        return this.lengthArb.shrink(items.length - 1 - numToKeep, undefined).map(l => fixedStart.concat(items.slice(items.length - (l.value + 1))));\n      }));\n    }\n\n    for (let itemAt = 0; itemAt !== items.length; ++itemAt) {\n      nextShrinks.push(makeLazy(() => this.oneCommandArb.shrink(items[itemAt].value_, items[itemAt].context).map(v => items.slice(0, itemAt).concat([v], items.slice(itemAt + 1)))));\n    }\n\n    return rootShrink.join(...nextShrinks).map(shrinkables => {\n      return this.buildNextValueFor(shrinkables.map(c => new NextValue(c.value_.clone(), c.context)), true);\n    });\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}