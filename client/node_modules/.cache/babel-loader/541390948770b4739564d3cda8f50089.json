{"ast":null,"code":"'use strict';\n\nconst bignumber = require('bignumber.js').BigNumber;\n\nconst utils = require('./utils');\n\nconst url = require('url');\n\nconst MINUS_ONE = new bignumber(-1);\nconst TWO = new bignumber(2);\n/**\n * A CBOR tagged item, where the tag does not have semantics specified at the\n * moment, or those semantics threw an error during parsing. Typically this will\n * be an extension point you're not yet expecting.\n */\n\nclass Tagged {\n  /**\n   * Creates an instance of Tagged.\n   *\n   * @param {number} tag - the number of the tag\n   * @param {any} value - the value inside the tag\n   * @param {Error} [err] - the error that was thrown parsing the tag, or null\n   */\n  constructor(tag, value, err) {\n    this.tag = tag;\n    this.value = value;\n    this.err = err;\n\n    if (typeof this.tag !== 'number') {\n      throw new Error('Invalid tag type (' + typeof this.tag + ')');\n    }\n\n    if (this.tag < 0 || (this.tag | 0) !== this.tag) {\n      throw new Error('Tag must be a positive integer: ' + this.tag);\n    }\n  }\n  /**\n   * Convert to a String\n   *\n   * @returns {string} string of the form '1(2)'\n   */\n\n\n  toString() {\n    return \"\".concat(this.tag, \"(\").concat(JSON.stringify(this.value), \")\");\n  }\n  /**\n   * Push the simple value onto the CBOR stream\n   *\n   * @param {Object} gen The generator to push onto\n   */\n\n\n  encodeCBOR(gen) {\n    gen._pushTag(this.tag);\n\n    return gen.pushAny(this.value);\n  }\n  /**\n   * If we have a converter for this type, do the conversion.  Some converters\n   * are built-in.  Additional ones can be passed in.  If you want to remove\n   * a built-in converter, pass a converter in whose value is 'null' instead\n   * of a function.\n   *\n   * @param {Object} converters - keys in the object are a tag number, the value\n   *   is a function that takes the decoded CBOR and returns a JavaScript value\n   *   of the appropriate type.  Throw an exception in the function on errors.\n   * @returns {any} - the converted item\n   */\n\n\n  convert(converters) {\n    let f = converters != null ? converters[this.tag] : void 0;\n\n    if (typeof f !== 'function') {\n      f = Tagged['_tag_' + this.tag];\n\n      if (typeof f !== 'function') {\n        return this;\n      }\n    }\n\n    try {\n      return f.call(Tagged, this.value);\n    } catch (error) {\n      this.err = error;\n      return this;\n    }\n  }\n\n  static _tag_0(v) {\n    return new Date(v);\n  }\n\n  static _tag_1(v) {\n    return new Date(v * 1000);\n  }\n\n  static _tag_2(v) {\n    return utils.bufferToBignumber(v);\n  }\n\n  static _tag_3(v) {\n    return MINUS_ONE.minus(utils.bufferToBignumber(v));\n  }\n\n  static _tag_4(v) {\n    return bignumber(v[1]).shiftedBy(v[0]);\n  }\n\n  static _tag_5(v) {\n    return TWO.pow(v[0]).times(v[1]);\n  }\n\n  static _tag_32(v) {\n    return url.parse(v);\n  }\n\n  static _tag_35(v) {\n    return new RegExp(v);\n  }\n\n}\n\nmodule.exports = Tagged;","map":null,"metadata":{},"sourceType":"script"}