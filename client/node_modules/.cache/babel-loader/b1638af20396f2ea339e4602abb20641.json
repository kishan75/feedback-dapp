{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectSources = void 0;\n\nconst path = __importStar(require(\"path\"));\n/**\n * Collects sources, targets into collections with OS-independent paths,\n * along with a reverse mapping to the original path (for post-processing)\n *\n * @param originalSources - { [originalSourcePath]: contents }\n * @param originalTargets - originalSourcePath[]\n * @param baseDirectory - a directory to remove as a prefix\n * @param replacement - what to replace it with\n * @return { sources, targets, originalSourcePaths }\n */\n\n\nfunction collectSources(originalSources, originalTargets = [], baseDirectory = \"\", replacement = \"/\") {\n  const mappedResults = Object.entries(originalSources).filter(([originalSourcePath, _]) => !path.isAbsolute(originalSourcePath) || originalSourcePath.startsWith(baseDirectory)).map(([originalSourcePath, contents]) => ({\n    originalSourcePath,\n    contents,\n    sourcePath: getPortableSourcePath(replaceRootDirectory(originalSourcePath, baseDirectory, replacement))\n  })).map(({\n    originalSourcePath,\n    sourcePath,\n    contents\n  }) => ({\n    sources: {\n      [sourcePath]: contents\n    },\n    // include transformed form as target if original is a target\n    targets: originalTargets.includes(originalSourcePath) ? [sourcePath] : [],\n    originalSourcePaths: {\n      [sourcePath]: originalSourcePath\n    }\n  }));\n  const defaultAccumulator = {\n    sources: {},\n    targets: [],\n    originalSourcePaths: {}\n  };\n  return mappedResults.reduce((accumulator, result) => ({\n    sources: Object.assign({}, accumulator.sources, result.sources),\n    targets: [...accumulator.targets, ...result.targets],\n    originalSourcePaths: Object.assign({}, accumulator.originalSourcePaths, result.originalSourcePaths)\n  }), defaultAccumulator);\n}\n\nexports.collectSources = collectSources;\n/**\n * @param sourcePath - string\n * @return string - operating system independent path\n * @private\n */\n\nfunction getPortableSourcePath(sourcePath) {\n  let replacement = sourcePath; //on Windows, replace backslashes with forward slashes\n\n  if (path.sep === '\\\\') {\n    replacement = sourcePath.replace(/\\\\/g, \"/\");\n  } // Turn G:/.../ into /G/.../ for Windows\n\n\n  if (replacement.length >= 2 && replacement[1] === \":\") {\n    replacement = \"/\" + replacement;\n    replacement = replacement.replace(\":\", \"\");\n  }\n\n  return replacement;\n}\n\nfunction replaceRootDirectory(sourcePath, rootDirectory, replacement) {\n  //make sure root directory ends in a separator\n  if (!rootDirectory.endsWith(path.sep)) {\n    rootDirectory = rootDirectory + path.sep;\n  }\n\n  return sourcePath.startsWith(rootDirectory) ? replacement + sourcePath.slice(rootDirectory.length) //remove prefix\n  : sourcePath;\n}","map":null,"metadata":{},"sourceType":"script"}