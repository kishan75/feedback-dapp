{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.forBytecode = exports.forContract = void 0;\n\nfunction forContract(contract) {\n  const contractName = contract.contractName,\n        sourcePath = contract.sourcePath,\n        source = contract.source,\n        sourceMap = contract.sourceMap,\n        deployedSourceMap = contract.deployedSourceMap,\n        legacyAST = contract.legacyAST,\n        ast = contract.ast,\n        abi = contract.abi,\n        metadata = contract.metadata,\n        bytecode = contract.bytecode,\n        deployedBytecode = contract.deployedBytecode,\n        compiler = contract.compiler,\n        devdoc = contract.devdoc,\n        userdoc = contract.userdoc,\n        immutableReferences = contract.immutableReferences,\n        generatedSources = contract.generatedSources,\n        deployedGeneratedSources = contract.deployedGeneratedSources,\n        db = contract.db;\n  return {\n    contract_name: contractName,\n    sourcePath,\n    source,\n    sourceMap,\n    deployedSourceMap,\n    legacyAST,\n    ast,\n    abi,\n    metadata,\n    bytecode: forBytecode(bytecode),\n    deployedBytecode: forBytecode(deployedBytecode),\n    unlinked_binary: forBytecode(bytecode),\n    compiler,\n    devdoc,\n    userdoc,\n    immutableReferences,\n    generatedSources,\n    deployedGeneratedSources,\n    db\n  };\n}\n\nexports.forContract = forContract;\n\nfunction forBytecode(bytecode) {\n  if (!bytecode) {\n    return bytecode;\n  }\n\n  if (typeof bytecode === \"string\") {\n    return bytecode;\n  }\n\n  let bytes = bytecode.bytes,\n      linkReferences = bytecode.linkReferences;\n  linkReferences = linkReferences || []; // inline link references - start by flattening the offsets\n\n  const flattenedLinkReferences = linkReferences // map each link ref to array of link refs with only one offset\n  .map(({\n    offsets,\n    length,\n    name\n  }) => offsets.map(offset => ({\n    offset,\n    length,\n    name\n  }))) // flatten\n  .reduce((a, b) => [...a, ...b], []); // then overwite bytes with link reference\n\n  bytes = flattenedLinkReferences.reduce((bytes, {\n    offset,\n    name,\n    length\n  }) => {\n    // length is a byte offset\n    const characterLength = length * 2;\n    let linkId = \"__\".concat(name.slice(0, characterLength - 2));\n\n    while (linkId.length < characterLength) {\n      linkId += \"_\";\n    }\n\n    const start = offset * 2;\n    return \"\".concat(bytes.substring(0, start)).concat(linkId).concat(bytes.substring(start + characterLength));\n  }, bytes);\n  return \"0x\".concat(bytes);\n}\n\nexports.forBytecode = forBytecode;","map":null,"metadata":{},"sourceType":"script"}