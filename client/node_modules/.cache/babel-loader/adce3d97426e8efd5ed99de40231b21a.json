{"ast":null,"code":"export const toStringMethod = Symbol('fast-check/toStringMethod');\nexport function hasToStringMethod(instance) {\n  return instance !== null && (typeof instance === 'object' || typeof instance === 'function') && toStringMethod in instance && typeof instance[toStringMethod] === 'function';\n}\nexport const asyncToStringMethod = Symbol('fast-check/asyncToStringMethod');\nexport function hasAsyncToStringMethod(instance) {\n  return instance !== null && (typeof instance === 'object' || typeof instance === 'function') && asyncToStringMethod in instance && typeof instance[asyncToStringMethod] === 'function';\n}\nconst findSymbolNameRegex = /^Symbol\\((.*)\\)$/;\n\nfunction getSymbolDescription(s) {\n  if (s.description !== undefined) return s.description;\n  const m = findSymbolNameRegex.exec(String(s));\n  return m && m[1].length ? m[1] : null;\n}\n\nfunction stringifyNumber(numValue) {\n  switch (numValue) {\n    case 0:\n      return 1 / numValue === Number.NEGATIVE_INFINITY ? '-0' : '0';\n\n    case Number.NEGATIVE_INFINITY:\n      return 'Number.NEGATIVE_INFINITY';\n\n    case Number.POSITIVE_INFINITY:\n      return 'Number.POSITIVE_INFINITY';\n\n    default:\n      return numValue === numValue ? String(numValue) : 'Number.NaN';\n  }\n}\n\nfunction isSparseArray(arr) {\n  let previousNumberedIndex = -1;\n\n  for (const index in arr) {\n    const numberedIndex = Number(index);\n    if (numberedIndex !== previousNumberedIndex + 1) return true;\n    previousNumberedIndex = numberedIndex;\n  }\n\n  return previousNumberedIndex + 1 !== arr.length;\n}\n\nexport function stringifyInternal(value, previousValues, getAsyncContent) {\n  const currentValues = previousValues.concat([value]);\n\n  if (typeof value === 'object') {\n    if (previousValues.indexOf(value) !== -1) {\n      return '[cyclic]';\n    }\n  }\n\n  if (hasAsyncToStringMethod(value)) {\n    const content = getAsyncContent(value);\n\n    if (content.state === 'fulfilled') {\n      return content.value;\n    }\n  }\n\n  if (hasToStringMethod(value)) {\n    try {\n      return value[toStringMethod]();\n    } catch (err) {}\n  }\n\n  switch (Object.prototype.toString.call(value)) {\n    case '[object Array]':\n      {\n        const arr = value;\n\n        if (arr.length >= 50 && isSparseArray(arr)) {\n          const assignments = [];\n\n          for (const index in arr) {\n            if (!Number.isNaN(Number(index))) assignments.push(\"\".concat(index, \":\").concat(stringifyInternal(arr[index], currentValues, getAsyncContent)));\n          }\n\n          return assignments.length !== 0 ? \"Object.assign(Array(\".concat(arr.length, \"),{\").concat(assignments.join(','), \"})\") : \"Array(\".concat(arr.length, \")\");\n        }\n\n        const stringifiedArray = arr.map(v => stringifyInternal(v, currentValues, getAsyncContent)).join(',');\n        return arr.length === 0 || arr.length - 1 in arr ? \"[\".concat(stringifiedArray, \"]\") : \"[\".concat(stringifiedArray, \",]\");\n      }\n\n    case '[object BigInt]':\n      return \"\".concat(value, \"n\");\n\n    case '[object Boolean]':\n      return typeof value === 'boolean' ? JSON.stringify(value) : \"new Boolean(\".concat(JSON.stringify(value), \")\");\n\n    case '[object Date]':\n      {\n        const d = value;\n        return Number.isNaN(d.getTime()) ? \"new Date(NaN)\" : \"new Date(\".concat(JSON.stringify(d.toISOString()), \")\");\n      }\n\n    case '[object Map]':\n      return \"new Map(\".concat(stringifyInternal(Array.from(value), currentValues, getAsyncContent), \")\");\n\n    case '[object Null]':\n      return \"null\";\n\n    case '[object Number]':\n      return typeof value === 'number' ? stringifyNumber(value) : \"new Number(\".concat(stringifyNumber(Number(value)), \")\");\n\n    case '[object Object]':\n      {\n        try {\n          const toStringAccessor = value.toString;\n\n          if (typeof toStringAccessor === 'function' && toStringAccessor !== Object.prototype.toString) {\n            return value.toString();\n          }\n        } catch (err) {\n          return '[object Object]';\n        }\n\n        const mapper = k => \"\".concat(k === '__proto__' ? '[\"__proto__\"]' : typeof k === 'symbol' ? \"[\".concat(stringifyInternal(k, currentValues, getAsyncContent), \"]\") : JSON.stringify(k), \":\").concat(stringifyInternal(value[k], currentValues, getAsyncContent));\n\n        const stringifiedProperties = [...Object.keys(value).map(mapper), ...Object.getOwnPropertySymbols(value).filter(s => {\n          const descriptor = Object.getOwnPropertyDescriptor(value, s);\n          return descriptor && descriptor.enumerable;\n        }).map(mapper)];\n        const rawRepr = '{' + stringifiedProperties.join(',') + '}';\n\n        if (Object.getPrototypeOf(value) === null) {\n          return rawRepr === '{}' ? 'Object.create(null)' : \"Object.assign(Object.create(null),\".concat(rawRepr, \")\");\n        }\n\n        return rawRepr;\n      }\n\n    case '[object Set]':\n      return \"new Set(\".concat(stringifyInternal(Array.from(value), currentValues, getAsyncContent), \")\");\n\n    case '[object String]':\n      return typeof value === 'string' ? JSON.stringify(value) : \"new String(\".concat(JSON.stringify(value), \")\");\n\n    case '[object Symbol]':\n      {\n        const s = value;\n\n        if (Symbol.keyFor(s) !== undefined) {\n          return \"Symbol.for(\".concat(JSON.stringify(Symbol.keyFor(s)), \")\");\n        }\n\n        const desc = getSymbolDescription(s);\n\n        if (desc === null) {\n          return 'Symbol()';\n        }\n\n        const knownSymbol = desc.startsWith('Symbol.') && Symbol[desc.substring(7)];\n        return s === knownSymbol ? desc : \"Symbol(\".concat(JSON.stringify(desc), \")\");\n      }\n\n    case '[object Promise]':\n      {\n        const promiseContent = getAsyncContent(value);\n\n        switch (promiseContent.state) {\n          case 'fulfilled':\n            return \"Promise.resolve(\".concat(stringifyInternal(promiseContent.value, currentValues, getAsyncContent), \")\");\n\n          case 'rejected':\n            return \"Promise.reject(\".concat(stringifyInternal(promiseContent.value, currentValues, getAsyncContent), \")\");\n\n          case 'pending':\n            return \"new Promise(() => {/*pending*/})\";\n\n          case 'unknown':\n          default:\n            return \"new Promise(() => {/*unknown*/})\";\n        }\n      }\n\n    case '[object Error]':\n      if (value instanceof Error) {\n        return \"new Error(\".concat(stringifyInternal(value.message, currentValues, getAsyncContent), \")\");\n      }\n\n      break;\n\n    case '[object Undefined]':\n      return \"undefined\";\n\n    case '[object Int8Array]':\n    case '[object Uint8Array]':\n    case '[object Uint8ClampedArray]':\n    case '[object Int16Array]':\n    case '[object Uint16Array]':\n    case '[object Int32Array]':\n    case '[object Uint32Array]':\n    case '[object Float32Array]':\n    case '[object Float64Array]':\n    case '[object BigInt64Array]':\n    case '[object BigUint64Array]':\n      {\n        if (typeof Buffer !== 'undefined' && typeof Buffer.isBuffer === 'function' && Buffer.isBuffer(value)) {\n          return \"Buffer.from(\".concat(stringifyInternal(Array.from(value.values()), currentValues, getAsyncContent), \")\");\n        }\n\n        const valuePrototype = Object.getPrototypeOf(value);\n        const className = valuePrototype && valuePrototype.constructor && valuePrototype.constructor.name;\n\n        if (typeof className === 'string') {\n          const typedArray = value;\n          const valuesFromTypedArr = typedArray.values();\n          return \"\".concat(className, \".from(\").concat(stringifyInternal(Array.from(valuesFromTypedArr), currentValues, getAsyncContent), \")\");\n        }\n\n        break;\n      }\n  }\n\n  try {\n    return value.toString();\n  } catch (_a) {\n    return Object.prototype.toString.call(value);\n  }\n}\nexport function stringify(value) {\n  return stringifyInternal(value, [], () => ({\n    state: 'unknown',\n    value: undefined\n  }));\n}\nexport function possiblyAsyncStringify(value) {\n  const stillPendingMarker = Symbol();\n  const pendingPromisesForCache = [];\n  const cache = new Map();\n\n  function createDelay0() {\n    let handleId = null;\n\n    const cancel = () => {\n      if (handleId !== null) {\n        clearTimeout(handleId);\n      }\n    };\n\n    const delay = new Promise(resolve => {\n      handleId = setTimeout(() => {\n        handleId = null;\n        resolve(stillPendingMarker);\n      }, 0);\n    });\n    return {\n      delay,\n      cancel\n    };\n  }\n\n  const unknownState = {\n    state: 'unknown',\n    value: undefined\n  };\n\n  const getAsyncContent = function getAsyncContent(data) {\n    const cacheKey = data;\n\n    if (cache.has(cacheKey)) {\n      return cache.get(cacheKey);\n    }\n\n    const delay0 = createDelay0();\n    const p = asyncToStringMethod in data ? Promise.resolve().then(() => data[asyncToStringMethod]()) : data;\n    p.catch(() => {});\n    pendingPromisesForCache.push(Promise.race([p, delay0.delay]).then(successValue => {\n      if (successValue === stillPendingMarker) cache.set(cacheKey, {\n        state: 'pending',\n        value: undefined\n      });else cache.set(cacheKey, {\n        state: 'fulfilled',\n        value: successValue\n      });\n      delay0.cancel();\n    }, errorValue => {\n      cache.set(cacheKey, {\n        state: 'rejected',\n        value: errorValue\n      });\n      delay0.cancel();\n    }));\n    cache.set(cacheKey, unknownState);\n    return unknownState;\n  };\n\n  function loop() {\n    const stringifiedValue = stringifyInternal(value, [], getAsyncContent);\n\n    if (pendingPromisesForCache.length === 0) {\n      return stringifiedValue;\n    }\n\n    return Promise.all(pendingPromisesForCache.splice(0)).then(loop);\n  }\n\n  return loop();\n}\nexport async function asyncStringify(value) {\n  return Promise.resolve(possiblyAsyncStringify(value));\n}","map":null,"metadata":{},"sourceType":"module"}