{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeLiteral = exports.decodeStack = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:stack:decode\");\n\nconst AbiData = __importStar(require(\"../../abi-data\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Memory = __importStar(require(\"../../memory\"));\n\nconst Storage = __importStar(require(\"../../storage\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeStack(dataType, pointer, info) {\n  let rawValue;\n\n  try {\n    rawValue = yield* read_1.default(pointer, info.state);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error);\n  }\n\n  const literalPointer = {\n    location: \"stackliteral\",\n    literal: rawValue\n  };\n  return yield* decodeLiteral(dataType, literalPointer, info);\n}\n\nexports.decodeStack = decodeStack;\n\nfunction* decodeLiteral(dataType, pointer, info) {\n  debug(\"type %O\", dataType);\n  debug(\"pointer %o\", pointer);\n\n  if (Format.Types.isReferenceType(dataType)) {\n    switch (dataType.location) {\n      case \"memory\":\n        //first: do we have a memory pointer? if so we can just dispatch to\n        //decodeMemoryReference\n        return yield* Memory.Decode.decodeMemoryReferenceByAddress(dataType, pointer, info);\n\n      case \"storage\":\n        //next: do we have a storage pointer (which may be a mapping)? if so, we can\n        //we dispatch to decodeStorageByAddress\n        return yield* Storage.Decode.decodeStorageReferenceByAddress(dataType, pointer, info);\n\n      case \"calldata\":\n        //next: do we have a calldata pointer?\n        //if it's a lookup type, it'll need special handling\n        if (dataType.typeClass === \"bytes\" || dataType.typeClass === \"string\" || dataType.typeClass === \"array\" && dataType.kind === \"dynamic\") {\n          const lengthAsBN = Conversion.toBN(pointer.literal.slice(Evm.Utils.WORD_SIZE));\n          const locationOnly = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n          return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, {\n            location: \"stackliteral\",\n            literal: locationOnly\n          }, info, {\n            abiPointerBase: 0,\n            lengthOverride: lengthAsBN\n          });\n        } else {\n          //multivalue case -- this case is straightforward\n          return yield* AbiData.Decode.decodeAbiReferenceByAddress(dataType, pointer, info, {\n            abiPointerBase: 0 //let's be explicit\n\n          });\n        }\n\n    }\n  } //next: do we have an external function?  these work differently on the stack\n  //than elsewhere, so we can't just pass it on to decodeBasic.\n\n\n  if (dataType.typeClass === \"function\" && dataType.visibility === \"external\") {\n    let address = pointer.literal.slice(0, Evm.Utils.WORD_SIZE);\n    let selectorWord = pointer.literal.slice(-Evm.Utils.WORD_SIZE);\n\n    if (!Basic.Decode.checkPaddingLeft(address, Evm.Utils.ADDRESS_SIZE) || !Basic.Decode.checkPaddingLeft(selectorWord, Evm.Utils.SELECTOR_SIZE)) {\n      return {\n        type: dataType,\n        kind: \"error\",\n        error: {\n          kind: \"FunctionExternalStackPaddingError\",\n          rawAddress: Conversion.toHexString(address),\n          rawSelector: Conversion.toHexString(selectorWord)\n        }\n      };\n    }\n\n    let selector = selectorWord.slice(-Evm.Utils.SELECTOR_SIZE);\n    return {\n      type: dataType,\n      kind: \"value\",\n      value: yield* Basic.Decode.decodeExternalFunction(address, selector, info)\n    };\n  } //finally, if none of the above hold, we can just dispatch to decodeBasic.\n  //however, note that because we're on the stack, we use the permissive padding\n  //option so that errors won't result due to values with bad padding\n  //(of numeric or bytesN type, anyway)\n\n\n  return yield* Basic.Decode.decodeBasic(dataType, pointer, info, {\n    paddingMode: \"permissive\"\n  });\n}\n\nexports.decodeLiteral = decodeLiteral;","map":null,"metadata":{},"sourceType":"script"}