{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeAbiReferenceStatic = exports.decodeAbiReferenceByAddress = exports.decodeAbi = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst allocate_1 = require(\"../allocate\");\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeAbi(dataType, pointer, info, options = {}) {\n  if (Format.Types.isReferenceType(dataType) || dataType.typeClass === \"tuple\") {\n    //I don't want tuples to be considered a reference type, but it makes sense\n    //to group them for this purpose\n    let dynamic;\n\n    try {\n      dynamic = allocate_1.abiSizeInfo(dataType, info.allocations.abi).dynamic;\n    } catch (error) {\n      return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);\n    }\n\n    if (dynamic) {\n      return yield* decodeAbiReferenceByAddress(dataType, pointer, info, options);\n    } else {\n      return yield* decodeAbiReferenceStatic(dataType, pointer, info, options);\n    }\n  } else {\n    debug(\"pointer %o\", pointer);\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info, options);\n  }\n}\n\nexports.decodeAbi = decodeAbi;\n\nfunction* decodeAbiReferenceByAddress(dataType, pointer, info, options = {}) {\n  let strict = options.strictAbiMode,\n      base = options.abiPointerBase,\n      lengthOverride = options.lengthOverride;\n  base = base || 0; //in case base was undefined\n\n  const allocations = info.allocations.abi,\n        state = info.state;\n  debug(\"pointer %o\", pointer); //this variable holds the location we should look to *next*\n  //stack pointers point to calldata; other pointers point to same location\n\n  const location = pointer.location === \"stack\" || pointer.location === \"stackliteral\" ? \"calldata\" : pointer.location;\n\n  if (pointer.location !== \"stack\" && pointer.location !== \"stackliteral\") {\n    //length overrides are only applicable when you're decoding a pointer\n    //from the stack!  otherwise they must be ignored!\n    lengthOverride = undefined;\n  }\n\n  let rawValue;\n\n  try {\n    rawValue = yield* read_1.default(pointer, state);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error, strict);\n  }\n\n  let rawValueAsBN = Conversion.toBN(rawValue);\n  debug(\"rawValue: %O\", rawValue);\n  debug(\"rawValueAsBN: %O\", rawValueAsBN);\n  let rawValueAsNumber;\n\n  try {\n    rawValueAsNumber = rawValueAsBN.toNumber();\n  } catch (_a) {\n    let error = {\n      kind: \"OverlargePointersNotImplementedError\",\n      pointerAsBN: rawValueAsBN\n    };\n\n    if (strict) {\n      throw new errors_1.StopDecodingError(error);\n    }\n\n    return {\n      //again with the TS failures...\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n\n  let startPosition = rawValueAsNumber + base;\n  debug(\"startPosition %d\", startPosition);\n  let dynamic;\n  let size;\n\n  try {\n    var _allocate_1$abiSizeIn = allocate_1.abiSizeInfo(dataType, allocations);\n\n    dynamic = _allocate_1$abiSizeIn.dynamic;\n    size = _allocate_1$abiSizeIn.size;\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error, strict);\n  }\n\n  if (!dynamic) {\n    //this will only come up when called from stack.ts\n    let staticPointer = {\n      location,\n      start: startPosition,\n      length: size\n    };\n    return yield* decodeAbiReferenceStatic(dataType, staticPointer, info, options);\n  }\n\n  let length;\n  let lengthAsBN;\n  let rawLength;\n\n  switch (dataType.typeClass) {\n    case \"bytes\":\n    case \"string\":\n      //initial word contains length (unless an override was given)\n      if (lengthOverride !== undefined) {\n        lengthAsBN = lengthOverride; //note in this case we do *not* increment start position;\n        //if a length override is given, that means the given start\n        //position skips over the length word!\n      } else {\n        try {\n          rawLength = yield* read_1.default({\n            location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error, strict);\n        }\n\n        lengthAsBN = Conversion.toBN(rawLength);\n        startPosition += Evm.Utils.WORD_SIZE; //increment start position after reading length\n        //so it'll be set up to read the data\n      }\n\n      if (strict && lengthAsBN.gtn(state[location].length)) {\n        //you may notice that the comparison is a bit crude; that's OK, this is\n        //just to prevent huge numbers from DOSing us, other errors will still\n        //be caught regardless\n        throw new errors_1.StopDecodingError({\n          kind: \"OverlongArrayOrStringStrictModeError\",\n          lengthAsBN,\n          dataLength: state[location].length\n        });\n      }\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_b) {\n        //note: if we're in this situation, we can assume we're not in strict mode,\n        //as the strict case was handled above\n        return {\n          //again with the TS failures...\n          type: dataType,\n          kind: \"error\",\n          error: {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          }\n        };\n      }\n\n      let childPointer = {\n        location,\n        start: startPosition,\n        length\n      };\n      return yield* Bytes.Decode.decodeBytes(dataType, childPointer, info, options);\n\n    case \"array\":\n      if (dataType.kind === \"static\") {\n        //static-length array\n        lengthAsBN = dataType.length; //note we don't increment start position; static arrays don't\n        //include a length word!\n      } else if (lengthOverride !== undefined) {\n        debug(\"override: %o\", lengthOverride); //dynamic-length array, but with length override\n\n        lengthAsBN = lengthOverride; //we don't increment start position; if a length override was\n        //given, that means the pointer skipped the length word!\n      } else {\n        //dynamic-length array, read length from data\n        //initial word contains array length\n        try {\n          rawLength = yield* read_1.default({\n            location,\n            start: startPosition,\n            length: Evm.Utils.WORD_SIZE\n          }, state);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error, strict);\n        }\n\n        lengthAsBN = Conversion.toBN(rawLength);\n        startPosition += Evm.Utils.WORD_SIZE; //increment startPosition\n        //to next word, as first word was used for length\n      }\n\n      if (strict && lengthAsBN.gtn(state[location].length)) {\n        //you may notice that the comparison is a bit crude; that's OK, this is\n        //just to prevent huge numbers from DOSing us, other errors will still\n        //be caught regardless\n        throw new errors_1.StopDecodingError({\n          kind: \"OverlongArraysAndStringsNotImplementedError\",\n          lengthAsBN,\n          dataLength: state[location].length\n        });\n      }\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_c) {\n        //again, if we get here, we can assume we're not in strict mode\n        return {\n          type: dataType,\n          kind: \"error\",\n          error: {\n            kind: \"OverlongArraysAndStringsNotImplementedError\",\n            lengthAsBN\n          }\n        };\n      } //note: I've written this fairly generically, but it is worth noting that\n      //since this array is of dynamic type, we know that if it's static length\n      //then size must be EVM.WORD_SIZE\n\n\n      let baseSize;\n\n      try {\n        baseSize = allocate_1.abiSizeInfo(dataType.baseType, allocations).size;\n      } catch (error) {\n        return errors_1.handleDecodingError(dataType, error, strict);\n      }\n\n      let decodedChildren = [];\n\n      for (let index = 0; index < length; index++) {\n        decodedChildren.push((yield* decodeAbi(dataType.baseType, {\n          location,\n          start: startPosition + index * baseSize,\n          length: baseSize\n        }, info, Object.assign(Object.assign({}, options), {\n          abiPointerBase: startPosition\n        })))); //pointer base is always start of list, never the length\n      }\n\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedChildren\n      };\n\n    case \"struct\":\n      return yield* decodeAbiStructByPosition(dataType, location, startPosition, info, options);\n\n    case \"tuple\":\n      return yield* decodeAbiTupleByPosition(dataType, location, startPosition, info, options);\n  }\n}\n\nexports.decodeAbiReferenceByAddress = decodeAbiReferenceByAddress;\n\nfunction* decodeAbiReferenceStatic(dataType, pointer, info, options = {}) {\n  debug(\"static\");\n  debug(\"pointer %o\", pointer);\n  const location = pointer.location;\n\n  switch (dataType.typeClass) {\n    case \"array\":\n      //we're in the static case, so we know the array must be statically sized\n      const lengthAsBN = dataType.length;\n      let length;\n\n      try {\n        length = lengthAsBN.toNumber();\n      } catch (_a) {\n        //note: since this is the static case, we don't bother including the stronger\n        //strict-mode guard against getting DOSed by large array sizes, since in this\n        //case we're not reading the size from the input; if there's a huge static size\n        //array, well, we'll just have to deal with it\n        let error = {\n          kind: \"OverlongArraysAndStringsNotImplementedError\",\n          lengthAsBN\n        };\n\n        if (options.strictAbiMode) {\n          throw new errors_1.StopDecodingError(error);\n        }\n\n        return {\n          type: dataType,\n          kind: \"error\",\n          error\n        };\n      }\n\n      let baseSize;\n\n      try {\n        baseSize = allocate_1.abiSizeInfo(dataType.baseType, info.allocations.abi).size;\n      } catch (error) {\n        return errors_1.handleDecodingError(dataType, error, options.strictAbiMode);\n      }\n\n      let decodedChildren = [];\n\n      for (let index = 0; index < length; index++) {\n        decodedChildren.push((yield* decodeAbi(dataType.baseType, {\n          location,\n          start: pointer.start + index * baseSize,\n          length: baseSize\n        }, info, options)));\n      }\n\n      return {\n        type: dataType,\n        kind: \"value\",\n        value: decodedChildren\n      };\n\n    case \"struct\":\n      return yield* decodeAbiStructByPosition(dataType, location, pointer.start, info, options);\n\n    case \"tuple\":\n      return yield* decodeAbiTupleByPosition(dataType, location, pointer.start, info, options);\n  }\n}\n\nexports.decodeAbiReferenceStatic = decodeAbiReferenceStatic; //note that this function takes the start position as a *number*; it does not take a pointer\n\nfunction* decodeAbiStructByPosition(dataType, location, startPosition, info, options = {}) {\n  const allocations = info.allocations.abi;\n  const typeLocation = location === \"calldata\" ? \"calldata\" : null; //other abi locations are not valid type locations\n\n  const typeId = dataType.id;\n  const structAllocation = allocations[typeId];\n\n  if (!structAllocation) {\n    let error = {\n      kind: \"UserDefinedTypeNotFoundError\",\n      type: dataType\n    };\n\n    if (options.strictAbiMode || options.allowRetry) {\n      throw new errors_1.StopDecodingError(error, true); //note that we allow a retry if we couldn't locate the allocation!\n    }\n\n    return {\n      type: dataType,\n      kind: \"error\",\n      error\n    };\n  }\n\n  let decodedMembers = [];\n\n  for (let index = 0; index < structAllocation.members.length; index++) {\n    const memberAllocation = structAllocation.members[index];\n    const memberPointer = memberAllocation.pointer;\n    const childPointer = {\n      location,\n      start: startPosition + memberPointer.start,\n      length: memberPointer.length\n    };\n    let memberName = memberAllocation.name;\n    let memberType = Format.Types.specifyLocation(memberAllocation.type, typeLocation);\n    decodedMembers.push({\n      name: memberName,\n      value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n        abiPointerBase: startPosition\n      })) //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n\n    });\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: decodedMembers\n  };\n} //note that this function takes the start position as a *number*; it does not take a pointer\n\n\nfunction* decodeAbiTupleByPosition(dataType, location, startPosition, info, options = {}) {\n  //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n  //I'm writing it this way anyway for simplicity, to avoid rewriting the decoder\n  //However it may be worth revisiting this in the future if performance turns out to be a problem\n  //(changing this may be pretty hard though)\n  let decodedMembers = [];\n  let position = startPosition;\n\n  for (const _ref of dataType.memberTypes) {\n    const name = _ref.name;\n    const memberType = _ref.type;\n    const memberSize = allocate_1.abiSizeInfo(memberType, info.allocations.abi).size;\n    const childPointer = {\n      location,\n      start: position,\n      length: memberSize\n    };\n    decodedMembers.push({\n      name,\n      value: yield* decodeAbi(memberType, childPointer, info, Object.assign(Object.assign({}, options), {\n        abiPointerBase: startPosition\n      })) //note that the base option is only needed in the dynamic case, but we're being indiscriminate\n\n    });\n    position += memberSize;\n  }\n\n  return {\n    type: dataType,\n    kind: \"value\",\n    value: decodedMembers\n  };\n}","map":null,"metadata":{},"sourceType":"script"}