{"ast":null,"code":"import _slicedToArray from \"F:\\\\BlockChain\\\\Projects\\\\feedback-dapp-full\\\\feedback-dapp\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { useForkRef } from '@mui/material/utils';\nimport { useGridApiContext } from '../../utils/useGridApiContext';\nimport { useGridSelector } from '../../utils/useGridSelector';\nimport { gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector } from '../columns/gridColumnsSelector';\nimport { gridTabIndexColumnHeaderSelector, gridTabIndexCellSelector, gridFocusColumnHeaderSelector } from '../focus/gridFocusStateSelector';\nimport { gridDensityHeaderHeightSelector } from '../density/densitySelector';\nimport { gridFilterActiveItemsLookupSelector } from '../filter/gridFilterSelector';\nimport { gridSortColumnLookupSelector } from '../sorting/gridSortingSelector';\nimport { gridColumnMenuSelector } from '../columnMenu/columnMenuSelector';\nimport { useGridRootProps } from '../../utils/useGridRootProps';\nimport { useGridApiEventHandler } from '../../utils/useGridApiEventHandler';\nimport { GridEvents } from '../../../models/events';\nimport { GridColumnHeaderItem } from '../../../components/columnHeaders/GridColumnHeaderItem';\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport const useGridColumnHeaders = props => {\n  const innerRefProp = props.innerRef,\n        _props$minColumnIndex = props.minColumnIndex,\n        minColumnIndex = _props$minColumnIndex === void 0 ? 0 : _props$minColumnIndex;\n\n  const _React$useState = React.useState(''),\n        _React$useState2 = _slicedToArray(_React$useState, 2),\n        dragCol = _React$useState2[0],\n        setDragCol = _React$useState2[1];\n\n  const _React$useState3 = React.useState(''),\n        _React$useState4 = _slicedToArray(_React$useState3, 2),\n        resizeCol = _React$useState4[0],\n        setResizeCol = _React$useState4[1];\n\n  const apiRef = useGridApiContext();\n  const visibleColumns = useGridSelector(apiRef, gridVisibleColumnDefinitionsSelector);\n  const columnPositions = useGridSelector(apiRef, gridColumnPositionsSelector);\n  const tabIndexState = useGridSelector(apiRef, gridTabIndexColumnHeaderSelector);\n  const cellTabIndexState = useGridSelector(apiRef, gridTabIndexCellSelector);\n  const columnHeaderFocus = useGridSelector(apiRef, gridFocusColumnHeaderSelector);\n  const headerHeight = useGridSelector(apiRef, gridDensityHeaderHeightSelector);\n  const filterColumnLookup = useGridSelector(apiRef, gridFilterActiveItemsLookupSelector);\n  const sortColumnLookup = useGridSelector(apiRef, gridSortColumnLookupSelector);\n  const columnMenuState = useGridSelector(apiRef, gridColumnMenuSelector);\n  const rootProps = useGridRootProps();\n  const innerRef = React.useRef(null);\n  const handleInnerRef = useForkRef(innerRefProp, innerRef);\n\n  const _React$useState5 = React.useState(null),\n        _React$useState6 = _slicedToArray(_React$useState5, 2),\n        renderContext = _React$useState6[0],\n        setRenderContext = _React$useState6[1];\n\n  const prevRenderContext = React.useRef(renderContext);\n  const prevScrollLeft = React.useRef(0);\n  React.useEffect(() => {\n    apiRef.current.columnHeadersContainerElementRef.current.scrollLeft = 0;\n  }, [apiRef]);\n  const updateInnerPosition = React.useCallback(nextRenderContext => {\n    const firstColumnToRender = Math.max(nextRenderContext.firstColumnIndex - rootProps.columnBuffer, minColumnIndex);\n    const offset = firstColumnToRender > 0 ? prevScrollLeft.current - columnPositions[firstColumnToRender] : prevScrollLeft.current;\n    innerRef.current.style.transform = \"translate3d(\".concat(-offset, \"px, 0px, 0px)\");\n  }, [columnPositions, minColumnIndex, rootProps.columnBuffer]);\n  const handleScroll = React.useCallback(({\n    left,\n    renderContext: nextRenderContext = null\n  }) => {\n    var _prevRenderContext$cu, _prevRenderContext$cu2;\n\n    if (!innerRef.current) {\n      return;\n    } // Ignore vertical scroll.\n    // Excepts the first event which sets the previous render context.\n\n\n    if (prevScrollLeft.current === left && ((_prevRenderContext$cu = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu.firstColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.firstColumnIndex) && ((_prevRenderContext$cu2 = prevRenderContext.current) == null ? void 0 : _prevRenderContext$cu2.lastColumnIndex) === (nextRenderContext == null ? void 0 : nextRenderContext.lastColumnIndex)) {\n      return;\n    }\n\n    prevScrollLeft.current = left;\n\n    if (nextRenderContext !== prevRenderContext.current || !prevRenderContext.current) {\n      setRenderContext(nextRenderContext);\n      prevRenderContext.current = nextRenderContext;\n    } // Pass directly the render context to avoid waiting for the next render\n\n\n    if (nextRenderContext) {\n      updateInnerPosition(nextRenderContext);\n    }\n  }, [updateInnerPosition]);\n  const handleColumnResizeStart = React.useCallback(params => setResizeCol(params.field), []);\n  const handleColumnResizeStop = React.useCallback(() => setResizeCol(''), []);\n  const handleColumnReorderStart = React.useCallback(params => setDragCol(params.field), []);\n  const handleColumnReorderStop = React.useCallback(() => setDragCol(''), []);\n  useGridApiEventHandler(apiRef, GridEvents.columnResizeStart, handleColumnResizeStart);\n  useGridApiEventHandler(apiRef, GridEvents.columnResizeStop, handleColumnResizeStop);\n  useGridApiEventHandler(apiRef, GridEvents.columnHeaderDragStart, handleColumnReorderStart);\n  useGridApiEventHandler(apiRef, GridEvents.columnHeaderDragEnd, handleColumnReorderStop);\n  useGridApiEventHandler(apiRef, GridEvents.rowsScroll, handleScroll);\n\n  const getColumns = (params, other = {}) => {\n    const _ref = params || {},\n          _ref$renderContext = _ref.renderContext,\n          nextRenderContext = _ref$renderContext === void 0 ? renderContext : _ref$renderContext,\n          _ref$minFirstColumn = _ref.minFirstColumn,\n          minFirstColumn = _ref$minFirstColumn === void 0 ? minColumnIndex : _ref$minFirstColumn,\n          _ref$maxLastColumn = _ref.maxLastColumn,\n          maxLastColumn = _ref$maxLastColumn === void 0 ? visibleColumns.length : _ref$maxLastColumn;\n\n    if (!nextRenderContext) {\n      return null;\n    }\n\n    const columns = [];\n    const firstColumnToRender = Math.max(nextRenderContext.firstColumnIndex - rootProps.columnBuffer, minFirstColumn);\n    const lastColumnToRender = Math.min(nextRenderContext.lastColumnIndex + rootProps.columnBuffer, maxLastColumn);\n    const renderedColumns = visibleColumns.slice(firstColumnToRender, lastColumnToRender);\n\n    for (let i = 0; i < renderedColumns.length; i += 1) {\n      const column = renderedColumns[i];\n      const columnIndex = firstColumnToRender + i;\n      const isFirstColumn = columnIndex === 0;\n      const hasTabbableElement = !(tabIndexState === null && cellTabIndexState === null);\n      const tabIndex = tabIndexState !== null && tabIndexState.field === column.field || isFirstColumn && !hasTabbableElement ? 0 : -1;\n      const hasFocus = columnHeaderFocus !== null && columnHeaderFocus.field === column.field;\n      const open = columnMenuState.open && columnMenuState.field === column.field;\n      columns.push(\n      /*#__PURE__*/\n      _jsx(GridColumnHeaderItem, _extends({}, sortColumnLookup[column.field], {\n        columnMenuOpen: open,\n        filterItemsCounter: filterColumnLookup[column.field] && filterColumnLookup[column.field].length,\n        headerHeight: headerHeight,\n        isDragging: column.field === dragCol,\n        column: column,\n        colIndex: columnIndex,\n        isResizing: resizeCol === column.field,\n        isLastColumn: columnIndex === columns.length - 1,\n        extendRowFullWidth: !rootProps.disableExtendRowFullWidth,\n        hasFocus: hasFocus,\n        tabIndex: tabIndex\n      }, other), i));\n    }\n\n    return columns;\n  };\n\n  const rootStyle = {\n    minHeight: headerHeight,\n    maxHeight: headerHeight,\n    lineHeight: \"\".concat(headerHeight, \"px\")\n  };\n  return {\n    renderContext,\n    getColumns,\n    isDragging: !!dragCol,\n    updateInnerPosition,\n    getRootProps: (other = {}) => _extends({\n      style: rootStyle\n    }, other),\n    getInnerProps: () => ({\n      ref: handleInnerRef,\n      'aria-rowindex': 1,\n      role: 'row'\n    })\n  };\n};","map":null,"metadata":{},"sourceType":"module"}