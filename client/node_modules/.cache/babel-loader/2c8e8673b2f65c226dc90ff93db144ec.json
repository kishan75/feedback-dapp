{"ast":null,"code":"export function keyValuePairsToObjectMapper(items) {\n  const obj = {};\n\n  for (const keyValue of items) {\n    obj[keyValue[0]] = keyValue[1];\n  }\n\n  return obj;\n}\n\nfunction buildInvalidPropertyNameFilter(obj) {\n  return function invalidPropertyNameFilter(key) {\n    const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n    return descriptor === undefined || !descriptor.configurable || !descriptor.enumerable || !descriptor.writable || descriptor.get !== undefined || descriptor.set !== undefined;\n  };\n}\n\nexport function keyValuePairsToObjectUnmapper(value) {\n  if (typeof value !== 'object' || value === null) {\n    throw new Error('Incompatible instance received: should be a non-null object');\n  }\n\n  if (!('constructor' in value) || value.constructor !== Object) {\n    throw new Error('Incompatible instance received: should be of exact type Object');\n  }\n\n  if (Object.getOwnPropertySymbols(value).length > 0) {\n    throw new Error('Incompatible instance received: should contain symbols');\n  }\n\n  if (Object.getOwnPropertyNames(value).find(buildInvalidPropertyNameFilter(value)) !== undefined) {\n    throw new Error('Incompatible instance received: should contain only c/e/w properties without get/set');\n  }\n\n  return Object.entries(value);\n}","map":null,"metadata":{},"sourceType":"module"}