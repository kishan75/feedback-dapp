{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeStorageReference = exports.decodeStorageReferenceByAddress = exports.decodeStorage = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:storage:decode\");\n\nconst read_1 = __importDefault(require(\"../../read\"));\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst Utils = __importStar(require(\"../utils\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst allocate_1 = require(\"../allocate\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* decodeStorage(dataType, pointer, info) {\n  if (Format.Types.isReferenceType(dataType)) {\n    return yield* decodeStorageReference(dataType, pointer, info);\n  } else {\n    return yield* Basic.Decode.decodeBasic(dataType, pointer, info);\n  }\n}\n\nexports.decodeStorage = decodeStorage; //decodes storage at the address *read* from the pointer -- hence why this takes DataPointer rather than StoragePointer.\n//NOTE: ONLY for use with pointers to reference types!\n//Of course, pointers to value types don't exist in Solidity, so that warning is redundant, but...\n\nfunction* decodeStorageReferenceByAddress(dataType, pointer, info) {\n  const allocations = info.allocations.storage;\n  let rawValue;\n\n  try {\n    rawValue = yield* read_1.default(pointer, info.state);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error);\n  }\n\n  const startOffset = Conversion.toBN(rawValue);\n  let rawSize;\n\n  try {\n    rawSize = allocate_1.storageSize(dataType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n  } catch (error) {\n    return errors_1.handleDecodingError(dataType, error);\n  } //we *know* the type being decoded must be sized in words, because it's a\n  //reference type, but TypeScript doesn't, so we'll have to use a type\n  //coercion\n\n\n  const size = rawSize.words; //now, construct the storage pointer\n\n  const newPointer = {\n    location: \"storage\",\n    range: {\n      from: {\n        slot: {\n          offset: startOffset\n        },\n        index: 0\n      },\n      to: {\n        slot: {\n          offset: startOffset.addn(size - 1)\n        },\n        index: Evm.Utils.WORD_SIZE - 1\n      }\n    }\n  }; //dispatch to decodeStorageReference\n\n  return yield* decodeStorageReference(dataType, newPointer, info);\n}\n\nexports.decodeStorageReferenceByAddress = decodeStorageReferenceByAddress;\n\nfunction* decodeStorageReference(dataType, pointer, info) {\n  var data;\n  var length;\n  const state = info.state;\n  const allocations = info.allocations.storage;\n\n  switch (dataType.typeClass) {\n    case \"array\":\n      {\n        debug(\"storage array! %o\", pointer);\n        let lengthAsBN;\n\n        switch (dataType.kind) {\n          case \"dynamic\":\n            debug(\"dynamic array\");\n            debug(\"type %O\", dataType);\n\n            try {\n              data = yield* read_1.default(pointer, state);\n            } catch (error) {\n              return errors_1.handleDecodingError(dataType, error);\n            }\n\n            lengthAsBN = Conversion.toBN(data);\n            break;\n\n          case \"static\":\n            debug(\"static array\");\n            lengthAsBN = dataType.length;\n            break;\n        }\n\n        try {\n          length = lengthAsBN.toNumber();\n        } catch (_a) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"OverlongArraysAndStringsNotImplementedError\",\n              lengthAsBN\n            }\n          };\n        }\n\n        debug(\"length %o\", length);\n        debug(\"about to determine baseSize\");\n        let baseSize;\n\n        try {\n          baseSize = allocate_1.storageSize(dataType.baseType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error);\n        }\n\n        debug(\"baseSize %o\", baseSize); //we are going to make a list of child ranges, pushing them one by one onto\n        //this list, and then decode them; the first part will vary based on whether\n        //we're in the words case or the bytes case, the second will not\n\n        let ranges = [];\n\n        if (Utils.isWordsLength(baseSize)) {\n          //currentSlot will point to the start of the entry being decoded\n          let currentSlot = {\n            path: pointer.range.from.slot,\n            offset: new bn_js_1.default(0),\n            hashPath: dataType.kind === \"dynamic\"\n          };\n\n          for (let i = 0; i < length; i++) {\n            let childRange = {\n              from: {\n                slot: {\n                  path: currentSlot.path,\n                  offset: currentSlot.offset.clone(),\n                  hashPath: currentSlot.hashPath\n                },\n                index: 0\n              },\n              to: {\n                slot: {\n                  path: currentSlot.path,\n                  offset: currentSlot.offset.addn(baseSize.words - 1),\n                  hashPath: currentSlot.hashPath\n                },\n                index: Evm.Utils.WORD_SIZE - 1\n              }\n            };\n            ranges.push(childRange);\n            currentSlot.offset.iaddn(baseSize.words);\n          }\n        } else {\n          const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n          debug(\"perWord %d\", perWord); //currentPosition will point to the start of the entry being decoded\n          //note we have baseSize.bytes <= Evm.Utils.WORD_SIZE\n\n          let currentPosition = {\n            slot: {\n              path: pointer.range.from.slot,\n              offset: new bn_js_1.default(0),\n              hashPath: dataType.kind === \"dynamic\"\n            },\n            index: Evm.Utils.WORD_SIZE - baseSize.bytes //note the starting index!\n\n          };\n\n          for (let i = 0; i < length; i++) {\n            let childRange = {\n              from: {\n                slot: {\n                  path: currentPosition.slot.path,\n                  offset: currentPosition.slot.offset.clone(),\n                  hashPath: currentPosition.slot.hashPath\n                },\n                index: currentPosition.index\n              },\n              length: baseSize.bytes\n            };\n            ranges.push(childRange);\n            currentPosition.index -= baseSize.bytes;\n\n            if (currentPosition.index < 0) {\n              currentPosition.slot.offset.iaddn(1);\n              currentPosition.index = Evm.Utils.WORD_SIZE - baseSize.bytes;\n            }\n          }\n        }\n\n        let decodedChildren = [];\n\n        for (let childRange of ranges) {\n          decodedChildren.push((yield* decodeStorage(dataType.baseType, {\n            location: \"storage\",\n            range: childRange\n          }, info)));\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedChildren\n        };\n      }\n\n    case \"bytes\":\n    case \"string\":\n      {\n        try {\n          data = yield* read_1.default(pointer, state);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error);\n        }\n\n        let lengthByte = data[Evm.Utils.WORD_SIZE - 1];\n\n        if (lengthByte % 2 == 0) {\n          // string lives in word, length is last byte / 2\n          length = lengthByte / 2;\n          debug(\"in-word; length %o\", length);\n          return yield* Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: pointer.range.from.slot,\n                index: 0\n              },\n              to: {\n                slot: pointer.range.from.slot,\n                index: length - 1\n              }\n            }\n          }, info);\n        } else {\n          let lengthAsBN = Conversion.toBN(data).subn(1).divn(2);\n\n          try {\n            length = lengthAsBN.toNumber();\n          } catch (_b) {\n            return {\n              //again with the TS failures...\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"OverlongArraysAndStringsNotImplementedError\",\n                lengthAsBN\n              }\n            };\n          }\n\n          debug(\"new-word, length %o\", length);\n          return yield* Bytes.Decode.decodeBytes(dataType, {\n            location: \"storage\",\n            range: {\n              from: {\n                slot: {\n                  path: pointer.range.from.slot,\n                  offset: new bn_js_1.default(0),\n                  hashPath: true\n                },\n                index: 0\n              },\n              length\n            }\n          }, info);\n        }\n      }\n\n    case \"struct\":\n      {\n        const typeId = dataType.id;\n        const structAllocation = allocations[typeId];\n\n        if (!structAllocation) {\n          return {\n            type: dataType,\n            kind: \"error\",\n            error: {\n              kind: \"UserDefinedTypeNotFoundError\",\n              type: dataType\n            }\n          };\n        }\n\n        let decodedMembers = [];\n        const members = structAllocation.members;\n\n        for (let index = 0; index < members.length; index++) {\n          const memberAllocation = members[index];\n          const memberPointer = memberAllocation.pointer; //the type system thinks memberPointer might also be a constant\n          //definition pointer.  However, structs can't contain constants,\n          //so *we* know it's not, and can safely coerce it.\n\n          debug(\"pointer %O\", pointer);\n          const childRange = {\n            from: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.from.slot.offset.clone() //note that memberPointer should have no path\n\n              },\n              index: memberPointer.range.from.index\n            },\n            to: {\n              slot: {\n                path: pointer.range.from.slot,\n                offset: memberPointer.range.to.slot.offset.clone() //note that memberPointer should have no path\n\n              },\n              index: memberPointer.range.to.index\n            }\n          };\n          let storedType = info.userDefinedTypes[typeId];\n\n          if (!storedType) {\n            return {\n              type: dataType,\n              kind: \"error\",\n              error: {\n                kind: \"UserDefinedTypeNotFoundError\",\n                type: dataType\n              }\n            };\n          }\n\n          let storedMemberType = storedType.memberTypes[index].type;\n          let memberType = Format.Types.specifyLocation(storedMemberType, \"storage\");\n          decodedMembers.push({\n            name: memberAllocation.name,\n            value: yield* decodeStorage(memberType, {\n              location: \"storage\",\n              range: childRange\n            }, info)\n          });\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedMembers\n        };\n      }\n\n    case \"mapping\":\n      {\n        debug(\"decoding mapping\");\n        const valueType = dataType.valueType;\n        let valueSize;\n\n        try {\n          valueSize = allocate_1.storageSize(valueType, info.userDefinedTypes, allocations, info.currentContext.compiler);\n        } catch (error) {\n          return errors_1.handleDecodingError(dataType, error);\n        }\n\n        let decodedEntries = [];\n        const baseSlot = pointer.range.from.slot;\n        debug(\"baseSlot %o\", baseSlot);\n        debug(\"base slot address %o\", Utils.slotAddress(baseSlot));\n        const keySlots = info.mappingKeys.filter(({\n          path\n        }) => Utils.slotAddress(baseSlot).eq(Utils.slotAddress(path)));\n\n        for (const _ref of keySlots) {\n          const key = _ref.key;\n          let valuePointer;\n\n          if (Utils.isWordsLength(valueSize)) {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: 0\n                },\n                to: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(valueSize.words - 1)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          } else {\n            valuePointer = {\n              location: \"storage\",\n              range: {\n                from: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - valueSize.bytes\n                },\n                to: {\n                  slot: {\n                    key,\n                    path: baseSlot,\n                    offset: new bn_js_1.default(0)\n                  },\n                  index: Evm.Utils.WORD_SIZE - 1\n                }\n              }\n            };\n          }\n\n          decodedEntries.push({\n            key,\n            value: yield* decodeStorage(valueType, valuePointer, info)\n          });\n        }\n\n        return {\n          type: dataType,\n          kind: \"value\",\n          value: decodedEntries\n        };\n      }\n  }\n}\n\nexports.decodeStorageReference = decodeStorageReference;","map":null,"metadata":{},"sourceType":"script"}