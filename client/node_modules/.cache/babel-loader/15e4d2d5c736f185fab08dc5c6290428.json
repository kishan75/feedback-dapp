{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Cheerio = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar parse_1 = tslib_1.__importDefault(require(\"./parse\"));\n\nvar options_1 = tslib_1.__importDefault(require(\"./options\"));\n\nvar utils_1 = require(\"./utils\");\n\nvar Attributes = tslib_1.__importStar(require(\"./api/attributes\"));\n\nvar Traversing = tslib_1.__importStar(require(\"./api/traversing\"));\n\nvar Manipulation = tslib_1.__importStar(require(\"./api/manipulation\"));\n\nvar Css = tslib_1.__importStar(require(\"./api/css\"));\n\nvar Forms = tslib_1.__importStar(require(\"./api/forms\"));\n\nvar Cheerio =\n/** @class */\nfunction () {\n  /**\n   * Instance of cheerio. Methods are specified in the modules. Usage of this\n   * constructor is not recommended. Please use $.load instead.\n   *\n   * @private\n   * @param selector - The new selection.\n   * @param context - Context of the selection.\n   * @param root - Sets the root node.\n   * @param options - Options for the instance.\n   */\n  function Cheerio(selector, context, root, options) {\n    var _this = this;\n\n    if (options === void 0) {\n      options = options_1.default;\n    }\n\n    this.length = 0;\n    this.options = options; // $(), $(null), $(undefined), $(false)\n\n    if (!selector) return this;\n\n    if (root) {\n      if (typeof root === 'string') root = parse_1.default(root, this.options, false);\n      this._root = new this.constructor(root, null, null, this.options); // Add a cyclic reference, so that calling methods on `_root` never fails.\n\n      this._root._root = this._root;\n    } // $($)\n\n\n    if (utils_1.isCheerio(selector)) return selector;\n    var elements = typeof selector === 'string' && utils_1.isHtml(selector) ? // $(<html>)\n    parse_1.default(selector, this.options, false).children : isNode(selector) ? // $(dom)\n    [selector] : Array.isArray(selector) ? // $([dom])\n    selector : null;\n\n    if (elements) {\n      elements.forEach(function (elem, idx) {\n        _this[idx] = elem;\n      });\n      this.length = elements.length;\n      return this;\n    } // We know that our selector is a string now.\n\n\n    var search = selector;\n    var searchContext = !context ? // If we don't have a context, maybe we have a root, from loading\n    this._root : typeof context === 'string' ? utils_1.isHtml(context) ? // $('li', '<ul>...</ul>')\n    this._make(parse_1.default(context, this.options, false)) : ( // $('li', 'ul')\n    search = context + \" \" + search, this._root) : utils_1.isCheerio(context) ? // $('li', $)\n    context : // $('li', node), $('li', [nodes])\n    this._make(context); // If we still don't have a context, return\n\n    if (!searchContext) return this;\n    /*\n     * #id, .class, tag\n     */\n    // @ts-expect-error No good way to type this â€” we will always return `Cheerio<Element>` here.\n\n    return searchContext.find(search);\n  }\n  /**\n   * Make a cheerio object.\n   *\n   * @private\n   * @param dom - The contents of the new object.\n   * @param context - The context of the new object.\n   * @returns The new cheerio object.\n   */\n\n\n  Cheerio.prototype._make = function (dom, context) {\n    var cheerio = new this.constructor(dom, context, this._root, this.options);\n    cheerio.prevObject = this;\n    return cheerio;\n  };\n\n  return Cheerio;\n}();\n\nexports.Cheerio = Cheerio;\n/** Set a signature of the object. */\n\nCheerio.prototype.cheerio = '[cheerio object]';\n/*\n * Make cheerio an array-like object\n */\n\nCheerio.prototype.splice = Array.prototype.splice; // Support for (const element of $(...)) iteration:\n\nCheerio.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]; // Plug in the API\n\nObject.assign(Cheerio.prototype, Attributes, Traversing, Manipulation, Css, Forms);\n\nfunction isNode(obj) {\n  return !!obj.name || obj.type === 'root' || obj.type === 'text' || obj.type === 'comment';\n}","map":null,"metadata":{},"sourceType":"script"}