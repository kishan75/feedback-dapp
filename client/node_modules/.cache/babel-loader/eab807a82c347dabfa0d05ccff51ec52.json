{"ast":null,"code":"import { filterHelper, flatMapHelper, joinHelper, mapHelper, nilHelper, takeNHelper, takeWhileHelper } from './StreamHelpers.js';\nexport class Stream {\n  constructor(g) {\n    this.g = g;\n  }\n\n  static nil() {\n    return new Stream(nilHelper());\n  }\n\n  static of(...elements) {\n    return new Stream(elements[Symbol.iterator]());\n  }\n\n  next() {\n    return this.g.next();\n  }\n\n  [Symbol.iterator]() {\n    return this.g;\n  }\n\n  map(f) {\n    return new Stream(mapHelper(this.g, f));\n  }\n\n  flatMap(f) {\n    return new Stream(flatMapHelper(this.g, f));\n  }\n\n  dropWhile(f) {\n    let foundEligible = false;\n\n    function* helper(v) {\n      if (foundEligible || !f(v)) {\n        foundEligible = true;\n        yield v;\n      }\n    }\n\n    return this.flatMap(helper);\n  }\n\n  drop(n) {\n    let idx = 0;\n\n    function helper() {\n      return idx++ < n;\n    }\n\n    return this.dropWhile(helper);\n  }\n\n  takeWhile(f) {\n    return new Stream(takeWhileHelper(this.g, f));\n  }\n\n  take(n) {\n    return new Stream(takeNHelper(this.g, n));\n  }\n\n  filter(f) {\n    return new Stream(filterHelper(this.g, f));\n  }\n\n  every(f) {\n    for (const v of this.g) {\n      if (!f(v)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  has(f) {\n    for (const v of this.g) {\n      if (f(v)) {\n        return [true, v];\n      }\n    }\n\n    return [false, null];\n  }\n\n  join(...others) {\n    return new Stream(joinHelper(this.g, others));\n  }\n\n  getNthOrLast(nth) {\n    let remaining = nth;\n    let last = null;\n\n    for (const v of this.g) {\n      if (remaining-- === 0) return v;\n      last = v;\n    }\n\n    return last;\n  }\n\n}\nexport function stream(g) {\n  return new Stream(g);\n}","map":null,"metadata":{},"sourceType":"module"}