{"ast":null,"code":"import { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { cloneMethod } from '../../check/symbols.js';\nimport { Stream } from '../../stream/Stream.js';\nexport class CloneArbitrary extends NextArbitrary {\n  constructor(arb, numValues) {\n    super();\n    this.arb = arb;\n    this.numValues = numValues;\n  }\n\n  generate(mrng, biasFactor) {\n    const items = [];\n\n    if (this.numValues <= 0) {\n      return this.wrapper(items);\n    }\n\n    for (let idx = 0; idx !== this.numValues - 1; ++idx) {\n      items.push(this.arb.generate(mrng.clone(), biasFactor));\n    }\n\n    items.push(this.arb.generate(mrng, biasFactor));\n    return this.wrapper(items);\n  }\n\n  canShrinkWithoutContext(value) {\n    if (!Array.isArray(value) || value.length !== this.numValues) {\n      return false;\n    }\n\n    if (value.length === 0) {\n      return true;\n    }\n\n    for (let index = 1; index < value.length; ++index) {\n      if (!Object.is(value[0], value[index])) {\n        return false;\n      }\n    }\n\n    return this.arb.canShrinkWithoutContext(value[0]);\n  }\n\n  shrink(value, context) {\n    if (value.length === 0) {\n      return Stream.nil();\n    }\n\n    return new Stream(this.shrinkImpl(value, context !== undefined ? context : [])).map(v => this.wrapper(v));\n  }\n\n  *shrinkImpl(value, contexts) {\n    const its = value.map((v, idx) => this.arb.shrink(v, contexts[idx])[Symbol.iterator]());\n    let cur = its.map(it => it.next());\n\n    while (!cur[0].done) {\n      yield cur.map(c => c.value);\n      cur = its.map(it => it.next());\n    }\n  }\n\n  static makeItCloneable(vs, shrinkables) {\n    vs[cloneMethod] = () => {\n      const cloned = [];\n\n      for (let idx = 0; idx !== shrinkables.length; ++idx) {\n        cloned.push(shrinkables[idx].value);\n      }\n\n      this.makeItCloneable(cloned, shrinkables);\n      return cloned;\n    };\n\n    return vs;\n  }\n\n  wrapper(items) {\n    let cloneable = false;\n    const vs = [];\n    const contexts = [];\n\n    for (let idx = 0; idx !== items.length; ++idx) {\n      const s = items[idx];\n      cloneable = cloneable || s.hasToBeCloned;\n      vs.push(s.value);\n      contexts.push(s.context);\n    }\n\n    if (cloneable) {\n      CloneArbitrary.makeItCloneable(vs, items);\n    }\n\n    return new NextValue(vs, contexts);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}