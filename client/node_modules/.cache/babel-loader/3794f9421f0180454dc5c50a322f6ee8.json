{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.getterParameters = exports.definitionToAbi = exports.isContractPayable = exports.mutability = exports.functionClass = exports.functionKind = exports.parameters = exports.valueDefinition = exports.keyDefinition = exports.baseDefinition = exports.rationalValue = exports.regularizeTypeIdentifier = exports.spliceLocation = exports.isSimpleConstant = exports.stackSize = exports.contractKind = exports.referenceType = exports.isReference = exports.isEnum = exports.isMapping = exports.isStruct = exports.staticLengthAsString = exports.staticLength = exports.isDynamicArray = exports.isArray = exports.decimalPlaces = exports.specifiedSize = exports.visibility = exports.typeId = exports.typeClassLongForm = exports.typeClass = exports.typeStringWithoutLocation = exports.typeString = exports.typeIdentifier = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:ast:utils\");\n\nconst Common = __importStar(require(\"../common\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst cloneDeep_1 = __importDefault(require(\"lodash/cloneDeep\"));\n/** @category Definition Reading */\n\n\nfunction typeIdentifier(definition) {\n  return definition.typeDescriptions.typeIdentifier;\n}\n\nexports.typeIdentifier = typeIdentifier;\n/** @category Definition Reading */\n\nfunction typeString(definition) {\n  return definition.typeDescriptions.typeString;\n}\n\nexports.typeString = typeString;\n/**\n * Returns the type string, but with location (if any) stripped off the end\n * @category Definition Reading\n */\n\nfunction typeStringWithoutLocation(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    //for handling Yul variables\n    return \"bytes32\";\n  }\n\n  return typeString(definition).replace(/ (storage|memory|calldata)( slice)?$/, \"\");\n}\n\nexports.typeStringWithoutLocation = typeStringWithoutLocation;\n/**\n * returns basic type class for a variable definition node\n * e.g.:\n *  `t_uint256` becomes `uint`\n *  `t_struct$_Thing_$20_memory_ptr` becomes `struct`\n * @category Definition Reading\n */\n\nfunction typeClass(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    //for handling Yul variables\n    return \"bytes\";\n  }\n\n  return typeIdentifier(definition).match(/t_([^$_0-9]+)/)[1];\n}\n\nexports.typeClass = typeClass;\n/**\n * similar to typeClass, but includes any numeric qualifiers\n * e.g.:\n * `t_uint256` becomes `uint256`\n * @category Definition Reading\n */\n\nfunction typeClassLongForm(definition) {\n  return typeIdentifier(definition).match(/t_([^$_]+)/)[1];\n}\n\nexports.typeClassLongForm = typeClassLongForm;\n/**\n * for user-defined types -- structs, enums, contracts\n * often you can get these from referencedDeclaration, but not\n * always\n * @category Definition Reading\n */\n\nfunction typeId(definition) {\n  debug(\"definition %O\", definition);\n  return parseInt(typeIdentifier(definition).match(/\\$(\\d+)(_(storage|memory|calldata)(_ptr(_slice)?)?)?$/)[1]);\n}\n\nexports.typeId = typeId;\n/**\n * For function types; returns internal or external\n * (not for use on other types! will cause an error!)\n * should only return \"internal\" or \"external\"\n * @category Definition Reading\n */\n\nfunction visibility(definition) {\n  return definition.typeName ? definition.typeName.visibility : definition.visibility;\n}\n\nexports.visibility = visibility;\n/**\n * e.g. uint48 -> 6\n * @return size in bytes for explicit type size, or `null` if not stated\n * @category Definition Reading\n */\n\nfunction specifiedSize(definition) {\n  if (definition.nodeType === \"YulTypedName\") {\n    return 32; //for handling Yul variables\n  }\n\n  let specified = typeIdentifier(definition).match(/t_[a-z]+([0-9]+)/);\n\n  if (!specified) {\n    return null;\n  }\n\n  let num = parseInt(specified[1]);\n\n  switch (typeClass(definition)) {\n    case \"int\":\n    case \"uint\":\n    case \"fixed\":\n    case \"ufixed\":\n      return num / 8;\n\n    case \"bytes\":\n      return num;\n\n    default:\n      debug(\"Unknown type for size specification: %s\", typeIdentifier(definition));\n  }\n}\n\nexports.specifiedSize = specifiedSize;\n/**\n * for fixed-point types, obviously\n * @category Definition Reading\n */\n\nfunction decimalPlaces(definition) {\n  return parseInt(typeIdentifier(definition).match(/t_[a-z]+[0-9]+x([0-9]+)/)[1]);\n}\n\nexports.decimalPlaces = decimalPlaces;\n/** @category Definition Reading */\n\nfunction isArray(definition) {\n  return typeIdentifier(definition).match(/^t_array/) != null;\n}\n\nexports.isArray = isArray;\n/** @category Definition Reading */\n\nfunction isDynamicArray(definition) {\n  return isArray(definition) && //NOTE: we do this by parsing the type identifier, rather than by just\n  //checking the length field, because we might be using this on a faked-up\n  //definition\n  typeIdentifier(definition).match(/\\$dyn_(storage|memory|calldata)(_ptr(_slice)?)?$/) != null;\n}\n\nexports.isDynamicArray = isDynamicArray;\n/**\n * length of a statically sized array -- please only use for arrays\n * already verified to be static!\n * @category Definition Reading\n */\n\nfunction staticLength(definition) {\n  //NOTE: we do this by parsing the type identifier, rather than by just\n  //checking the length field, because we might be using this on a faked-up\n  //definition\n  return parseInt(staticLengthAsString(definition));\n}\n\nexports.staticLength = staticLength;\n/**\n * see staticLength for explanation\n * @category Definition Reading\n */\n\nfunction staticLengthAsString(definition) {\n  return typeIdentifier(definition).match(/\\$(\\d+)_(storage|memory|calldata)(_ptr(_slice)?)?$/)[1];\n}\n\nexports.staticLengthAsString = staticLengthAsString;\n/** @category Definition Reading */\n\nfunction isStruct(definition) {\n  return typeIdentifier(definition).match(/^t_struct/) != null;\n}\n\nexports.isStruct = isStruct;\n/** @category Definition Reading */\n\nfunction isMapping(definition) {\n  return typeIdentifier(definition).match(/^t_mapping/) != null;\n}\n\nexports.isMapping = isMapping;\n/** @category Definition Reading */\n\nfunction isEnum(definition) {\n  return typeIdentifier(definition).match(/^t_enum/) != null;\n}\n\nexports.isEnum = isEnum;\n/** @category Definition Reading */\n\nfunction isReference(definition) {\n  return typeIdentifier(definition).match(/_(memory|storage|calldata)(_ptr(_slice)?)?$/) != null;\n}\n\nexports.isReference = isReference;\n/**\n * note: only use this on things already verified to be references\n * @category Definition Reading\n */\n\nfunction referenceType(definition) {\n  return typeIdentifier(definition).match(/_([^_]+)(_ptr(_slice)?)?$/)[1];\n}\n\nexports.referenceType = referenceType;\n/**\n * only for contract types, obviously! will yield nonsense otherwise!\n * @category Definition Reading\n */\n\nfunction contractKind(definition) {\n  return typeString(definition).split(\" \")[0];\n}\n\nexports.contractKind = contractKind;\n/**\n * stack size, in words, of a given type\n * note: this function assumes that UDVTs only ever take up\n * a single word, which is currently true\n * @category Definition Reading\n */\n\nfunction stackSize(definition) {\n  if (typeClass(definition) === \"function\" && visibility(definition) === \"external\") {\n    return 2;\n  }\n\n  if (isReference(definition) && referenceType(definition) === \"calldata\") {\n    if (typeClass(definition) === \"string\" || typeClass(definition) === \"bytes\") {\n      return 2;\n    }\n\n    if (isDynamicArray(definition)) {\n      return 2;\n    }\n  }\n\n  return 1;\n}\n\nexports.stackSize = stackSize;\n/** @category Definition Reading */\n\nfunction isSimpleConstant(definition) {\n  const types = [\"stringliteral\", \"rational\"];\n  return types.includes(typeClass(definition));\n}\n\nexports.isSimpleConstant = isSimpleConstant;\n/**\n * definition: a storage reference definition\n * location: the location you want it to refer to instead\n * @category Definition Reading\n */\n\nfunction spliceLocation(definition, location) {\n  debug(\"definition %O\", definition);\n  return Object.assign(Object.assign({}, definition), {\n    typeDescriptions: Object.assign(Object.assign({}, definition.typeDescriptions), {\n      typeIdentifier: definition.typeDescriptions.typeIdentifier.replace(/_(storage|memory|calldata)(?=((_slice)?_ptr)?$)/, \"_\" + location)\n    })\n  });\n}\n\nexports.spliceLocation = spliceLocation;\n/**\n * adds \"_ptr\" on to the end of type identifiers that might need it; note that\n * this operates on identifiers, not definitions\n * @category Definition Reading\n */\n\nfunction regularizeTypeIdentifier(identifier) {\n  return identifier.replace(/(_(storage|memory|calldata))((_slice)?_ptr)?$/, \"$1_ptr\" //this used to use lookbehind for clarity, but Firefox...\n  //(see: https://github.com/trufflesuite/truffle/issues/3068 )\n  );\n}\n\nexports.regularizeTypeIdentifier = regularizeTypeIdentifier;\n/**\n * extract the actual numerical value from a node of type rational.\n * currently assumes result will be integer (currently returns BN)\n * @category Definition Reading\n */\n\nfunction rationalValue(definition) {\n  let identifier = typeIdentifier(definition);\n  let absoluteValue = identifier.match(/_(\\d+)_by_1$/)[1];\n  let isNegative = identifier.match(/_minus_/) != null;\n  return isNegative ? new bn_js_1.default(absoluteValue).neg() : new bn_js_1.default(absoluteValue);\n}\n\nexports.rationalValue = rationalValue;\n/** @category Definition Reading */\n\nfunction baseDefinition(definition) {\n  if (definition.typeName && definition.typeName.baseType) {\n    return definition.typeName.baseType;\n  }\n\n  if (definition.baseType) {\n    return definition.baseType;\n  } //otherwise, we'll have to spoof it up ourselves\n\n\n  let baseIdentifier = typeIdentifier(definition).match(/^t_array\\$_(.*)_\\$/)[1]; //greedy match to extract everything from first to last dollar sign\n  // HACK - internal types for memory or storage also seem to be pointers\n\n  baseIdentifier = regularizeTypeIdentifier(baseIdentifier); // another HACK - we get away with it because we're only using that one property\n\n  let result = cloneDeep_1.default(definition);\n  result.typeDescriptions.typeIdentifier = baseIdentifier;\n  return result; //WARNING -- these hacks do *not* correctly handle all cases!\n  //they do, however, handle the cases we currently need.\n}\n\nexports.baseDefinition = baseDefinition;\n/**\n * for use for mappings and arrays only!\n * for arrays, fakes up a uint definition\n * @category Definition Reading\n */\n\nfunction keyDefinition(definition, scopes) {\n  let result;\n\n  switch (typeClass(definition)) {\n    case \"mapping\":\n      //first: is there a key type already there? if so just use that\n      if (definition.keyType) {\n        return definition.keyType;\n      }\n\n      if (definition.typeName && definition.typeName.keyType) {\n        return definition.typeName.keyType;\n      } //otherwise: is there a referencedDeclaration? if so try using that\n\n\n      let baseDeclarationId = definition.referencedDeclaration;\n      debug(\"baseDeclarationId %d\", baseDeclarationId); //if there's a referencedDeclaration, we'll use that\n\n      if (baseDeclarationId !== undefined) {\n        let baseDeclaration = scopes[baseDeclarationId].definition;\n        return baseDeclaration.keyType || baseDeclaration.typeName.keyType;\n      } //otherwise, we'll need to perform some hackery, similarly to in baseDefinition;\n      //we'll have to spoof it up ourselves\n\n\n      let keyIdentifier = typeIdentifier(definition).match(/^t_mapping\\$_(.*?)_\\$_/)[1]; //use *non*-greedy match; note that if the key type could include\n      //the sequence \"_$_\", this could cause a problem, but they can't; the only\n      //valid key types that include dollar signs at all are user-defined types,\n      //which contain both \"$_\" and \"_$\" but never \"_$_\".\n      // HACK - internal types for memory or storage also seem to be pointers\n\n      keyIdentifier = regularizeTypeIdentifier(keyIdentifier);\n      let keyString = typeString(definition).match(/mapping\\((.*?) => .*\\)( storage)?$/)[1]; //use *non*-greedy match; note that if the key type could include\n      //\"=>\", this could cause a problem, but mappings are not allowed as key\n      //types, so this can't come up\n      // another HACK - we get away with it because we're only using that one property\n\n      result = cloneDeep_1.default(definition);\n      result.typeDescriptions = {\n        typeIdentifier: keyIdentifier,\n        typeString: keyString\n      };\n      return result;\n\n    case \"array\":\n      //HACK -- again we should get away with it because for a uint256 we don't\n      //really need to inspect the other properties\n      result = cloneDeep_1.default(definition);\n      result.typeDescriptions = {\n        typeIdentifier: \"t_uint256\",\n        typeString: \"uint256\"\n      };\n      return result;\n\n    default:\n      debug(\"unrecognized index access!\");\n  }\n}\n\nexports.keyDefinition = keyDefinition;\n/**\n * for use for mappings only!\n * @category Definition Reading\n */\n\nfunction valueDefinition(definition, scopes) {\n  let result; //first: is there a value type already there? if so just use that\n\n  if (definition.valueType) {\n    return definition.valueType;\n  }\n\n  if (definition.typeName && definition.typeName.valueType) {\n    return definition.typeName.valueType;\n  } //otherwise: is there a referencedDeclaration? if so try using that\n\n\n  let baseDeclarationId = definition.referencedDeclaration;\n  debug(\"baseDeclarationId %d\", baseDeclarationId); //if there's a referencedDeclaration, we'll use that\n\n  if (baseDeclarationId !== undefined) {\n    let baseDeclaration = scopes[baseDeclarationId].definition;\n    return baseDeclaration.valueType || baseDeclaration.typeName.valueType;\n  } //otherwise, we'll need to perform some hackery, similarly to in keyDefinition;\n  //we'll have to spoof it up ourselves\n\n\n  let valueIdentifier = typeIdentifier(definition).match(/^t_mapping\\$_.*?_\\$_(.*)_\\$/)[1]; //use *non*-greedy match on the key; note that if the key type could include\n  //the sequence \"_$_\", this could cause a problem, but they can't; the only\n  //valid key types that include dollar signs at all are user-defined types,\n  //which contain both \"$_\" and \"_$\" but never \"_$_\".\n  // HACK - internal types for memory or storage also seem to be pointers\n\n  valueIdentifier = regularizeTypeIdentifier(valueIdentifier);\n  let valueString = typeString(definition).match(/mapping\\(.*? => (.*)\\)( storage)?$/)[1]; //use *non*-greedy match; note that if the key type could include\n  //\"=>\", this could cause a problem, but mappings are not allowed as key\n  //types, so this can't come up\n  // another HACK - we get away with it because we're only using that one property\n\n  result = cloneDeep_1.default(definition);\n  result.typeDescriptions = {\n    typeIdentifier: valueIdentifier,\n    typeString: valueString\n  };\n  return result;\n}\n\nexports.valueDefinition = valueDefinition;\n/**\n * returns input parameters, then output parameters\n * NOTE: ONLY FOR VARIABLE DECLARATIONS OF FUNCTION TYPE\n * NOT FOR FUNCTION DEFINITIONS\n * @category Definition Reading\n */\n\nfunction parameters(definition) {\n  let typeObject = definition.typeName || definition;\n\n  if (typeObject.parameterTypes && typeObject.returnParameterTypes) {\n    return [typeObject.parameterTypes.parameters, typeObject.returnParameterTypes.parameters];\n  } else {\n    return undefined;\n  }\n}\n\nexports.parameters = parameters;\n/**\n * compatibility function, since pre-0.5.0 functions don't have node.kind\n * returns undefined if you don't put in a function node\n * @category Definition Reading\n */\n\nfunction functionKind(node) {\n  if (node.nodeType !== \"FunctionDefinition\") {\n    return undefined;\n  }\n\n  if (node.kind !== undefined) {\n    //if we're dealing with 0.5.x, we can just read node.kind\n    return node.kind;\n  } //otherwise, we need this little shim\n\n\n  if (node.isConstructor) {\n    return \"constructor\";\n  }\n\n  return node.name === \"\" ? \"fallback\" : \"function\";\n}\n\nexports.functionKind = functionKind; //this is kind of a weird one, it exposes some Solidity internals.\n//for internal functions it'll return \"internal\".\n//for external functions it'll return \"external\".\n//for library functions it'll return \"delegatecall\".\n//and for builtin functions, it'll return an internal name for\n//that particular builtin function.\n//(there are more possibilities but I'm not going to list them all here)\n\nfunction functionClass(node) {\n  const match = typeIdentifier(node).match(/^t_function_([^_]+)_/);\n  return match ? match[1] : undefined;\n}\n\nexports.functionClass = functionClass;\n/**\n * similar compatibility function for mutability for pre-0.4.16 versions\n * returns undefined if you don't give it a FunctionDefinition or\n * VariableDeclaration\n * @category Definition Reading\n */\n\nfunction mutability(node) {\n  node = node.typeName || node;\n\n  if (node.nodeType !== \"FunctionDefinition\" && node.nodeType !== \"FunctionTypeName\") {\n    return undefined;\n  }\n\n  if (node.stateMutability !== undefined) {\n    //if we're dealing with 0.4.16 or later, we can just read node.stateMutability\n    return node.stateMutability;\n  } //otherwise, we need this little shim\n\n\n  if (node.payable) {\n    return \"payable\";\n  }\n\n  if (node.constant) {\n    //yes, it means \"view\" even if you're looking at a variable declaration!\n    //old Solidity was weird!\n    return \"view\";\n  }\n\n  return \"nonpayable\";\n}\n\nexports.mutability = mutability;\n/**\n * takes a contract definition and asks, does it have a payable fallback\n * function?\n * @category Definition Reading\n */\n\nfunction isContractPayable(definition) {\n  return definition.nodes.some(node => node.nodeType === \"FunctionDefinition\" && (functionKind(node) === \"fallback\" || functionKind(node) === \"receive\") && mutability(node) === \"payable\");\n}\n\nexports.isContractPayable = isContractPayable;\n/**\n * the main function. just does some dispatch.\n * returns undefined on bad input\n */\n\nfunction definitionToAbi(node, referenceDeclarations) {\n  switch (node.nodeType) {\n    case \"FunctionDefinition\":\n      if (node.visibility === \"public\" || node.visibility === \"external\") {\n        return functionDefinitionToAbi(node, referenceDeclarations);\n      } else {\n        return undefined;\n      }\n\n    case \"EventDefinition\":\n      return eventDefinitionToAbi(node, referenceDeclarations);\n\n    case \"ErrorDefinition\":\n      return errorDefinitionToAbi(node, referenceDeclarations);\n\n    case \"VariableDeclaration\":\n      if (node.visibility === \"public\") {\n        return getterDefinitionToAbi(node, referenceDeclarations);\n      } else {\n        return undefined;\n      }\n\n    default:\n      return undefined;\n  }\n}\n\nexports.definitionToAbi = definitionToAbi; //note: not for FunctionTypeNames or VariableDeclarations\n\nfunction functionDefinitionToAbi(node, referenceDeclarations) {\n  let kind = functionKind(node);\n  let stateMutability = mutability(node);\n  let payable = stateMutability === \"payable\";\n  let inputs;\n\n  switch (kind) {\n    case \"function\":\n      let name = node.name;\n      let outputs = parametersToAbi(node.returnParameters.parameters, referenceDeclarations);\n      inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n      return {\n        type: \"function\",\n        name,\n        inputs,\n        outputs,\n        stateMutability\n      };\n\n    case \"constructor\":\n      inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations); //note: need to coerce because of mutability restrictions\n\n      return {\n        type: \"constructor\",\n        inputs,\n        stateMutability,\n        payable\n      };\n\n    case \"fallback\":\n      //note: need to coerce because of mutability restrictions\n      return {\n        type: \"fallback\",\n        stateMutability,\n        payable\n      };\n\n    case \"receive\":\n      //note: need to coerce because of mutability restrictions\n      return {\n        type: \"receive\",\n        stateMutability,\n        payable\n      };\n  }\n}\n\nfunction eventDefinitionToAbi(node, referenceDeclarations) {\n  let inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n  let name = node.name;\n  let anonymous = node.anonymous;\n  return {\n    type: \"event\",\n    inputs,\n    name,\n    anonymous\n  };\n}\n\nfunction errorDefinitionToAbi(node, referenceDeclarations) {\n  let inputs = parametersToAbi(node.parameters.parameters, referenceDeclarations);\n  let name = node.name;\n  return {\n    type: \"error\",\n    inputs,\n    name\n  };\n}\n\nfunction parametersToAbi(nodes, referenceDeclarations) {\n  return nodes.map(node => parameterToAbi(node, referenceDeclarations));\n} //NOTE: This function is only for types that could potentially go in the ABI!\n//(otherwise it could, say, loop infinitely)\n//currently it will only ever be called on those because it's only called from\n//definitionToAbi, which filters out any definitions that are not for\n//this that *actually* go in the ABI\n//if you want to expand it to handle those (by throwing an exception, say),\n//you'll need to give it a way to detect circularities\n\n\nfunction parameterToAbi(node, referenceDeclarations) {\n  let name = node.name; //may be the empty string... or even undefined for a base type\n\n  let components;\n  let internalType = typeStringWithoutLocation(node); //is this an array? if so use separate logic\n\n  if (typeClass(node) === \"array\") {\n    let baseType = node.typeName ? node.typeName.baseType : node.baseType;\n    let baseAbi = parameterToAbi(baseType, referenceDeclarations);\n    let arraySuffix = isDynamicArray(node) ? \"[]\" : \"[\".concat(staticLength(node), \"]\");\n    const parameter = {\n      name,\n      type: baseAbi.type + arraySuffix,\n      components: baseAbi.components,\n      internalType\n    };\n\n    if (\"indexed\" in node) {\n      return Object.assign(Object.assign({}, parameter), {\n        indexed: node.indexed\n      });\n    } else {\n      return parameter;\n    }\n  }\n\n  let abiTypeString = toAbiType(node, referenceDeclarations); //otherwise... is it a struct? if so we need to populate components\n\n  if (typeClass(node) === \"struct\") {\n    let id = typeId(node);\n    let referenceDeclaration = referenceDeclarations[id];\n\n    if (referenceDeclaration === undefined) {\n      let typeToDisplay = typeString(node);\n      throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);\n    }\n\n    components = parametersToAbi(referenceDeclaration.members, referenceDeclarations);\n  }\n\n  const parameter = {\n    name,\n    type: abiTypeString,\n    components,\n    internalType\n  };\n\n  if (\"indexed\" in node) {\n    return Object.assign(Object.assign({}, parameter), {\n      indexed: node.indexed\n    });\n  } else {\n    return parameter;\n  }\n} //note: this is only meant for non-array types that can go in the ABI\n//it returns how that type is notated in the ABI -- just the string,\n//to be clear, not components of tuples\n//again, NOT FOR ARRAYS\n\n\nfunction toAbiType(node, referenceDeclarations) {\n  let basicType = typeClassLongForm(node); //get that whole first segment!\n\n  switch (basicType) {\n    case \"contract\":\n      return \"address\";\n\n    case \"struct\":\n      return \"tuple\";\n    //the more detailed checking will be handled elsewhere\n\n    case \"enum\":\n      {\n        const referenceId = typeId(node);\n        const referenceDeclaration = referenceDeclarations[referenceId];\n\n        if (referenceDeclaration === undefined) {\n          const typeToDisplay = typeString(node);\n          throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);\n        }\n\n        const numOptions = referenceDeclaration.members.length;\n        const bits = 8 * Math.ceil(Math.log2(numOptions) / 8);\n        return \"uint\".concat(bits);\n      }\n\n    case \"userDefinedValueType\":\n      {\n        const referenceId = typeId(node);\n        const referenceDeclaration = referenceDeclarations[referenceId];\n\n        if (referenceDeclaration === undefined) {\n          const typeToDisplay = typeString(node);\n          throw new Common.UnknownUserDefinedTypeError(referenceId.toString(), typeToDisplay);\n        }\n\n        const underlyingType = referenceDeclaration.underlyingType;\n        return toAbiType(underlyingType, referenceDeclarations);\n      }\n\n    default:\n      return basicType;\n    //note that: int/uint/fixed/ufixed/bytes will have their size and such left on;\n    //address will have \"payable\" left off;\n    //external functions will be reduced to \"function\" (and internal functions shouldn't\n    //be passed in!)\n    //(mappings shouldn't be passed in either obviously)\n    //(nor arrays :P )\n  }\n}\n\nfunction getterDefinitionToAbi(node, referenceDeclarations) {\n  debug(\"getter node: %O\", node);\n  let name = node.name;\n\n  let _getterParameters = getterParameters(node, referenceDeclarations),\n      inputs = _getterParameters.inputs,\n      outputs = _getterParameters.outputs;\n\n  let inputsAbi = parametersToAbi(inputs, referenceDeclarations);\n  let outputsAbi = parametersToAbi(outputs, referenceDeclarations);\n  return {\n    type: \"function\",\n    name,\n    inputs: inputsAbi,\n    outputs: outputsAbi,\n    stateMutability: \"view\"\n  };\n} //how getter parameters work:\n//INPUT:\n//types other than arrays and mappings take no input.\n//array getters take uint256 input. mapping getters take input of their key type.\n//if arrays, mappings, stacked, then takes multiple inputs, in order from outside\n//to in.\n//These parameters are unnamed.\n//OUTPUT:\n//if base type (beneath mappings & arrays) is not a struct, returns that.\n//(This return parameter has no name -- it is *not* named for the variable!)\n//if it is a struct, returns multiple outputs, one for each member of the struct,\n//*except* arrays and mappings.  (And they have names, the names of the members.)\n//important note: inner structs within a struct are just returned, not\n//partially destructured like the outermost struct!  Yes, this is confusing.\n\n\nfunction getterParameters(node, referenceDeclarations) {\n  let baseNode = node.typeName || node;\n  let inputs = [];\n\n  while (typeClass(baseNode) === \"array\" || typeClass(baseNode) === \"mapping\") {\n    let keyNode = keyDefinition(baseNode); //note: if baseNode is an array, this spoofs up a uint256 definition\n\n    inputs.push(Object.assign(Object.assign({}, keyNode), {\n      name: \"\"\n    })); //again, getter input params have no name\n\n    switch (typeClass(baseNode)) {\n      case \"array\":\n        baseNode = baseNode.baseType;\n        break;\n\n      case \"mapping\":\n        baseNode = baseNode.valueType;\n        break;\n    }\n  } //at this point, baseNode should hold the base type\n  //now we face the question: is it a struct?\n\n\n  if (typeClass(baseNode) === \"struct\") {\n    let id = typeId(baseNode);\n    let referenceDeclaration = referenceDeclarations[id];\n\n    if (referenceDeclaration === undefined) {\n      let typeToDisplay = typeString(baseNode);\n      throw new Common.UnknownUserDefinedTypeError(id.toString(), typeToDisplay);\n    }\n\n    let outputs = referenceDeclaration.members.filter(member => typeClass(member) !== \"array\" && typeClass(member) !== \"mapping\");\n    return {\n      inputs,\n      outputs\n    }; //no need to wash name!\n  } else {\n    //only one output; it's just the base node, with its name washed\n    return {\n      inputs,\n      outputs: [Object.assign(Object.assign({}, baseNode), {\n        name: \"\"\n      })]\n    };\n  }\n}\n\nexports.getterParameters = getterParameters;","map":null,"metadata":{},"sourceType":"script"}