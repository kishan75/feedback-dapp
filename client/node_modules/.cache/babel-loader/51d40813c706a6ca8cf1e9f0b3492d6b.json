{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst BinaryParseStream = require('../vendor/binary-parse-stream');\n\nconst Tagged = require('./tagged');\n\nconst Simple = require('./simple');\n\nconst utils = require('./utils');\n\nconst bignumber = require('bignumber.js').BigNumber;\n\nconst NoFilter = require('nofilter');\n\nconst constants = require('./constants'); // Do not fix this if you want to support node v4\n\n\nconst MT = constants.MT;\nconst NUMBYTES = constants.NUMBYTES;\nconst SIMPLE = constants.SIMPLE;\nconst SYMS = constants.SYMS;\nconst BI = utils.bigIntize(constants.BI);\nconst BN = constants.BN;\nconst COUNT = Symbol('count');\nconst PENDING_KEY = Symbol('pending_key');\nconst MAJOR = Symbol('major type');\nconst ERROR = Symbol('error');\nconst NOT_FOUND = Symbol('not found');\n\nfunction parentArray(parent, typ, count) {\n  const a = [];\n  a[COUNT] = count;\n  a[SYMS.PARENT] = parent;\n  a[MAJOR] = typ;\n  return a;\n}\n\nfunction parentBufferStream(parent, typ) {\n  const b = new NoFilter();\n  b[COUNT] = -1;\n  b[SYMS.PARENT] = parent;\n  b[MAJOR] = typ;\n  return b;\n}\n/**\n * @param {Buffer} v\n * @private\n */\n\n\nfunction _tag_2(v) {\n  return utils.bufferToBigInt(v);\n}\n/**\n * @param {BigInt} v\n * @private\n */\n\n\nfunction _tag_3(v) {\n  // avoid syntax error on old runtimes\n  return BI.MINUS_ONE - utils.bufferToBigInt(v);\n}\n/**\n * Decode a stream of CBOR bytes by transforming them into equivalent\n * JavaScript data.  Because of the limitations of Node object streams,\n * special symbols are emitted instead of NULL or UNDEFINED.  Fix those\n * up by calling {@link Decoder.nullcheck}.\n *\n * @extends {BinaryParseStream}\n */\n\n\nclass Decoder extends BinaryParseStream {\n  /**\n   * Create a parsing stream.\n   *\n   * @param {object} [options={}]\n   * @param {number} [options.max_depth=-1] - the maximum depth to parse.\n   *   Use -1 for \"until you run out of memory\".  Set this to a finite\n   *   positive number for un-trusted inputs.  Most standard inputs won't nest\n   *   more than 100 or so levels; I've tested into the millions before\n   *   running out of memory.\n   * @param {object} [options.tags] - mapping from tag number to function(v),\n   *   where v is the decoded value that comes after the tag, and where the\n   *   function returns the correctly-created value for that tag.\n   * @param {boolean} [options.bigint=false] generate JavaScript BigInt's\n   *   instead of BigNumbers, when possible.  TODO: when BigInt's are\n   *   more prevalent, change this to default to the value of cbor.hasBigInt.\n   */\n  constructor(options) {\n    options = options || {};\n    const tags = options.tags;\n    delete options.tags;\n    const max_depth = options.max_depth != null ? options.max_depth : -1;\n    delete options.max_depth;\n    const bigI = utils.hasBigInt ? !!options.bigint : false;\n    delete options.bigint;\n    super(options);\n    this.running = true;\n    this.max_depth = max_depth;\n    this.tags = tags;\n\n    if (bigI) {\n      if (this.tags == null) {\n        this.tags = {};\n      }\n\n      if (this.tags[2] == null) {\n        this.tags[2] = _tag_2;\n      }\n\n      if (this.tags[3] == null) {\n        this.tags[3] = _tag_3;\n      }\n    }\n  }\n  /**\n   * Check the given value for a symbol encoding a NULL or UNDEFINED value in\n   * the CBOR stream.\n   *\n   * @static\n   * @param {any} val - the value to check\n   * @returns {any} the corrected value\n   *\n   * @example\n   * myDecoder.on('data', function(val) {\n   *   val = Decoder.nullcheck(val);\n   *   ...\n   * });\n   */\n\n\n  static nullcheck(val) {\n    switch (val) {\n      case SYMS.NULL:\n        return null;\n\n      case SYMS.UNDEFINED:\n        return undefined;\n\n      case NOT_FOUND:\n        throw new Error('Value not found');\n\n      default:\n        return val;\n    }\n  }\n  /**\n   * @typedef DecodeOptions\n   * @property {string} [encoding='hex'] - The encoding of the input.\n   *   Ignored if input is a Buffer.\n   */\n\n  /**\n   * Decode the first CBOR item in the input, synchronously.  This will throw an\n   * exception if the input is not valid CBOR.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options\n   * @returns {any} - the decoded value\n   */\n\n\n  static decodeFirstSync(input, options) {\n    options = options || {\n      encoding: 'hex'\n    };\n    let opts = {};\n    let encod;\n\n    switch (typeof options) {\n      case 'string':\n        encod = options;\n        break;\n\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding;\n        delete opts.encoding;\n        break;\n    }\n\n    const c = new Decoder(opts);\n    const s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input)); // for/of doesn't work when you need to call next() with a value\n    // generator created by parser will be \"done\" after each CBOR entity\n    // parser will yield numbers of bytes that it wants\n\n    const parser = c._parse();\n\n    let state = parser.next();\n\n    while (!state.done) {\n      const b = s.read(state.value);\n\n      if (b == null || b.length !== state.value) {\n        throw new Error('Insufficient data');\n      }\n\n      state = parser.next(b);\n    }\n\n    const val = Decoder.nullcheck(state.value);\n\n    if (s.length > 0) {\n      const nextByte = s.read(1);\n      s.unshift(nextByte);\n      const er = new Error('Unexpected data: 0x' + nextByte[0].toString(16));\n      er.value = val;\n      throw er;\n    }\n\n    return val;\n  }\n  /**\n   * Decode all of the CBOR items in the input into an array.  This will throw\n   * an exception if the input is not valid CBOR; a zero-length input will\n   * return an empty array.\n   *\n   * @static\n   * @param {string|Buffer|stream.Readable} input\n   * @param {DecodeOptions|string} [options] Options or encoding string\n   * @returns {Array} - Array of all found items\n   */\n\n\n  static decodeAllSync(input, options) {\n    options = options || {\n      encoding: 'hex'\n    };\n    let opts = {};\n    let encod;\n\n    switch (typeof options) {\n      case 'string':\n        encod = options;\n        break;\n\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding;\n        delete opts.encoding;\n    }\n\n    const c = new Decoder(opts);\n    const s = input instanceof stream.Readable ? input : new NoFilter(input, encod != null ? encod : utils.guessEncoding(input));\n    const res = [];\n\n    while (s.length > 0) {\n      const parser = c._parse();\n\n      let state = parser.next();\n\n      while (!state.done) {\n        const b = s.read(state.value);\n\n        if (b == null || b.length !== state.value) {\n          throw new Error('Insufficient data');\n        }\n\n        state = parser.next(b);\n      }\n\n      res.push(Decoder.nullcheck(state.value));\n    }\n\n    return res;\n  }\n  /**\n   * @callback decodeCallback\n   * @param {Error} [error] - if one was generated\n   * @param {any} [value] - the decoded value\n   */\n\n  /**\n   * Decode the first CBOR item in the input.  This will error if there are more\n   * bytes left over at the end, and optionally if there were no valid CBOR\n   * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback\n   * if no data was found and the `required` option is false.\n   *\n   * @static\n   * @param {string|Buffer} input - the input to parse\n   * @param {DecodeOptions|decodeCallback|string} [options] - options\n   * @param {decodeCallback} [cb] callback\n   * @returns {Promise<any>} returned even if callback is specified\n   */\n\n\n  static decodeFirst(input, options, cb) {\n    let opts = {};\n    let required = false;\n    let encod = 'hex';\n\n    switch (typeof options) {\n      case 'function':\n        cb = options;\n        encod = utils.guessEncoding(input);\n        break;\n\n      case 'string':\n        encod = options;\n        break;\n\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n        required = opts.required != null ? opts.required : false;\n        delete opts.required;\n    }\n\n    const c = new Decoder(opts);\n    let v = NOT_FOUND;\n    const p = new Promise((resolve, reject) => {\n      c.on('data', val => {\n        v = Decoder.nullcheck(val);\n        c.close();\n      });\n      c.once('error', er => {\n        if (v !== NOT_FOUND) {\n          er.value = v;\n        }\n\n        v = ERROR;\n        c.close();\n        return reject(er);\n      });\n      c.once('end', () => {\n        switch (v) {\n          case NOT_FOUND:\n            if (required) {\n              return reject(new Error('No CBOR found'));\n            } else {\n              return resolve(v);\n            }\n\n          case ERROR:\n            return void 0;\n\n          default:\n            return resolve(v);\n        }\n      });\n    });\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb);\n    }\n\n    c.end(input, encod);\n    return p;\n  }\n  /**\n   * @callback decodeAllCallback\n   * @param {Error} error - if one was generated\n   * @param {Array} value - all of the decoded values, wrapped in an Array\n   */\n\n  /**\n   * Decode all of the CBOR items in the input.  This will error if there are\n   * more bytes left over at the end.\n   *\n   * @static\n   * @param {(string|Buffer)} input - the input to parse\n   * @param {(string|Object)} options - Decoding options.\n   *   If string, the input encoding.\n   * @param {decodeAllCallback} cb callback\n   * @returns {Promise<Array>} even if callback is specified\n   */\n\n\n  static decodeAll(input, options, cb) {\n    let opts = {};\n    let encod = 'hex';\n\n    switch (typeof options) {\n      case 'function':\n        cb = options;\n        encod = utils.guessEncoding(input);\n        break;\n\n      case 'string':\n        encod = options;\n        break;\n\n      case 'object':\n        opts = utils.extend({}, options);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n    }\n\n    const c = new Decoder(opts);\n    const vals = [];\n    c.on('data', val => {\n      return vals.push(Decoder.nullcheck(val));\n    });\n    const p = new Promise((resolve, reject) => {\n      c.on('error', reject);\n      c.on('end', () => resolve(vals));\n    });\n\n    if (typeof cb === 'function') {\n      p.then(v => cb(null, v), cb);\n    }\n\n    c.end(input, encod);\n    return p;\n  }\n  /**\n   * Stop processing\n   */\n\n\n  close() {\n    this.running = false;\n    this.__fresh = true;\n  }\n\n  *_parse() {\n    let parent = null;\n    let depth = 0;\n    let val = null;\n\n    while (true) {\n      if (this.max_depth >= 0 && depth > this.max_depth) {\n        throw new Error('Maximum depth ' + this.max_depth + ' exceeded');\n      }\n\n      const octet = (yield 1)[0];\n\n      if (!this.running) {\n        throw new Error('Unexpected data: 0x' + octet.toString(16));\n      }\n\n      const mt = octet >> 5;\n      const ai = octet & 0x1f;\n      const parent_major = parent != null ? parent[MAJOR] : undefined;\n      const parent_length = parent != null ? parent.length : undefined;\n\n      switch (ai) {\n        case NUMBYTES.ONE:\n          this.emit('more-bytes', mt, 1, parent_major, parent_length);\n          val = (yield 1)[0];\n          break;\n\n        case NUMBYTES.TWO:\n        case NUMBYTES.FOUR:\n        case NUMBYTES.EIGHT:\n          const numbytes = 1 << ai - 24;\n          this.emit('more-bytes', mt, numbytes, parent_major, parent_length);\n          const buf = yield numbytes;\n          val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);\n          break;\n\n        case 28:\n        case 29:\n        case 30:\n          this.running = false;\n          throw new Error('Additional info not implemented: ' + ai);\n\n        case NUMBYTES.INDEFINITE:\n          switch (mt) {\n            case MT.POS_INT:\n            case MT.NEG_INT:\n            case MT.TAG:\n              throw new Error(\"Invalid indefinite encoding for MT \".concat(mt));\n          }\n\n          val = -1;\n          break;\n\n        default:\n          val = ai;\n      }\n\n      switch (mt) {\n        case MT.POS_INT:\n          // val already decoded\n          break;\n\n        case MT.NEG_INT:\n          if (val === Number.MAX_SAFE_INTEGER) {\n            val = BN.NEG_MAX;\n          } else if (val instanceof bignumber) {\n            val = BN.MINUS_ONE.minus(val);\n          } else {\n            val = -1 - val;\n          }\n\n          break;\n\n        case MT.BYTE_STRING:\n        case MT.UTF8_STRING:\n          switch (val) {\n            case 0:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = mt === MT.BYTE_STRING ? Buffer.allocUnsafe(0) : '';\n              break;\n\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentBufferStream(parent, mt);\n              depth++;\n              continue;\n\n            default:\n              this.emit('start-string', mt, val, parent_major, parent_length);\n              val = yield val;\n\n              if (mt === MT.UTF8_STRING) {\n                val = utils.utf8(val);\n              }\n\n          }\n\n          break;\n\n        case MT.ARRAY:\n        case MT.MAP:\n          switch (val) {\n            case 0:\n              val = mt === MT.MAP ? {} : [];\n              break;\n\n            case -1:\n              this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);\n              parent = parentArray(parent, mt, -1);\n              depth++;\n              continue;\n\n            default:\n              this.emit('start', mt, val, parent_major, parent_length);\n              parent = parentArray(parent, mt, val * (mt - 3));\n              depth++;\n              continue;\n          }\n\n          break;\n\n        case MT.TAG:\n          this.emit('start', mt, val, parent_major, parent_length);\n          parent = parentArray(parent, mt, 1);\n          parent.push(val);\n          depth++;\n          continue;\n\n        case MT.SIMPLE_FLOAT:\n          if (typeof val === 'number') {\n            if (ai === NUMBYTES.ONE && val < 32) {\n              throw new Error(\"Invalid two-byte encoding of simple value \".concat(val));\n            }\n\n            const hasParent = parent != null;\n            val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);\n          } else {\n            val = utils.parseCBORfloat(val);\n          }\n\n      }\n\n      this.emit('value', val, parent_major, parent_length, ai);\n      let again = false;\n\n      while (parent != null) {\n        switch (false) {\n          case val !== SYMS.BREAK:\n            parent[COUNT] = 1;\n            break;\n\n          case !Array.isArray(parent):\n            parent.push(val);\n            break;\n\n          case !(parent instanceof NoFilter):\n            const pm = parent[MAJOR];\n\n            if (pm != null && pm !== mt) {\n              this.running = false;\n              throw new Error('Invalid major type in indefinite encoding');\n            }\n\n            parent.write(val);\n        }\n\n        if (--parent[COUNT] !== 0) {\n          again = true;\n          break;\n        }\n\n        --depth;\n        delete parent[COUNT];\n\n        if (Array.isArray(parent)) {\n          switch (parent[MAJOR]) {\n            case MT.ARRAY:\n              val = parent;\n              break;\n\n            case MT.MAP:\n              let allstrings = true;\n\n              if (parent.length % 2 !== 0) {\n                throw new Error('Invalid map length: ' + parent.length);\n              }\n\n              for (let i = 0, len = parent.length; i < len; i += 2) {\n                if (typeof parent[i] !== 'string') {\n                  allstrings = false;\n                  break;\n                }\n              }\n\n              if (allstrings) {\n                val = {};\n\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val[parent[i]] = parent[i + 1];\n                }\n              } else {\n                val = new Map();\n\n                for (let i = 0, len = parent.length; i < len; i += 2) {\n                  val.set(parent[i], parent[i + 1]);\n                }\n              }\n\n              break;\n\n            case MT.TAG:\n              const t = new Tagged(parent[0], parent[1]);\n              val = t.convert(this.tags);\n              break;\n          }\n        } else if (parent instanceof NoFilter) {\n          switch (parent[MAJOR]) {\n            case MT.BYTE_STRING:\n              val = parent.slice();\n              break;\n\n            case MT.UTF8_STRING:\n              val = parent.toString('utf-8');\n              break;\n          }\n        }\n\n        this.emit('stop', parent[MAJOR]);\n        const old = parent;\n        parent = parent[SYMS.PARENT];\n        delete old[SYMS.PARENT];\n        delete old[MAJOR];\n      }\n\n      if (!again) {\n        return val;\n      }\n    }\n  }\n\n}\n\nDecoder.NOT_FOUND = NOT_FOUND;\nmodule.exports = Decoder;","map":null,"metadata":{},"sourceType":"script"}