{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.render = exports.parse = void 0;\n\nvar tslib_1 = require(\"tslib\");\n\nvar domhandler_1 = require(\"domhandler\");\n\nvar parse5_1 = require(\"parse5\");\n\nvar parse5_htmlparser2_tree_adapter_1 = tslib_1.__importDefault(require(\"parse5-htmlparser2-tree-adapter\"));\n\nfunction parse(content, options, isDocument) {\n  var opts = {\n    scriptingEnabled: typeof options.scriptingEnabled === 'boolean' ? options.scriptingEnabled : true,\n    treeAdapter: parse5_htmlparser2_tree_adapter_1.default,\n    sourceCodeLocationInfo: options.sourceCodeLocationInfo\n  };\n  var context = options.context; // @ts-expect-error The tree adapter unfortunately doesn't return the exact types.\n\n  return isDocument ? parse5_1.parse(content, opts) : // @ts-expect-error Same issue again.\n  parse5_1.parseFragment(context, content, opts);\n}\n\nexports.parse = parse;\n\nfunction render(dom) {\n  var _a;\n  /*\n   * `dom-serializer` passes over the special \"root\" node and renders the\n   * node's children in its place. To mimic this behavior with `parse5`, an\n   * equivalent operation must be applied to the input array.\n   */\n\n\n  var nodes = 'length' in dom ? dom : [dom];\n\n  for (var index = 0; index < nodes.length; index += 1) {\n    var node = nodes[index];\n\n    if (domhandler_1.isDocument(node)) {\n      (_a = Array.prototype.splice).call.apply(_a, tslib_1.__spreadArray([nodes, index, 1], node.children));\n    }\n  } // @ts-expect-error Types don't align here either.\n\n\n  return parse5_1.serialize({\n    children: nodes\n  }, {\n    treeAdapter: parse5_htmlparser2_tree_adapter_1.default\n  });\n}\n\nexports.render = render;","map":null,"metadata":{},"sourceType":"script"}