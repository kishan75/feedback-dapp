{"ast":null,"code":"const Reason = require(\"./reason\");\n\nconst handlers = require(\"./handlers\");\n\nconst override = {\n  timeoutMessage: \"not mined within\",\n  // Substring of timeout err fired by web3\n  defaultWeb3Error: \"please check your gas limit\",\n  // Substring of default Web3 error\n  defaultMaxBlocks: 50,\n  // Max # of blocks web3 will wait for a tx\n  pollingInterval: 1000,\n\n  /**\n   * Attempts to extract receipt object from Web3 error message\n   * @param  {Object} message       web3 error\n   * @return {Object|undefined} receipt\n   */\n  extractReceipt(message) {\n    const hasReceipt = message && message.includes(\"{\");\n    message.includes(\"}\");\n\n    if (hasReceipt) {\n      const receiptString = \"{\" + message.split(\"{\")[1].trim();\n\n      try {\n        return JSON.parse(receiptString);\n      } catch (err) {// ignore\n      }\n    }\n  },\n\n  /**\n   * Fired after web3 ceases to support subscriptions if user has specified\n   * a higher block wait time than web3's 50 blocks limit. Opens a subscription to listen\n   * for new blocks and begins evaluating whether block height has reached the user\n   * defined timeout threshhold. Resolves either a contract instance or a transaction receipt.\n   *\n   * @param  {Object} context execution state\n   * @param  {Object} err     error\n   */\n  start: async function (context, web3Error) {\n    const constructor = this;\n    let currentBlock = override.defaultMaxBlocks; // Reject after attempting to get reason string if we shouldn't be waiting.\n\n    if (!handlers.ignoreTimeoutError(context, web3Error)) {\n      // We might have been routed here in web3 >= beta.34 by their own status check\n      // error. We want to extract the receipt, emit a receipt event\n      // and reject it ourselves.\n      const receipt = override.extractReceipt(web3Error.message);\n\n      if (receipt) {\n        await handlers.receipt(context, receipt);\n        return;\n      } // This will run if there's a reason and no status field\n      // e.g: revert with reason ganache-cli --vmErrorsOnRPCResponse=true\n\n\n      const reason = await Reason.get(context.params, constructor.web3, constructor.interfaceAdapter);\n\n      if (reason) {\n        web3Error.reason = reason;\n        web3Error.message += \" -- Reason given: \".concat(reason, \".\");\n      }\n\n      return context.promiEvent.reject(web3Error);\n    } // This will run every block from now until contract.timeoutBlocks\n\n\n    const listener = function (pollID) {\n      currentBlock++;\n\n      if (currentBlock > constructor.timeoutBlocks) {\n        clearInterval(pollID);\n        return;\n      }\n\n      constructor.interfaceAdapter.getTransactionReceipt(context.transactionHash).then(result => {\n        if (!result) return; // make sure reporter receives tx receipt promievent\n\n        handlers.receipt(context, result);\n        result.contractAddress ? constructor.at(result.contractAddress).then(context.promiEvent.resolve).catch(context.promiEvent.reject) : constructor.promiEvent.resolve(result);\n      }).catch(err => {\n        clearInterval(pollID);\n        context.promiEvent.reject(err);\n      });\n    }; // Start polling\n\n\n    let currentPollingBlock = await constructor.interfaceAdapter.getBlockNumber();\n    const pollID = setInterval(async () => {\n      const newBlock = await constructor.interfaceAdapter.getBlockNumber();\n\n      if (newBlock > currentPollingBlock) {\n        currentPollingBlock = newBlock;\n        listener(pollID);\n      }\n    }, override.pollingInterval);\n  }\n};\nmodule.exports = override;","map":null,"metadata":{},"sourceType":"script"}