{"ast":null,"code":"\"use strict\";\n/**\n * # Truffle Codec\n *\n * This module provides low-level decoding and encoding functionality for\n * Solidity and the Solidity ABI.  Many parts of this module are intended\n * primarily for internal use by Truffle and so remain largely undocumented,\n * but some of its types are also output by @truffle/decoder, which provides\n * a higher-level interface to much of this module's functionality.\n *\n * ## If you're here from Truffle Decoder\n *\n * If you're coming here from [[@truffle/decoder]], you probably just want to\n * know about the parts that are relevant to you.  These are:\n *\n * * The \"data\" category (specifically [[Format]])\n * * The \"output\" and \"enumerations\" categories ([[CalldataDecoding]], [[LogDecoding]], et al., see below)\n * * The \"errors\" category (specifically [[UnknownUserDefinedTypeError]])\n *\n * Note that the data category is largely scarce in\n * documentation, although that's because it's largely self-explanatory.\n *\n * If you're not just here from Truffle Decoder, but are actually\n * interested in the lower-level workings, read on.\n *\n * ## How this module differs from Truffle Decoder\n *\n * Unlike Truffle Decoder, this library makes no network connections\n * and avoids dependencies that do.  Instead, its decoding functionality\n * is generator-based; calling one of the decoding functions returns a\n * generator.  This generator's `next()` function may return a finished\n * result, or it may return a request for more information.  It is up to\n * the caller to fulfill these requests -- say, by making a network\n * connection of its own.  This is how @truffle/decoder works; @truffle/codec\n * makes requests, and @truffle/decoder fulfills them by\n * looking up the necessary information on the blockchain.\n *\n * This library also provides additional functionality beyond what's used by\n * Truffle Decoder.  In particular, this library also exists to support Truffle\n * Debugger, and so it provides encoding functionality not just for\n * transactions, logs, and state variables, but also for Solidity variables\n * during transaction execution, including circularity detection for memroy\n * structures.  It includes functionality for decoding Solidity's internal\n * function pointers, which the debugger uses, but which Truffle Decoder\n * currently does not (although this is planned for the future).\n *\n * There is also functionality for decoding return values and revert messages\n * that goes beyond what's currently available in @truffle/decoder; this may get\n * a better interface in the future.\n *\n * ## How to use\n *\n * You should probably use [[@truffle/decoder]] instead, if your use case doesn't\n * preclude it.  This module has little documentation, where it has any at all,\n * and it's likely that parts of its interface may change (particularly\n * regarding allocation).  That said, if you truly need the functionality here,\n * Truffle Decoder can perhaps serve as something of a reference implementation\n * (and perhaps Truffle Debugger as well, though that code is much harder to\n * read or copy).\n *\n * @module @truffle/codec\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __exportStar = this && this.__exportStar || function (m, exports) {\n  for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Export = exports.Evm = exports.Conversion = exports.Contexts = exports.Compilations = exports.Compiler = exports.Ast = exports.AstConstant = exports.Storage = exports.Stack = exports.Special = exports.Memory = exports.MappingKey = exports.Topic = exports.AbiData = exports.Bytes = exports.Basic = exports.abifyReturndataDecoding = exports.abifyLogDecoding = exports.abifyCalldataDecoding = exports.StopDecodingError = exports.DecodingError = exports.decodeRevert = exports.decodeReturndata = exports.decodeCalldata = exports.decodeEvent = exports.decodeVariable = exports.Format = void 0; //So, what shall codec export...?\n//First: export the data format\n\nconst Format = __importStar(require(\"./format\"));\n\nexports.Format = Format; //now... various low-level stuff we want to export!\n//the actual decoding functions and related errors\n\nvar core_1 = require(\"./core\");\n\nObject.defineProperty(exports, \"decodeVariable\", {\n  enumerable: true,\n  get: function () {\n    return core_1.decodeVariable;\n  }\n});\nObject.defineProperty(exports, \"decodeEvent\", {\n  enumerable: true,\n  get: function () {\n    return core_1.decodeEvent;\n  }\n});\nObject.defineProperty(exports, \"decodeCalldata\", {\n  enumerable: true,\n  get: function () {\n    return core_1.decodeCalldata;\n  }\n});\nObject.defineProperty(exports, \"decodeReturndata\", {\n  enumerable: true,\n  get: function () {\n    return core_1.decodeReturndata;\n  }\n});\nObject.defineProperty(exports, \"decodeRevert\", {\n  enumerable: true,\n  get: function () {\n    return core_1.decodeRevert;\n  }\n});\n\nvar errors_1 = require(\"./errors\");\n\nObject.defineProperty(exports, \"DecodingError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.DecodingError;\n  }\n});\nObject.defineProperty(exports, \"StopDecodingError\", {\n  enumerable: true,\n  get: function () {\n    return errors_1.StopDecodingError;\n  }\n});\n\n__exportStar(require(\"./common\"), exports);\n\nvar abify_1 = require(\"./abify\");\n\nObject.defineProperty(exports, \"abifyCalldataDecoding\", {\n  enumerable: true,\n  get: function () {\n    return abify_1.abifyCalldataDecoding;\n  }\n});\nObject.defineProperty(exports, \"abifyLogDecoding\", {\n  enumerable: true,\n  get: function () {\n    return abify_1.abifyLogDecoding;\n  }\n});\nObject.defineProperty(exports, \"abifyReturndataDecoding\", {\n  enumerable: true,\n  get: function () {\n    return abify_1.abifyReturndataDecoding;\n  }\n}); // data locations - common\n\nconst Basic = __importStar(require(\"./basic\"));\n\nexports.Basic = Basic;\n\nconst Bytes = __importStar(require(\"./bytes\"));\n\nexports.Bytes = Bytes; // data locations - abi\n\nconst AbiData = __importStar(require(\"./abi-data\"));\n\nexports.AbiData = AbiData;\n\nconst Topic = __importStar(require(\"./topic\"));\n\nexports.Topic = Topic; // data locations - solidity\n\nconst MappingKey = __importStar(require(\"./mapping-key\"));\n\nexports.MappingKey = MappingKey;\n\nconst Memory = __importStar(require(\"./memory\"));\n\nexports.Memory = Memory;\n\nconst Special = __importStar(require(\"./special\"));\n\nexports.Special = Special;\n\nconst Stack = __importStar(require(\"./stack\"));\n\nexports.Stack = Stack;\n\nconst Storage = __importStar(require(\"./storage\"));\n\nexports.Storage = Storage;\n\nconst AstConstant = __importStar(require(\"./ast-constant\"));\n\nexports.AstConstant = AstConstant;\n\nconst Ast = __importStar(require(\"./ast\"));\n\nexports.Ast = Ast;\n\nconst Compiler = __importStar(require(\"./compiler\"));\n\nexports.Compiler = Compiler;\n\nconst Compilations = __importStar(require(\"./compilations\"));\n\nexports.Compilations = Compilations;\n\nconst Contexts = __importStar(require(\"./contexts\"));\n\nexports.Contexts = Contexts;\n\nconst Conversion = __importStar(require(\"./conversion\"));\n\nexports.Conversion = Conversion;\n\nconst Evm = __importStar(require(\"./evm\"));\n\nexports.Evm = Evm;\n\nconst Export = __importStar(require(\"./export\"));\n\nexports.Export = Export;","map":null,"metadata":{},"sourceType":"script"}