{"ast":null,"code":"import { Stream, stream } from '../../stream/Stream.js';\nimport { readConfigureGlobal } from './configuration/GlobalParameters.js';\nimport { QualifiedParameters } from './configuration/QualifiedParameters.js';\nimport { decorateProperty } from './DecorateProperty.js';\nimport { RunnerIterator } from './RunnerIterator.js';\nimport { SourceValuesIterator } from './SourceValuesIterator.js';\nimport { toss } from './Tosser.js';\nimport { pathWalk } from './utils/PathWalker.js';\nimport { asyncReportRunDetails, reportRunDetails } from './utils/RunDetailsFormatter.js';\n\nfunction runIt(property, shrink, sourceValues, verbose, interruptedAsFailure) {\n  const runner = new RunnerIterator(sourceValues, shrink, verbose, interruptedAsFailure);\n\n  for (const v of runner) {\n    const out = property.run(v);\n    runner.handleResult(out);\n  }\n\n  return runner.runExecution;\n}\n\nasync function asyncRunIt(property, shrink, sourceValues, verbose, interruptedAsFailure) {\n  const runner = new RunnerIterator(sourceValues, shrink, verbose, interruptedAsFailure);\n\n  for (const v of runner) {\n    const out = await property.run(v);\n    runner.handleResult(out);\n  }\n\n  return runner.runExecution;\n}\n\nfunction runnerPathWalker(valueProducers, shrink, path) {\n  const pathPoints = path.split(':');\n  const pathStream = stream(valueProducers).drop(pathPoints.length > 0 ? +pathPoints[0] : 0).map(producer => producer());\n  const adaptedPath = ['0', ...pathPoints.slice(1)].join(':');\n  return stream(pathWalk(adaptedPath, pathStream, shrink)).map(v => () => v);\n}\n\nfunction buildInitialValues(valueProducers, shrink, qParams) {\n  if (qParams.path.length === 0) {\n    return stream(valueProducers);\n  }\n\n  return runnerPathWalker(valueProducers, shrink, qParams.path);\n}\n\nfunction check(rawProperty, params) {\n  if (rawProperty == null || rawProperty.generate == null) throw new Error('Invalid property encountered, please use a valid property');\n  if (rawProperty.run == null) throw new Error('Invalid property encountered, please use a valid property not an arbitrary');\n  const qParams = QualifiedParameters.read(Object.assign(Object.assign({}, readConfigureGlobal()), params));\n  if (qParams.reporter !== null && qParams.asyncReporter !== null) throw new Error('Invalid parameters encountered, reporter and asyncReporter cannot be specified together');\n  if (qParams.asyncReporter !== null && !rawProperty.isAsync()) throw new Error('Invalid parameters encountered, only asyncProperty can be used when asyncReporter specified');\n  const property = decorateProperty(rawProperty, qParams);\n  const generator = toss(property, qParams.seed, qParams.randomType, qParams.examples);\n  const maxInitialIterations = qParams.path.indexOf(':') === -1 ? qParams.numRuns : -1;\n  const maxSkips = qParams.numRuns * qParams.maxSkipsPerRun;\n  const shrink = property.shrink.bind(property);\n  const initialValues = buildInitialValues(generator, shrink, qParams);\n  const sourceValues = new SourceValuesIterator(initialValues, maxInitialIterations, maxSkips);\n  const finalShrink = !qParams.endOnFailure ? shrink : Stream.nil;\n  return property.isAsync() ? asyncRunIt(property, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).then(e => e.toRunDetails(qParams.seed, qParams.path, maxSkips, qParams)) : runIt(property, finalShrink, sourceValues, qParams.verbose, qParams.markInterruptAsFailure).toRunDetails(qParams.seed, qParams.path, maxSkips, qParams);\n}\n\nfunction assert(property, params) {\n  const out = check(property, params);\n  if (property.isAsync()) return out.then(asyncReportRunDetails);else reportRunDetails(out);\n}\n\nexport { check, assert };","map":null,"metadata":{},"sourceType":"module"}