{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abifyReturndataDecoding = exports.abifyLogDecoding = exports.abifyCalldataDecoding = exports.abifyResult = exports.abifyType = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abify\");\n\nconst Format = __importStar(require(\"./format\"));\n\nconst Common = __importStar(require(\"./common\"));\n\nconst Conversion = __importStar(require(\"./conversion\"));\n/** @category ABIfication */\n\n\nfunction abifyType(dataType, userDefinedTypes) {\n  switch (dataType.typeClass) {\n    //we only need to specially handle types that don't go in\n    //the ABI, or that have some information loss when going\n    //in the ABI\n    //note that we do need to handle arrays, due to recursion!\n    //First: types that do not go in the ABI\n    case \"mapping\":\n    case \"magic\":\n    case \"type\":\n      return undefined;\n    //Next: address & contract, these can get handled together\n\n    case \"address\":\n    case \"contract\":\n      return {\n        typeClass: \"address\",\n        kind: \"general\",\n        typeHint: Format.Types.typeString(dataType)\n      };\n\n    case \"function\":\n      switch (dataType.visibility) {\n        case \"external\":\n          return {\n            typeClass: \"function\",\n            visibility: \"external\",\n            kind: \"general\",\n            typeHint: Format.Types.typeString(dataType)\n          };\n\n        case \"internal\":\n          //these don't go in the ABI\n          return undefined;\n      }\n\n      break;\n    //to satisfy TypeScript\n    //the complex cases: struct & enum\n\n    case \"struct\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n\n        if (!fullType.memberTypes) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n\n        const memberTypes = fullType.memberTypes.map(({\n          name,\n          type: memberType\n        }) => ({\n          name,\n          type: abifyType(memberType, userDefinedTypes)\n        }));\n        return {\n          typeClass: \"tuple\",\n          typeHint: Format.Types.typeString(fullType),\n          memberTypes\n        };\n      }\n\n    case \"enum\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n\n        if (!fullType.options) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n\n        let numOptions = fullType.options.length;\n        let bits = 8 * Math.ceil(Math.log2(numOptions) / 8);\n        return {\n          typeClass: \"uint\",\n          bits,\n          typeHint: Format.Types.typeString(fullType)\n        };\n      }\n\n    case \"userDefinedValueType\":\n      {\n        const fullType = Format.Types.fullType(dataType, userDefinedTypes);\n\n        if (!fullType.underlyingType) {\n          let typeToDisplay = Format.Types.typeString(dataType);\n          throw new Common.UnknownUserDefinedTypeError(dataType.id, typeToDisplay);\n        }\n\n        const abifiedUnderlying = abifyType(fullType.underlyingType, userDefinedTypes);\n        return Object.assign(Object.assign({}, abifiedUnderlying), {\n          typeHint: Format.Types.typeStringWithoutLocation(dataType)\n        });\n      }\n    //finally: arrays\n\n    case \"array\":\n      return Object.assign(Object.assign({}, dataType), {\n        typeHint: Format.Types.typeString(dataType),\n        baseType: abifyType(dataType.baseType, userDefinedTypes)\n      });\n    //default case: just leave as-is\n\n    default:\n      return dataType;\n  }\n}\n\nexports.abifyType = abifyType;\n/** @category ABIfication */\n\nfunction abifyResult(result, userDefinedTypes) {\n  switch (result.type.typeClass) {\n    case \"mapping\": //doesn't go in ABI\n\n    case \"magic\": //doesn't go in ABI\n\n    case \"type\":\n      //doesn't go in ABI\n      return undefined;\n\n    case \"address\":\n      //abify the type but leave the value alone\n      return Object.assign(Object.assign({}, result), {\n        type: abifyType(result.type, userDefinedTypes)\n      });\n\n    case \"contract\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            return {\n              type: abifyType(result.type, userDefinedTypes),\n              kind: \"value\",\n              value: {\n                asAddress: coercedResult.value.address,\n                rawAsHex: coercedResult.value.rawAddress\n              }\n            };\n\n          case \"error\":\n            switch (coercedResult.error.kind) {\n              case \"ContractPaddingError\":\n                return {\n                  type: abifyType(result.type, userDefinedTypes),\n                  kind: \"error\",\n                  error: {\n                    kind: \"AddressPaddingError\",\n                    paddingType: coercedResult.error.paddingType,\n                    raw: coercedResult.error.raw\n                  }\n                };\n\n              default:\n                //other contract errors are generic errors!\n                //but TS doesn't know this so we coerce\n                return Object.assign(Object.assign({}, coercedResult), {\n                  type: abifyType(result.type, userDefinedTypes)\n                });\n            }\n\n        }\n\n        break; //to satisfy typescript\n      }\n\n    case \"function\":\n      switch (result.type.visibility) {\n        case \"external\":\n          {\n            let coercedResult = result;\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n          }\n\n        case \"internal\":\n          //these don't go in the ABI\n          return undefined;\n      }\n\n      break;\n    //to satisfy TypeScript\n\n    case \"struct\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            if (coercedResult.reference !== undefined) {\n              return undefined; //no circular values in the ABI!\n            }\n\n            let abifiedMembers = coercedResult.value.map(({\n              name,\n              value: member\n            }) => ({\n              name,\n              value: abifyResult(member, userDefinedTypes)\n            }));\n            return {\n              kind: \"value\",\n              type: abifyType(result.type, userDefinedTypes),\n              value: abifiedMembers\n            };\n\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes) //note: may throw exception\n\n            });\n        }\n      }\n\n    case \"userDefinedValueType\":\n      {\n        const coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            return abifyResult(coercedResult.value, userDefinedTypes);\n\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n        }\n\n        break; //to satisfy TS :P\n      }\n\n    case \"enum\":\n      {\n        //NOTE: this is the one case where errors are converted to non-error values!!\n        //(other than recursively, I mean)\n        //be aware!\n        let coercedResult = result;\n        let uintType = abifyType(result.type, userDefinedTypes); //may throw exception\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            return {\n              type: uintType,\n              kind: \"value\",\n              value: {\n                asBN: coercedResult.value.numericAsBN.clone()\n              }\n            };\n\n          case \"error\":\n            switch (coercedResult.error.kind) {\n              case \"EnumOutOfRangeError\":\n                return {\n                  type: uintType,\n                  kind: \"value\",\n                  value: {\n                    asBN: coercedResult.error.rawAsBN.clone()\n                  }\n                };\n\n              case \"EnumPaddingError\":\n                return {\n                  type: uintType,\n                  kind: \"error\",\n                  error: {\n                    kind: \"UintPaddingError\",\n                    paddingType: coercedResult.error.paddingType,\n                    raw: coercedResult.error.raw\n                  }\n                };\n\n              case \"EnumNotFoundDecodingError\":\n                let numericValue = coercedResult.error.rawAsBN.clone();\n\n                if (numericValue.bitLength() <= uintType.bits) {\n                  return {\n                    type: uintType,\n                    kind: \"value\",\n                    value: {\n                      asBN: numericValue\n                    }\n                  };\n                } else {\n                  return {\n                    type: uintType,\n                    kind: \"error\",\n                    error: {\n                      kind: \"UintPaddingError\",\n                      paddingType: \"left\",\n                      raw: Conversion.toHexString(numericValue)\n                    }\n                  };\n                }\n\n              default:\n                return {\n                  type: uintType,\n                  kind: \"error\",\n                  error: coercedResult.error\n                };\n            }\n\n        }\n      }\n\n    case \"array\":\n      {\n        let coercedResult = result;\n\n        switch (coercedResult.kind) {\n          case \"value\":\n            if (coercedResult.reference !== undefined) {\n              return undefined; //no circular values in the ABI!\n            }\n\n            let abifiedMembers = coercedResult.value.map(member => abifyResult(member, userDefinedTypes));\n            return {\n              kind: \"value\",\n              type: abifyType(result.type, userDefinedTypes),\n              value: abifiedMembers\n            };\n\n          case \"error\":\n            return Object.assign(Object.assign({}, coercedResult), {\n              type: abifyType(result.type, userDefinedTypes)\n            });\n        }\n      }\n\n    default:\n      return result;\n    //just coerce :-/\n  }\n}\n\nexports.abifyResult = abifyResult;\n/** @category ABIfication */\n\nfunction abifyCalldataDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n\n  switch (decoding.kind) {\n    case \"function\":\n    case \"constructor\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n          value: abifyResult(argument.value, userDefinedTypes)\n        }))\n      });\n\n    default:\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\"\n      });\n  }\n}\n\nexports.abifyCalldataDecoding = abifyCalldataDecoding;\n/** @category ABIfication */\n\nfunction abifyLogDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n\n  return Object.assign(Object.assign({}, decoding), {\n    decodingMode: \"abi\",\n    arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n      value: abifyResult(argument.value, userDefinedTypes)\n    }))\n  });\n}\n\nexports.abifyLogDecoding = abifyLogDecoding;\n/** @category ABIfication */\n\nfunction abifyReturndataDecoding(decoding, userDefinedTypes) {\n  if (decoding.decodingMode === \"abi\") {\n    return decoding;\n  }\n\n  switch (decoding.kind) {\n    case \"return\":\n    case \"revert\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        arguments: decoding.arguments.map(argument => Object.assign(Object.assign({}, argument), {\n          value: abifyResult(argument.value, userDefinedTypes)\n        }))\n      });\n\n    case \"bytecode\":\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\",\n        immutables: undefined\n      });\n\n    default:\n      return Object.assign(Object.assign({}, decoding), {\n        decodingMode: \"abi\"\n      });\n  }\n}\n\nexports.abifyReturndataDecoding = abifyReturndataDecoding;","map":null,"metadata":{},"sourceType":"script"}