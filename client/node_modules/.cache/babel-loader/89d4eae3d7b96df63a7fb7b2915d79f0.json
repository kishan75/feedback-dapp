{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readBytes = exports.readCode = void 0;\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* readCode(pointer, state) {\n  let code = state.code;\n\n  if (!code) {\n    code = yield {\n      type: \"code\",\n      address: Evm.Utils.toAddress(state.specials.this)\n    };\n  }\n\n  return readBytes(pointer, Object.assign(Object.assign({}, state), {\n    code\n  }));\n}\n\nexports.readCode = readCode;\n\nfunction readBytes(pointer, state) {\n  let sourceBytes = state[pointer.location];\n  const offset = pointer.start,\n        length = pointer.length;\n\n  if (!Number.isSafeInteger(offset + length)) {\n    throw new errors_1.DecodingError({\n      kind: \"ReadErrorBytes\",\n      location: pointer.location,\n      start: offset,\n      length\n    });\n  } // grab `length` bytes no matter what, here fill this array\n\n\n  var bytes = new Uint8Array(length);\n  bytes.fill(0); //fill it wil zeroes to start\n  //if the start is beyond the end of the source, just return those 0s\n\n  if (offset >= sourceBytes.length) {\n    return bytes;\n  } // if we're reading past the end of the source, truncate the length to read\n\n\n  let excess = offset + length - sourceBytes.length;\n  let readLength;\n\n  if (excess > 0) {\n    readLength = sourceBytes.length - offset;\n  } else {\n    readLength = length;\n  } //get the (truncated) bytes\n\n\n  let existing = new Uint8Array(sourceBytes.buffer, offset, readLength); //copy it into our buffer\n\n  bytes.set(existing);\n  return bytes;\n}\n\nexports.readBytes = readBytes;","map":null,"metadata":{},"sourceType":"script"}