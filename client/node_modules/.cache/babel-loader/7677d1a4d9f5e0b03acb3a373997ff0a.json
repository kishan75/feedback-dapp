{"ast":null,"code":"'use strict';\n\nvar _slicedToArray = require(\"F:\\\\BlockChain\\\\Projects\\\\feedback-dapp\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nconst stream = require('stream');\n\nconst url = require('url');\n\nconst bignumber = require('bignumber.js').BigNumber;\n\nconst NoFilter = require('nofilter');\n\nconst Tagged = require('./tagged');\n\nconst Simple = require('./simple');\n\nconst utils = require('./utils');\n\nconst constants = require('./constants');\n\nconst MT = constants.MT;\nconst NUMBYTES = constants.NUMBYTES;\nconst SHIFT32 = constants.SHIFT32;\nconst SYMS = constants.SYMS;\nconst TAG = constants.TAG;\nconst HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;\nconst FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;\nconst DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;\nconst TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;\nconst FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;\nconst UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;\nconst NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;\nconst BREAK = Buffer.from([0xff]);\nconst BI = utils.bigIntize(constants.BI);\nconst BN = constants.BN;\nconst BUF_NAN = Buffer.from('f97e00', 'hex');\nconst BUF_INF_NEG = Buffer.from('f9fc00', 'hex');\nconst BUF_INF_POS = Buffer.from('f97c00', 'hex');\nconst BUF_NEG_ZERO = Buffer.from('f98000', 'hex');\nconst LOOP_DETECT = Symbol('CBOR_LOOP_DETECT');\n/**\n * Transform JavaScript values into CBOR bytes.  The `Writable` side of\n * the stream is in object mode.\n *\n * @extends {stream.Transform}\n */\n\nclass Encoder extends stream.Transform {\n  /**\n   * Creates an instance of Encoder.\n   *\n   * @param {Object} [options={}] - options for the encoder\n   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,\n   *   `function(Encoder)` for semantic types to be encoded.  Not needed\n   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.\n   * @param {boolean} [options.canonical=false] - should the output be\n   *   canonicalized\n   * @param {boolean|Symbol} [options.detectLoops=false] - should object loops\n   *   be detected?  This will currently modify the encoded object graph\n   *   by adding a Symbol property to each object.  If this bothers you,\n   *   call `removeLoopDetectors` on the encoded object when done.  Do not\n   *   encode the same object twice on the same encoder, without calling\n   *   `removeLoopDetectors` in between.\n   * @param {(\"number\"|\"float\"|\"int\"|\"string\")} [options.dateType=\"number\"] -\n   *   how should dates be encoded?  \"number\" means float or int, if no\n   *   fractional seconds.\n   * @param {any} [options.encodeUndefined=undefined] - How should an \n   *   \"undefined\" in the input be encoded.  By default, just encode a CBOR\n   *   undefined.  If this is a buffer, use those bytes without re-encoding\n   *   them.  If this is a function, the function will be called (which is\n   *   a good time to throw an exception, if that's what you want), and the\n   *   return value will be used according to these rules.  Anything\n   *   else will be encoded as CBOR.\n   * @param {boolean} [options.disallowUndefinedKeys=false] - Should \"undefined\"\n   *   be disallowed as a key in a Map that is serialized?  If this is true,\n   *   encode(new Map([[undefined, 1]])) will throw an exception.  Note that\n   *   it is impossible to get a key of undefined in a normal JS object.\n   * @param {boolean} [options.collapseBigIntegers=false] - Should integers\n   *   that come in as BigNumber integers and ECMAscript bigint's be encoded\n   *   as normal CBOR integers if they fit, discarding type information?\n   */\n  constructor(options) {\n    const opts = Object.assign({}, options, {\n      readableObjectMode: false,\n      writableObjectMode: true\n    });\n    super(opts);\n    this.canonical = opts.canonical;\n    this.encodeUndefined = opts.encodeUndefined;\n    this.disallowUndefinedKeys = !!opts.disallowUndefinedKeys;\n    this.dateType = opts.dateType != null ? opts.dateType.toLowerCase() : 'number';\n    this.collapseBigIntegers = !!opts.collapseBigIntegers; // new Symbol for each instance.  Note: means we can't re-use the same\n    // encoder and encoded object\n\n    if (typeof opts.detectLoops === 'symbol') {\n      this.detectLoops = opts.detectLoops;\n    } else {\n      this.detectLoops = !!opts.detectLoops ? Symbol('CBOR_DETECT') : null;\n    }\n\n    this.semanticTypes = {\n      Array: this._pushArray,\n      Date: this._pushDate,\n      Buffer: this._pushBuffer,\n      Map: this._pushMap,\n      NoFilter: this._pushNoFilter,\n      RegExp: this._pushRegexp,\n      Set: this._pushSet,\n      BigNumber: this._pushBigNumber,\n      ArrayBuffer: this._pushUint8Array,\n      Uint8ClampedArray: this._pushUint8Array,\n      Uint8Array: this._pushUint8Array,\n      Uint16Array: this._pushArray,\n      Uint32Array: this._pushArray,\n      Int8Array: this._pushArray,\n      Int16Array: this._pushArray,\n      Int32Array: this._pushArray,\n      Float32Array: this._pushFloat32Array,\n      Float64Array: this._pushFloat64Array\n    }; // tsc doesn't know about old Url\n\n    if (url['Url']) {\n      this.addSemanticType('Url', this._pushUrl);\n    }\n\n    if (url['URL']) {\n      this.addSemanticType('URL', this._pushURL);\n    }\n\n    const addTypes = opts.genTypes || [];\n\n    for (let i = 0, len = addTypes.length; i < len; i += 2) {\n      this.addSemanticType(addTypes[i], addTypes[i + 1]);\n    }\n  }\n\n  _transform(fresh, encoding, cb) {\n    const ret = this.pushAny(fresh); // Old transformers might not return bool.  undefined !== false\n\n    return cb(ret === false ? new Error('Push Error') : undefined);\n  }\n\n  _flush(cb) {\n    return cb();\n  }\n  /**\n   * @callback encodeFunction\n   * @param {Encoder} encoder - the encoder to serialize into.  Call \"write\"\n   *   on the encoder as needed.\n   * @return {bool} - true on success, else false\n   */\n\n  /**\n   * Add an encoding function to the list of supported semantic types.  This is\n   * useful for objects for which you can't add an encodeCBOR method\n   *\n   * @param {any} type\n   * @param {any} fun\n   * @returns {encodeFunction}\n   */\n\n\n  addSemanticType(type, fun) {\n    if (typeof fun !== 'function') {\n      throw new TypeError('fun must be of type function');\n    }\n\n    const typeName = typeof type === 'string' ? type : type.name;\n    const old = this.semanticTypes[typeName];\n    this.semanticTypes[typeName] = fun;\n    return old;\n  }\n\n  _pushUInt8(val) {\n    const b = Buffer.allocUnsafe(1);\n    b.writeUInt8(val, 0);\n    return this.push(b);\n  }\n\n  _pushUInt16BE(val) {\n    const b = Buffer.allocUnsafe(2);\n    b.writeUInt16BE(val, 0);\n    return this.push(b);\n  }\n\n  _pushUInt32BE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeUInt32BE(val, 0);\n    return this.push(b);\n  }\n\n  _pushFloatBE(val) {\n    const b = Buffer.allocUnsafe(4);\n    b.writeFloatBE(val, 0);\n    return this.push(b);\n  }\n\n  _pushDoubleBE(val) {\n    const b = Buffer.allocUnsafe(8);\n    b.writeDoubleBE(val, 0);\n    return this.push(b);\n  }\n\n  _pushNaN() {\n    return this.push(BUF_NAN);\n  }\n\n  _pushInfinity(obj) {\n    const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;\n    return this.push(half);\n  }\n\n  _pushFloat(obj) {\n    if (this.canonical) {\n      // TODO: is this enough slower to hide behind canonical?\n      // It's certainly enough of a hack (see utils.parseHalf)\n      // From section 3.9:\n      // If a protocol allows for IEEE floats, then additional canonicalization\n      // rules might need to be added.  One example rule might be to have all\n      // floats start as a 64-bit float, then do a test conversion to a 32-bit\n      // float; if the result is the same numeric value, use the shorter value\n      // and repeat the process with a test conversion to a 16-bit float.  (This\n      // rule selects 16-bit float for positive and negative Infinity as well.)\n      // which seems pretty much backwards to me.\n      const b2 = Buffer.allocUnsafe(2);\n\n      if (utils.writeHalf(b2, obj)) {\n        // I have convinced myself that there are no cases where writeHalf\n        // will return true but `utils.parseHalf(b2) !== obj)`\n        return this._pushUInt8(HALF) && this.push(b2);\n      }\n    }\n\n    if (Math.fround(obj) === obj) {\n      return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);\n    }\n\n    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);\n  }\n\n  _pushInt(obj, mt, orig) {\n    const m = mt << 5;\n\n    switch (false) {\n      case !(obj < 24):\n        return this._pushUInt8(m | obj);\n\n      case !(obj <= 0xff):\n        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);\n\n      case !(obj <= 0xffff):\n        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);\n\n      case !(obj <= 0xffffffff):\n        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);\n\n      case !(obj <= Number.MAX_SAFE_INTEGER):\n        return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);\n\n      default:\n        if (mt === MT.NEG_INT) {\n          return this._pushFloat(orig);\n        } else {\n          return this._pushFloat(obj);\n        }\n\n    }\n  }\n\n  _pushIntNum(obj) {\n    if (Object.is(obj, -0)) {\n      return this.push(BUF_NEG_ZERO);\n    }\n\n    if (obj < 0) {\n      return this._pushInt(-obj - 1, MT.NEG_INT, obj);\n    } else {\n      return this._pushInt(obj, MT.POS_INT);\n    }\n  }\n\n  _pushNumber(obj) {\n    switch (false) {\n      case !isNaN(obj):\n        return this._pushNaN();\n\n      case isFinite(obj):\n        return this._pushInfinity(obj);\n\n      case Math.round(obj) !== obj:\n        return this._pushIntNum(obj);\n\n      default:\n        return this._pushFloat(obj);\n    }\n  }\n\n  _pushString(obj) {\n    const len = Buffer.byteLength(obj, 'utf8');\n    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');\n  }\n\n  _pushBoolean(obj) {\n    return this._pushUInt8(obj ? TRUE : FALSE);\n  }\n\n  _pushUndefined(obj) {\n    switch (typeof this.encodeUndefined) {\n      case 'undefined':\n        return this._pushUInt8(UNDEFINED);\n\n      case 'function':\n        return this.pushAny(this.encodeUndefined.call(this, obj));\n\n      case 'object':\n        if (Buffer.isBuffer(this.encodeUndefined)) {\n          return this.push(this.encodeUndefined);\n        }\n\n    }\n\n    return this.pushAny(this.encodeUndefined);\n  }\n\n  _pushNull(obj) {\n    return this._pushUInt8(NULL);\n  }\n\n  _pushArray(gen, obj, opts) {\n    opts = Object.assign({\n      indefinite: false\n    }, opts);\n    const len = obj.length;\n\n    if (opts.indefinite) {\n      if (!gen._pushUInt8(MT.ARRAY << 5 | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n\n    for (let j = 0; j < len; j++) {\n      if (!gen.pushAny(obj[j])) {\n        return false;\n      }\n    }\n\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _pushTag(tag) {\n    return this._pushInt(tag, MT.TAG);\n  }\n\n  _pushDate(gen, obj) {\n    switch (gen.dateType) {\n      case 'string':\n        return gen._pushTag(TAG.DATE_STRING) && gen._pushString(obj.toISOString());\n\n      case 'int':\n      case 'integer':\n        return gen._pushTag(TAG.DATE_EPOCH) && gen._pushIntNum(Math.round(obj / 1000));\n\n      case 'float':\n        // force float\n        return gen._pushTag(TAG.DATE_EPOCH) && gen._pushFloat(obj / 1000);\n\n      case 'number':\n      default:\n        // if we happen to have an integral number of seconds,\n        // use integer.  Otherwise, use float.\n        return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj / 1000);\n    }\n  }\n\n  _pushBuffer(gen, obj) {\n    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);\n  }\n\n  _pushNoFilter(gen, obj) {\n    return gen._pushBuffer(gen, obj.slice());\n  }\n\n  _pushRegexp(gen, obj) {\n    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);\n  }\n\n  _pushSet(gen, obj) {\n    if (!gen._pushInt(obj.size, MT.ARRAY)) {\n      return false;\n    }\n\n    for (const x of obj) {\n      if (!gen.pushAny(x)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _pushUrl(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());\n  }\n\n  _pushURL(gen, obj) {\n    return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());\n  }\n  /**\n   * @param {bignumber} obj\n   * @private\n   */\n\n\n  _pushBigint(obj) {\n    let m = MT.POS_INT;\n    let tag = TAG.POS_BIGINT;\n\n    if (obj.isNegative()) {\n      obj = obj.negated().minus(1);\n      m = MT.NEG_INT;\n      tag = TAG.NEG_BIGINT;\n    }\n\n    if (this.collapseBigIntegers && obj.lte(BN.MAXINT64)) {\n      //  special handiling for 64bits\n      if (obj.lte(BN.MAXINT32)) {\n        return this._pushInt(obj.toNumber(), m);\n      }\n\n      return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(obj.dividedToIntegerBy(BN.SHIFT32).toNumber()) && this._pushUInt32BE(obj.mod(BN.SHIFT32).toNumber());\n    }\n\n    let str = obj.toString(16);\n\n    if (str.length % 2) {\n      str = '0' + str;\n    }\n\n    const buf = Buffer.from(str, 'hex');\n    return this._pushTag(tag) && this._pushBuffer(this, buf);\n  }\n  /**\n   * @param {bigint} obj\n   * @private\n   */\n\n\n  _pushJSBigint(obj) {\n    let m = MT.POS_INT;\n    let tag = TAG.POS_BIGINT; // BigInt doesn't have -0\n\n    if (obj < 0) {\n      obj = -obj + BI.MINUS_ONE;\n      m = MT.NEG_INT;\n      tag = TAG.NEG_BIGINT;\n    }\n\n    if (this.collapseBigIntegers && obj <= BI.MAXINT64) {\n      //  special handiling for 64bits\n      if (obj <= 0xffffffff) {\n        return this._pushInt(Number(obj), m);\n      }\n\n      return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(Number(obj / BI.SHIFT32)) && this._pushUInt32BE(Number(obj % BI.SHIFT32));\n    }\n\n    let str = obj.toString(16);\n\n    if (str.length % 2) {\n      str = '0' + str;\n    }\n\n    const buf = Buffer.from(str, 'hex');\n    return this._pushTag(tag) && this._pushBuffer(this, buf);\n  }\n\n  _pushBigNumber(gen, obj) {\n    if (obj.isNaN()) {\n      return gen._pushNaN();\n    }\n\n    if (!obj.isFinite()) {\n      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);\n    }\n\n    if (obj.isInteger()) {\n      return gen._pushBigint(obj);\n    }\n\n    if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {\n      return false;\n    }\n\n    const dec = obj.decimalPlaces();\n    const slide = obj.shiftedBy(dec);\n\n    if (!gen._pushIntNum(-dec)) {\n      return false;\n    }\n\n    if (slide.abs().isLessThan(BN.MAXINT)) {\n      return gen._pushIntNum(slide.toNumber());\n    } else {\n      return gen._pushBigint(slide);\n    }\n  }\n\n  _pushMap(gen, obj, opts) {\n    opts = Object.assign({\n      indefinite: false\n    }, opts);\n\n    if (opts.indefinite) {\n      if (!gen._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!gen._pushInt(obj.size, MT.MAP)) {\n      return false;\n    } // memoizing the cbor only helps in certain cases, and hurts in most\n    // others.  Just avoid it.\n\n\n    if (gen.canonical) {\n      // keep the key/value pairs together, so we don't have to do odd\n      // gets with object keys later\n      const entries = [...obj.entries()];\n      const enc = new Encoder(this); // TODO: fix genTypes\n\n      const bs = new NoFilter({\n        highWaterMark: this.readableHighWaterMark\n      });\n      enc.pipe(bs);\n      entries.sort(([a], [b]) => {\n        // a, b are the keys\n        enc.pushAny(a);\n        const a_cbor = bs.read();\n        enc.pushAny(b);\n        const b_cbor = bs.read();\n        return a_cbor.compare(b_cbor);\n      });\n\n      for (const _ref of entries) {\n        var _ref2 = _slicedToArray(_ref, 2);\n\n        const k = _ref2[0];\n        const v = _ref2[1];\n\n        if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n          throw new Error('Invalid Map key: undefined');\n        }\n\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    } else {\n      for (const _ref3 of obj) {\n        var _ref4 = _slicedToArray(_ref3, 2);\n\n        const k = _ref4[0];\n        const v = _ref4[1];\n\n        if (gen.disallowUndefinedKeys && typeof k === 'undefined') {\n          throw new Error('Invalid Map key: undefined');\n        }\n\n        if (!(gen.pushAny(k) && gen.pushAny(v))) {\n          return false;\n        }\n      }\n    }\n\n    if (opts.indefinite) {\n      if (!gen.push(BREAK)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _pushUint8Array(gen, obj) {\n    return gen._pushBuffer(gen, Buffer.from(obj));\n  }\n\n  _pushFloat32Array(gen, obj) {\n    const len = obj.length;\n\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  _pushFloat64Array(gen, obj) {\n    const len = obj.length;\n\n    if (!gen._pushInt(len, MT.ARRAY)) {\n      return false;\n    }\n\n    for (let j = 0; j < len; j++) {\n      if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Remove all of the loop detector additions to the given object.\n   *\n   * @param {Object} obj - object to clean\n   * @returns {bool} - true when the object was cleaned, else false\n   */\n\n\n  removeLoopDetectors(obj) {\n    if (!this.detectLoops) {\n      return false;\n    }\n\n    return Encoder.removeLoopDetectors(obj, this.detectLoops);\n  }\n  /**\n   * Remove all of the loop detector additions to the given object.\n   * The static version is easier to call when you don't have a full\n   * encoder instance available; it uses a good heuristic to figure\n   * out the loop detector symbol.\n   *\n   * @param {Object} obj - object to clean\n   * @param {Symbol} [detector=null] - the symbol to clean, or null\n   *   to use the first detected symbol\n   * @returns {bool} - true when the object was cleaned, else false\n   */\n\n\n  static removeLoopDetectors(obj, detector = null) {\n    if (typeof obj !== 'object' || !obj) {\n      return false;\n    }\n\n    const dl = obj[LOOP_DETECT];\n\n    if (!dl) {\n      // ironically, use loop marking to detect loops on removal as well\n      return false;\n    }\n\n    if (detector == null) {\n      detector = dl;\n    } else {\n      if (detector !== dl) {\n        return false;\n      }\n    }\n\n    delete obj[LOOP_DETECT];\n\n    if (Array.isArray(obj)) {\n      for (const i of obj) {\n        this.removeLoopDetectors(i, detector);\n      }\n    } else {\n      for (const k in obj) {\n        this.removeLoopDetectors(obj[k], detector);\n      }\n    }\n\n    return true;\n  }\n\n  _pushObject(obj, opts) {\n    if (!obj) {\n      return this._pushNull(obj);\n    }\n\n    opts = Object.assign({\n      indefinite: false,\n      skipTypes: false\n    }, opts);\n\n    if (!opts.indefinite) {\n      // this will only happen the first time through for indefinite encoding\n      if (this.detectLoops) {\n        if (obj[LOOP_DETECT] === this.detectLoops) {\n          throw new Error('Loop detected while CBOR encoding');\n        } else {\n          obj[LOOP_DETECT] = this.detectLoops;\n        }\n      }\n    }\n\n    if (!opts.skipTypes) {\n      const f = obj.encodeCBOR;\n\n      if (typeof f === 'function') {\n        return f.call(obj, this);\n      }\n\n      const converter = this.semanticTypes[obj.constructor.name];\n\n      if (converter) {\n        return converter.call(obj, this, obj);\n      }\n    }\n\n    const keys = Object.keys(obj).filter(k => typeof obj[k] !== 'function');\n    const cbor_keys = {};\n\n    if (this.canonical) {\n      // note: this can't be a normal sort, because 'b' needs to sort before\n      // 'aa'\n      keys.sort((a, b) => {\n        // Always strings, so don't bother to pass options.\n        // hold on to the cbor versions, since there's no need\n        // to encode more than once\n        const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));\n        const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));\n        return a_cbor.compare(b_cbor);\n      });\n    }\n\n    if (opts.indefinite) {\n      if (!this._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {\n        return false;\n      }\n    } else if (!this._pushInt(keys.length, MT.MAP)) {\n      return false;\n    }\n\n    let ck;\n\n    for (let j = 0, len2 = keys.length; j < len2; j++) {\n      const k = keys[j];\n\n      if (this.canonical && (ck = cbor_keys[k])) {\n        if (!this.push(ck)) {\n          // already a Buffer\n          return false;\n        }\n      } else {\n        if (!this._pushString(k)) {\n          return false;\n        }\n      }\n\n      if (!this.pushAny(obj[k])) {\n        return false;\n      }\n    }\n\n    if (opts.indefinite) {\n      if (!this.push(BREAK)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n  /**\n   * Push any supported type onto the encoded stream\n   *\n   * @param {any} obj\n   * @returns {boolean} true on success\n   */\n\n\n  pushAny(obj) {\n    switch (typeof obj) {\n      case 'number':\n        return this._pushNumber(obj);\n\n      case 'bigint':\n        return this._pushJSBigint(obj);\n\n      case 'string':\n        return this._pushString(obj);\n\n      case 'boolean':\n        return this._pushBoolean(obj);\n\n      case 'undefined':\n        return this._pushUndefined(obj);\n\n      case 'object':\n        return this._pushObject(obj);\n\n      case 'symbol':\n        switch (obj) {\n          case SYMS.NULL:\n            return this._pushNull(null);\n\n          case SYMS.UNDEFINED:\n            return this._pushUndefined(void 0);\n          // TODO: Add pluggable support for other symbols\n\n          default:\n            throw new Error('Unknown symbol: ' + obj.toString());\n        }\n\n      default:\n        throw new Error('Unknown type: ' + typeof obj + ', ' + (!!obj.toString ? obj.toString() : ''));\n    }\n  }\n  /* backwards-compat wrapper */\n\n\n  _pushAny(obj) {\n    // TODO: write deprecation warning\n    return this.pushAny(obj);\n  }\n\n  _encodeAll(objs) {\n    const bs = new NoFilter({\n      highWaterMark: this.readableHighWaterMark\n    });\n    this.pipe(bs);\n\n    for (const o of objs) {\n      this.pushAny(o);\n    }\n\n    this.end();\n    return bs.read();\n  }\n  /**\n   * Encode the given object with indefinite length.  There are apparently\n   * some (IMO) broken implementations of poorly-specified protocols that\n   * REQUIRE indefinite-encoding.  Add this to an object or class as the\n   * `encodeCBOR` function to get indefinite encoding:\n   * @example\n   * const o = {\n   *   a: true,\n   *   encodeCBOR: cbor.Encoder.encodeIndefinite\n   * }\n   * const m = []\n   * m.encodeCBOR = cbor.Encoder.encodeIndefinite\n   * cbor.encodeOne([o, m])\n   *\n   * @param {Encoder} - the encoder to use\n   * @param {String|Buffer|Array|Map|Object} [obj] - the object to encode.  If\n   *   null, use \"this\" instead.\n   * @param {Object} [opts=null] - Options for encoding\n   * @param {boolean} [opts.chunkSize=4096] - Number of characters or bytes\n   *  for each chunk, if obj is a string or Buffer\n   * @returns {boolean} - true on success\n   */\n\n\n  static encodeIndefinite(gen, obj, opts) {\n    if (obj == null) {\n      if (this == null) {\n        throw new Error('No object to encode');\n      }\n\n      obj = this;\n    }\n\n    opts = Object.assign({\n      chunkSize: 4096\n    }, opts);\n    let ret = true;\n    const objType = typeof obj;\n\n    if (objType === 'string') {\n      // TODO: make sure not to split surrogate pairs at the edges of chunks,\n      // since such half-surrogates cannot be legally encoded as UTF-8.\n      ret = ret && gen._pushUInt8(MT.UTF8_STRING << 5 | NUMBYTES.INDEFINITE);\n      let offset = 0;\n\n      while (offset < obj.length) {\n        const endIndex = offset + opts.chunkSize;\n        ret = ret && gen._pushString(obj.slice(offset, endIndex));\n        offset = endIndex;\n      }\n\n      ret = ret && gen.push(BREAK);\n    } else if (Buffer.isBuffer(obj)) {\n      ret = ret && gen._pushUInt8(MT.BYTE_STRING << 5 | NUMBYTES.INDEFINITE);\n      let offset = 0;\n\n      while (offset < obj.length) {\n        const endIndex = offset + opts.chunkSize;\n        ret = ret && gen._pushBuffer(gen, obj.slice(offset, endIndex));\n        offset = endIndex;\n      }\n\n      ret = ret && gen.push(BREAK);\n    } else if (Array.isArray(obj)) {\n      ret = ret && gen._pushArray(gen, obj, {\n        indefinite: true\n      });\n    } else if (obj instanceof Map) {\n      ret = ret && gen._pushMap(gen, obj, {\n        indefinite: true\n      });\n    } else {\n      if (objType !== 'object') {\n        throw new Error('Invalid indefinite encoding');\n      }\n\n      ret = ret && gen._pushObject(obj, {\n        indefinite: true,\n        skipTypes: true\n      });\n    }\n\n    return ret;\n  }\n  /**\n   * Encode one or more JavaScript objects, and return a Buffer containing the\n   * CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n\n\n  static encode(...objs) {\n    return new Encoder()._encodeAll(objs);\n  }\n  /**\n   * Encode one or more JavaScript objects canonically (slower!), and return\n   * a Buffer containing the CBOR bytes.\n   *\n   * @param {...any} objs - the objects to encode\n   * @returns {Buffer} - the encoded objects\n   */\n\n\n  static encodeCanonical(...objs) {\n    return new Encoder({\n      canonical: true\n    })._encodeAll(objs);\n  }\n  /**\n   * Encode one JavaScript object using the given options.\n   *\n   * @static\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   * @returns {Buffer} - the encoded objects\n   */\n\n\n  static encodeOne(obj, options) {\n    return new Encoder(options)._encodeAll([obj]);\n  }\n  /**\n   * Encode one JavaScript object using the given options in a way that\n   * is more resilient to objects being larger than the highWaterMark\n   * number of bytes.  As with the other static encode functions, this \n   * will still use a large amount of memory.  Use a stream-based approach\n   * directly if you need to process large and complicated inputs.\n   *\n   * @param {any} obj - the object to encode\n   * @param {Object?} options - passed to the Encoder constructor\n   */\n\n\n  static encodeAsync(obj, options) {\n    return new Promise((resolve, reject) => {\n      const bufs = [];\n      const enc = new Encoder(options);\n      enc.on('data', buf => bufs.push(buf));\n      enc.on('error', reject);\n      enc.on('finish', () => resolve(Buffer.concat(bufs)));\n      enc.pushAny(obj);\n      enc.end();\n    });\n  }\n\n}\n\nmodule.exports = Encoder;","map":null,"metadata":{},"sourceType":"script"}