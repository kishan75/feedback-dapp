{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.message = void 0;\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:format:utils:exception\");\n\nconst Format = __importStar(require(\"../common\"));\n\nconst AstUtils = __importStar(require(\"../../ast/utils\")); //this function gives an error message\n//for those errors that are meant to possibly\n//be wrapped in a DecodingError and thrown\n\n\nfunction message(error) {\n  switch (error.kind) {\n    case \"UserDefinedTypeNotFoundError\":\n      let typeName = Format.Types.isContractDefinedType(error.type) ? error.type.definingContractName + \".\" + error.type.typeName : error.type.typeName;\n      return \"Unknown \".concat(error.type.typeClass, \" type \").concat(typeName, \" of id \").concat(error.type.id);\n\n    case \"UnsupportedConstantError\":\n      return \"Unsupported constant type \".concat(AstUtils.typeClass(error.definition));\n\n    case \"UnusedImmutableError\":\n      return \"Cannot read unused immutable\";\n\n    case \"ReadErrorStack\":\n      return \"Can't read stack from position \".concat(error.from, \" to \").concat(error.to);\n\n    case \"ReadErrorBytes\":\n      return \"Can't read \".concat(error.length, \" bytes from \").concat(error.location, \" starting at \").concat(error.start);\n\n    case \"ReadErrorStorage\":\n      if (error.range.length) {\n        return \"Can't read \".concat(error.range.length, \" bytes from storage starting at index \").concat(error.range.from.index, \" in \").concat(slotAddressPrintout(error.range.from.slot));\n      } else {\n        return \"Can't read storage from index \".concat(error.range.from.index, \" in \").concat(slotAddressPrintout(error.range.from.slot), \" to index \").concat(error.range.to.index, \" in \").concat(slotAddressPrintout(error.range.to.slot));\n      }\n\n  }\n}\n\nexports.message = message;\n\nfunction slotAddressPrintout(slot) {\n  if (slot.key !== undefined && slot.path !== undefined) {\n    // mapping reference\n    let _keyInfoForPrinting = keyInfoForPrinting(slot.key),\n        keyEncoding = _keyInfoForPrinting.type,\n        keyValue = _keyInfoForPrinting.value;\n\n    return \"keccak(\" + keyValue + \" as \" + keyEncoding + \", \" + slotAddressPrintout(slot.path) + \") + \" + slot.offset.toString();\n  } else if (slot.path !== undefined) {\n    const pathAddressPrintout = slotAddressPrintout(slot.path);\n    return slot.hashPath ? \"keccak(\" + pathAddressPrintout + \")\" + slot.offset.toString() : pathAddressPrintout + slot.offset.toString();\n  } else {\n    return slot.offset.toString();\n  }\n} //this is like the old toSoliditySha3Input, but for debugging purposes ONLY\n//it will NOT produce correct input to soliditySha3\n//please use mappingKeyAsHex instead if you wish to encode a mapping key.\n\n\nfunction keyInfoForPrinting(input) {\n  switch (input.type.typeClass) {\n    case \"uint\":\n      return {\n        type: \"uint\",\n        value: input.value.asBN.toString()\n      };\n\n    case \"int\":\n      return {\n        type: \"int\",\n        value: input.value.asBN.toString()\n      };\n\n    case \"fixed\":\n      return {\n        type: \"fixed256x\".concat(input.type.places),\n        value: input.value.asBig.toString()\n      };\n\n    case \"ufixed\":\n      return {\n        type: \"ufixed256x\".concat(input.type.places),\n        value: input.value.asBig.toString()\n      };\n\n    case \"bool\":\n      //this is the case that won't work as valid input to soliditySha3 :)\n      return {\n        type: \"uint\",\n        value: input.value.asBoolean.toString()\n      };\n\n    case \"bytes\":\n      switch (input.type.kind) {\n        case \"static\":\n          return {\n            type: \"bytes32\",\n            value: input.value.asHex\n          };\n\n        case \"dynamic\":\n          return {\n            type: \"bytes\",\n            value: input.value.asHex\n          };\n      }\n\n    case \"address\":\n      return {\n        type: \"address\",\n        value: input.value.asAddress\n      };\n\n    case \"string\":\n      let coercedInput = input;\n\n      switch (coercedInput.value.kind) {\n        case \"valid\":\n          return {\n            type: \"string\",\n            value: coercedInput.value.asString\n          };\n\n        case \"malformed\":\n          return {\n            type: \"bytes\",\n            value: coercedInput.value.asHex\n          };\n      }\n\n    //fixed and ufixed are skipped for now\n  }\n}","map":null,"metadata":{},"sourceType":"script"}