{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar _slicedToArray = require(\"F:\\\\BlockChain\\\\Projects\\\\feedback-dapp\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.abiParameterToType = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:import\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nfunction abiParameterToType(abi) {\n  let typeName = abi.type;\n  let typeHint = abi.internalType; //first: is it an array?\n\n  let arrayMatch = typeName.match(/(.*)\\[(\\d*)\\]$/);\n\n  if (arrayMatch) {\n    let baseTypeName = arrayMatch[1];\n    let lengthAsString = arrayMatch[2]; //may be empty!\n\n    let baseAbi = Object.assign(Object.assign({}, abi), {\n      type: baseTypeName\n    });\n    let baseType = abiParameterToType(baseAbi);\n\n    if (lengthAsString === \"\") {\n      return {\n        typeClass: \"array\",\n        kind: \"dynamic\",\n        baseType,\n        typeHint\n      };\n    } else {\n      let length = new bn_js_1.default(lengthAsString);\n      return {\n        typeClass: \"array\",\n        kind: \"static\",\n        length,\n        baseType,\n        typeHint\n      };\n    }\n  } //otherwise, here are the simple cases\n\n\n  let typeClass = typeName.match(/^([^0-9]+)/)[1];\n\n  switch (typeClass) {\n    case \"uint\":\n    case \"int\":\n      {\n        let bits = typeName.match(/^u?int([0-9]+)/)[1];\n        return {\n          typeClass,\n          bits: parseInt(bits),\n          typeHint\n        };\n      }\n\n    case \"bytes\":\n      let length = typeName.match(/^bytes([0-9]*)/)[1];\n\n      if (length === \"\") {\n        return {\n          typeClass,\n          kind: \"dynamic\",\n          typeHint\n        };\n      } else {\n        return {\n          typeClass,\n          kind: \"static\",\n          length: parseInt(length),\n          typeHint\n        };\n      }\n\n    case \"address\":\n      return {\n        typeClass,\n        kind: \"general\",\n        typeHint\n      };\n\n    case \"string\":\n    case \"bool\":\n      return {\n        typeClass,\n        typeHint\n      };\n\n    case \"fixed\":\n    case \"ufixed\":\n      {\n        let _typeName$match = typeName.match(/^u?fixed([0-9]+)x([0-9]+)/),\n            _typeName$match2 = _slicedToArray(_typeName$match, 3),\n            _ = _typeName$match2[0],\n            bits = _typeName$match2[1],\n            places = _typeName$match2[2];\n\n        return {\n          typeClass,\n          bits: parseInt(bits),\n          places: parseInt(places),\n          typeHint\n        };\n      }\n\n    case \"function\":\n      return {\n        typeClass,\n        visibility: \"external\",\n        kind: \"general\",\n        typeHint\n      };\n\n    case \"tuple\":\n      let memberTypes = abi.components.map(component => ({\n        name: component.name || undefined,\n        type: abiParameterToType(component)\n      }));\n      return {\n        typeClass,\n        memberTypes,\n        typeHint\n      };\n  }\n}\n\nexports.abiParameterToType = abiParameterToType;","map":null,"metadata":{},"sourceType":"script"}