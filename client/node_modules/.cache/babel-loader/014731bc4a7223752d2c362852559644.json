{"ast":null,"code":"var _slicedToArray = require(\"F:\\\\BlockChain\\\\Projects\\\\feedback-dapp\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nconst execute = require(\"../execute\");\n\nconst debug = require(\"debug\")(\"contract:contract:bootstrap\");\n\nmodule.exports = fn => {\n  // Add our static methods\n  // Add something here about excluding send, privately defined methods\n  Object.keys(fn._constructorMethods).forEach(function (key) {\n    fn[key] = fn._constructorMethods[key].bind(fn);\n  }); // Add our properties.\n\n  Object.keys(fn._properties).forEach(function (key) {\n    fn.addProp(key, fn._properties[key]);\n  }); // estimateGas & request as sub-property of new\n\n  fn[\"new\"].estimateGas = execute.estimateDeployment.bind(fn);\n  fn[\"new\"].request = execute.requestDeployment.bind(fn); //add enumerations. (probably these should go in\n  //constructorMethods.js, but this is easier to modify... we'll\n  //redo all this in the rewrite anyway)\n\n  if (fn._json) {\n    //getters will throw otherwise!\n    if (fn.ast) {\n      //note this was set up earlier\n      const node = locateNode(fn.contractName, fn.ast); //name also set up earlier\n\n      if (node) {\n        fn.enums = extractEnums(node);\n\n        for (const _ref of Object.entries(fn.enums)) {\n          var _ref2 = _slicedToArray(_ref, 2);\n\n          const name = _ref2[0];\n          const enumeration = _ref2[1];\n\n          //enum is a reserved word :P\n          if (!(name in fn)) {\n            //don't overwrite anything!\n            fn[name] = enumeration;\n          }\n        }\n      }\n    }\n  }\n\n  return fn;\n};\n\nfunction locateNode(name, ast) {\n  if (ast.nodeType === \"SourceUnit\") {\n    return ast.nodes.find(node => node.nodeType === \"ContractDefinition\" && node.name === name);\n  } else {\n    return undefined;\n  }\n}\n\nfunction extractEnums(node) {\n  return Object.assign({}, ...node.nodes.filter(definition => definition.nodeType === \"EnumDefinition\").map(definition => ({\n    [definition.name]: Object.assign({}, ...definition.members.map((member, index) => ({\n      [member.name]: index\n    })))\n  })));\n}","map":null,"metadata":{},"sourceType":"script"}