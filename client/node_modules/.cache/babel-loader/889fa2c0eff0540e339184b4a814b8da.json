{"ast":null,"code":"import { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { makeLazy } from '../../stream/LazyIterableIterator.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { isSubarrayOf } from './helpers/IsSubarrayOf.js';\nimport { IntegerArbitrary } from './IntegerArbitrary.js';\nexport class SubarrayArbitrary extends NextArbitrary {\n  constructor(originalArray, isOrdered, minLength, maxLength) {\n    super();\n    this.originalArray = originalArray;\n    this.isOrdered = isOrdered;\n    this.minLength = minLength;\n    this.maxLength = maxLength;\n    if (minLength < 0 || minLength > originalArray.length) throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be between 0 and the size of the original array');\n    if (maxLength < 0 || maxLength > originalArray.length) throw new Error('fc.*{s|S}ubarrayOf expects the maximal length to be between 0 and the size of the original array');\n    if (minLength > maxLength) throw new Error('fc.*{s|S}ubarrayOf expects the minimal length to be inferior or equal to the maximal length');\n    this.lengthArb = new IntegerArbitrary(minLength, maxLength);\n    this.biasedLengthArb = minLength !== maxLength ? new IntegerArbitrary(minLength, minLength + Math.floor(Math.log(maxLength - minLength) / Math.log(2))) : this.lengthArb;\n  }\n\n  generate(mrng, biasFactor) {\n    const lengthArb = biasFactor !== undefined && mrng.nextInt(1, biasFactor) === 1 ? this.biasedLengthArb : this.lengthArb;\n    const size = lengthArb.generate(mrng, undefined);\n    const sizeValue = size.value;\n    const remainingElements = this.originalArray.map((_v, idx) => idx);\n    const ids = [];\n\n    for (let index = 0; index !== sizeValue; ++index) {\n      const selectedIdIndex = mrng.nextInt(0, remainingElements.length - 1);\n      ids.push(remainingElements[selectedIdIndex]);\n      remainingElements.splice(selectedIdIndex, 1);\n    }\n\n    if (this.isOrdered) {\n      ids.sort((a, b) => a - b);\n    }\n\n    return new NextValue(ids.map(i => this.originalArray[i]), size.context);\n  }\n\n  canShrinkWithoutContext(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n\n    if (!this.lengthArb.canShrinkWithoutContext(value.length)) {\n      return false;\n    }\n\n    return isSubarrayOf(this.originalArray, value);\n  }\n\n  shrink(value, context) {\n    if (value.length === 0) {\n      return Stream.nil();\n    }\n\n    return this.lengthArb.shrink(value.length, context).map(newSize => {\n      return new NextValue(value.slice(value.length - newSize.value), newSize.context);\n    }).join(value.length > this.minLength ? makeLazy(() => this.shrink(value.slice(1), undefined).filter(newValue => this.minLength <= newValue.value.length + 1).map(newValue => new NextValue([value[0]].concat(newValue.value), undefined))) : Stream.nil());\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}