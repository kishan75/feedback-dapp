{"ast":null,"code":"const debug = require(\"debug\")(\"contract:execute\");\n\nconst PromiEvent = require(\"./promievent\");\n\nconst EventEmitter = require(\"events\");\n\nconst utils = require(\"./utils\");\n\nconst StatusError = require(\"./statuserror\");\n\nconst Reason = require(\"./reason\");\n\nconst handlers = require(\"./handlers\");\n\nconst override = require(\"./override\");\n\nconst reformat = require(\"./reformat\");\n\nconst _require = require(\"./manual-send\"),\n      sendTransactionManual = _require.sendTransactionManual;\n\nconst execute = {\n  // -----------------------------------  Helpers --------------------------------------------------\n\n  /**\n   * Retrieves gas estimate multiplied by the set gas multiplier for a `sendTransaction` call.\n   * Lacking an estimate, sets gas to have of latest blockLimit\n   * @param  {Object} params     `sendTransaction` parameters\n   * @param  {Number} blockLimit  most recent network block.blockLimit\n   * @return {Number}             gas estimate\n   */\n  getGasEstimate: function (params, blockLimit, stacktrace = false) {\n    const constructor = this;\n    const interfaceAdapter = this.interfaceAdapter;\n    return new Promise(function (accept) {\n      // Always prefer gas specified by user (if a user sets gas to 0, that is treated\n      // as undefined here and we do proceed to do gas estimation)\n      if (params.gas) return accept(params.gas);\n      if (!constructor.autoGas) return accept();\n      interfaceAdapter.estimateGas(params, stacktrace).then(gas => {\n        // there are situations where the web3 gas estimation function in interfaceAdapter\n        // fails, specifically when a transaction will revert; we still want to continue\n        // the user flow for debugging purposes if the user has enabled stacktraces; so we provide a\n        // default gas for that situation, equal to half of the blockLimit for the latest block\n        //\n        // note: this means if a transaction will revert but the user does not have stacktracing enabled,\n        // they will get an error from the gas estimation and be unable to proceed; we may need to revisit this\n        if (gas === null) {\n          const defaultGas = utils.bigNumberify(Math.floor(blockLimit / 2));\n          accept(defaultGas.toHexString());\n        } else {\n          const limit = utils.bigNumberify(blockLimit); // if we did get a numerical gas estimate from interfaceAdapter, we\n          // multiply that estimate by the gasMultiplier to help ensure we\n          // have enough gas for the transaction\n\n          const bestEstimate = utils.multiplyBigNumberByDecimal(utils.bigNumberify(gas), constructor.gasMultiplier); // Check that we don't go over blockLimit\n\n          bestEstimate.gte(limit) ? accept(limit.sub(1).toHexString()) : accept(bestEstimate.toHexString());\n        }\n      }).catch(() => accept());\n    });\n  },\n\n  /**\n   * Prepares simple wrapped calls by checking network and organizing the method inputs into\n   * objects web3 can consume.\n   * @param  {Object} constructor   TruffleContract constructor\n   * @param  {Object} methodABI     Function ABI segment w/ inputs & outputs keys.\n   * @param  {Array}  _arguments    Arguments passed to method invocation\n   * @param  {Boolean}  isCall      Used when preparing a call as opposed to a tx;\n   *                                  skips network checks and ignores default gas prices\n   * @return {Promise}              Resolves object w/ tx params disambiguated from arguments\n   */\n  prepareCall: async function (constructor, methodABI, _arguments, isCall) {\n    let args = Array.prototype.slice.call(_arguments);\n    let params = utils.getTxParams.call(constructor, methodABI, args, isCall);\n    args = utils.convertToEthersBN(args);\n\n    if (constructor.ens && constructor.ens.enabled) {\n      const web3 = constructor.web3;\n      const processedValues = await utils.ens.convertENSNames({\n        networkId: constructor.network_id,\n        ens: constructor.ens,\n        inputArgs: args,\n        inputParams: params,\n        methodABI,\n        web3\n      });\n      args = processedValues.args;\n      params = processedValues.params;\n    } //isCall flag used to skip network call for read data (calls type) methods invocation\n\n\n    if (isCall) {\n      return {\n        args,\n        params\n      };\n    }\n\n    const network = await constructor.detectNetwork();\n    return {\n      args,\n      params,\n      network\n    };\n  },\n\n  /**\n   * Disambiguates between transaction parameter objects and BN / BigNumber objects\n   * @param  {Any}  arg\n   * @return {Boolean}\n   */\n  hasTxParams: function (arg) {\n    return utils.is_object(arg) && !utils.is_big_number(arg);\n  },\n\n  /**\n   * Parses function arguments to discover if the terminal argument specifies the `defaultBlock`\n   * to execute a call at.\n   * @param  {Array}  args      `arguments` that were passed to method\n   * @param  {Any}    lastArg    terminal argument passed to method\n   * @param  {Array}  inputs     ABI segment defining method arguments\n   * @return {Boolean}           true if final argument is `defaultBlock`\n   */\n  hasDefaultBlock: function (args, lastArg, inputs) {\n    const hasDefaultBlock = !execute.hasTxParams(lastArg) && args.length > inputs.length;\n    const hasDefaultBlockWithParams = execute.hasTxParams(lastArg) && args.length - 1 > inputs.length;\n    return hasDefaultBlock || hasDefaultBlockWithParams;\n  },\n  // -----------------------------------  Methods --------------------------------------------------\n\n  /**\n   * Executes method as .call and processes optional `defaultBlock` argument.\n   * @param  {Function} fn         method\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}             Return value of the call.\n   */\n  call: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      let defaultBlock = constructor.web3.eth.defaultBlock || \"latest\";\n      const args = Array.prototype.slice.call(arguments);\n      const lastArg = args[args.length - 1];\n      const promiEvent = new PromiEvent(); // Extract defaultBlock parameter\n\n      if (execute.hasDefaultBlock(args, lastArg, methodABI.inputs)) {\n        defaultBlock = args.pop();\n      } //skipNetworkCheck flag passed to skip network call for read data (calls type) methods invocation\n\n\n      const skipNetworkCheck = true;\n      execute.prepareCall(constructor, methodABI, args, skipNetworkCheck).then(async ({\n        args,\n        params\n      }) => {\n        let result;\n        params.to = address;\n        promiEvent.eventEmitter.emit(\"execute:call:method\", {\n          fn: fn,\n          args: args,\n          address: address,\n          abi: methodABI,\n          contract: constructor\n        });\n        result = await fn(...args).call(params, defaultBlock);\n        result = reformat.numbers.call(constructor, result, methodABI.outputs);\n        return promiEvent.resolve(result);\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Executes method as .send\n   * @param  {Function} fn         Method to invoke\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @param  {String}   address    Deployed address of the targeted instance\n   * @return {PromiEvent}          Resolves a transaction receipt (via the receipt handler)\n   */\n  send: function (fn, methodABI, address) {\n    const constructor = this;\n    const web3 = constructor.web3;\n    return function () {\n      const promiEvent = new PromiEvent(false, constructor.debugger);\n      execute.prepareCall(constructor, methodABI, arguments).then(async ({\n        args,\n        params,\n        network\n      }) => {\n        const context = {\n          contract: constructor,\n          // Can't name this field `constructor` or `_constructor`\n          promiEvent: promiEvent,\n          params: params\n        };\n        params.to = address;\n        params.data = fn ? fn(...args).encodeABI() : params.data;\n        promiEvent.eventEmitter.emit(\"execute:send:method\", {\n          fn,\n          args,\n          address,\n          abi: methodABI,\n          contract: constructor\n        });\n        const stacktrace = promiEvent.debug ? promiEvent.debug : false;\n\n        try {\n          params.gas = await execute.getGasEstimate.call(constructor, params, network.blockLimit, stacktrace);\n        } catch (error) {\n          promiEvent.reject(error);\n          return;\n        }\n\n        execute.sendTransaction(web3, params, promiEvent, context) //the crazy things we do for stacktracing...\n        .then(receipt => {\n          if (promiEvent.debug) {\n            // in this case, we need to manually invoke the handler since it\n            // hasn't been set up (hack?)\n            handlers.receipt(context, receipt);\n          } //otherwise, just let the handlers handle things\n\n        }).catch(override.start.bind(constructor, context));\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Deploys an instance\n   * @param  {Object} constructorABI  Constructor ABI segment w/ inputs & outputs keys\n   * @return {PromiEvent}             Resolves a TruffleContract instance\n   */\n  deploy: function (constructorABI) {\n    const constructor = this;\n    const web3 = constructor.web3;\n    return function () {\n      let deferred;\n      const promiEvent = new PromiEvent(false, constructor.debugger, true);\n      execute.prepareCall(constructor, constructorABI, arguments).then(async ({\n        args,\n        params,\n        network\n      }) => {\n        const blockLimit = network.blockLimit;\n        utils.checkLibraries.apply(constructor); // Promievent and flag that allows instance to resolve (rather than just receipt)\n\n        const context = {\n          contract: constructor,\n          promiEvent,\n          onlyEmitReceipt: true\n        };\n        const options = {\n          data: constructor.binary,\n          arguments: args\n        };\n        const contract = new web3.eth.Contract(constructor.abi);\n        params.data = contract.deploy(options).encodeABI();\n        const stacktrace = promiEvent.debug ? promiEvent.debug : false;\n        params.gas = await execute.getGasEstimate.call(constructor, params, blockLimit, stacktrace);\n        context.params = params;\n        promiEvent.eventEmitter.emit(\"execute:deploy:method\", {\n          args,\n          abi: constructorABI,\n          contract: constructor\n        });\n        deferred = execute.sendTransaction(web3, params, promiEvent, context); //the crazy things we do for stacktracing...\n\n        try {\n          const receipt = await deferred;\n\n          if (receipt.status !== undefined && !receipt.status) {\n            const reason = await Reason.get(params, web3);\n            const error = new StatusError(params, context.transactionHash, receipt, reason);\n            return context.promiEvent.reject(error);\n          }\n\n          const web3Instance = new web3.eth.Contract(constructor.abi, receipt.contractAddress);\n          web3Instance.transactionHash = context.transactionHash;\n          context.promiEvent.resolve(new constructor(web3Instance));\n        } catch (web3Error) {\n          // Manage web3's 50 blocks' timeout error.\n          // Web3's own subscriptions go dead here.\n          await override.start.call(constructor, context, web3Error);\n        }\n      }).catch(promiEvent.reject);\n      return promiEvent.eventEmitter;\n    };\n  },\n\n  /**\n   * Begins listening for an event OR manages the event callback\n   * @param  {Function} fn  Solidity event method\n   * @return {Emitter}      Event emitter\n   */\n  event: function (fn) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null; // Someone upstream is firing duplicates :/\n\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n\n    return function (params, callback) {\n      if (typeof params === \"function\") {\n        callback = params;\n        params = {};\n      } // As callback\n\n\n      if (callback !== undefined) {\n        const intermediary = function (err, e) {\n          if (err) return callback(err);\n          if (!dedupe(e.id)) return;\n          callback(null, decode.call(constructor, e, true)[0]);\n        };\n\n        return constructor.detectNetwork().then(() => fn.call(constructor.events, params, intermediary));\n      } // As EventEmitter\n\n\n      const emitter = new EventEmitter();\n      constructor.detectNetwork().then(() => {\n        const event = fn(params);\n        event.on(\"data\", e => dedupe(e.id) && emitter.emit(\"data\", decode.call(constructor, e, true)[0]));\n        event.on(\"changed\", e => dedupe(e.id) && emitter.emit(\"changed\", decode.call(constructor, e, true)[0]));\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `allEvents`, with additional log decoding\n   * @return {PromiEvent}  EventEmitter\n   */\n  allEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    let currentLogID = null; // Someone upstream is firing duplicates :/\n\n    function dedupe(id) {\n      return id === currentLogID ? false : currentLogID = id;\n    }\n\n    return function (params) {\n      const emitter = new EventEmitter();\n      constructor.detectNetwork().then(() => {\n        const event = web3Instance.events.allEvents(params);\n        event.on(\"data\", e => dedupe(e.id) && emitter.emit(\"data\", decode.call(constructor, e, true)[0]));\n        event.on(\"changed\", e => dedupe(e.id) && emitter.emit(\"changed\", decode.call(constructor, e, true)[0]));\n        event.on(\"error\", e => emitter.emit(\"error\", e));\n      });\n      return emitter;\n    };\n  },\n\n  /**\n   * Wraps web3 `getPastEvents`, with additional log decoding\n   * @return {Promise}  Resolves array of event objects\n   */\n  getPastEvents: function (web3Instance) {\n    const constructor = this;\n    const decode = utils.decodeLogs;\n    return function (event, options) {\n      return web3Instance.getPastEvents(event, options).then(events => decode.call(constructor, events, false));\n    };\n  },\n\n  /**\n   * Estimates gas cost of a method invocation\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  estimate: function (fn, methodABI) {\n    const constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, methodABI, arguments).then(res => fn(...res.args).estimateGas(res.params));\n    };\n  },\n\n  /**\n   *\n   * @param  {Function} fn  Method to target\n   * @param  {Object}   methodABI  Function ABI segment w/ inputs & outputs keys.\n   * @return {Promise}\n   */\n  request: function (fn, methodABI, address) {\n    const constructor = this;\n    return function () {\n      return execute.prepareCall(constructor, methodABI, arguments).then(res => {\n        //clone res.params\n        let tx = {};\n\n        for (let key in res.params) {\n          tx[key] = res.params[key];\n        } //set to\n\n\n        tx.to = address; //set data\n\n        tx.data = fn(...res.args).encodeABI();\n        return tx;\n      });\n    };\n  },\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `estimateGas`\n  estimateDeployment: function () {\n    const constructor = this;\n    const constructorABI = constructor.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.prepareCall(constructor, constructorABI, arguments).then(res => {\n      const options = {\n        data: constructor.binary,\n        arguments: res.args\n      };\n      delete res.params[\"data\"]; // Is this necessary?\n\n      const instance = new constructor.web3.eth.Contract(constructor.abi, res.params);\n      return instance.deploy(options).estimateGas(res.params);\n    });\n  },\n  // This gets attached to `.new` (declared as a static_method in `contract`)\n  // during bootstrapping as `request`\n  requestDeployment: function () {\n    const constructor = this;\n    const constructorABI = constructor.abi.filter(i => i.type === \"constructor\")[0];\n    return execute.prepareCall(constructor, constructorABI, arguments).then(res => {\n      //clone res.params\n      let tx = {};\n\n      for (let key in res.params) {\n        tx[key] = res.params[key];\n      }\n\n      const options = {\n        data: constructor.binary,\n        arguments: res.args\n      };\n      const instance = new constructor.web3.eth.Contract(constructor.abi, res.params);\n      tx.data = instance.deploy(options).encodeABI();\n      return tx;\n    });\n  },\n  //our own custom sendTransaction function, made to mimic web3's,\n  //while also being able to do things, like, say, store the transaction\n  //hash even in case of failure.  it's not as powerful in some ways,\n  //as it just returns an ordinary Promise rather than web3's PromiEvent,\n  //but it's more suited to our purposes (we're not using that PromiEvent\n  //functionality here anyway)\n  //input works the same as input to web3.sendTransaction\n  //(well, OK, it's lacking some things there too, but again, good enough\n  //for our purposes)\n  sendTransaction: async function (web3, params, promiEvent, context) {\n    //if we don't need the debugger, let's not risk any errors on our part,\n    //and just have web3 do everything\n    if (!promiEvent || !promiEvent.debug) {\n      const deferred = web3.eth.sendTransaction(params);\n      handlers.setup(deferred, context);\n      return deferred;\n    } //otherwise, do things manually!\n    //(and skip the PromiEvent stuff :-/ )\n\n\n    return sendTransactionManual(web3, params, promiEvent);\n  }\n};\nmodule.exports = execute;","map":null,"metadata":{},"sourceType":"script"}