{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/esm/extends\";\nimport * as React from 'react';\nimport { GridEvents } from '../../../models/events';\nimport { useGridApiMethod } from '../../utils/useGridApiMethod';\nimport { useGridLogger } from '../../utils/useGridLogger';\nimport { gridColumnFieldsSelector, gridColumnDefinitionsSelector, gridColumnLookupSelector, gridColumnsMetaSelector, gridColumnsSelector, gridColumnVisibilityModelSelector, gridVisibleColumnDefinitionsSelector, gridColumnPositionsSelector } from './gridColumnsSelector';\nimport { useGridApiEventHandler, useGridApiOptionHandler } from '../../utils/useGridApiEventHandler';\nimport { useGridRegisterPreProcessor } from '../../core/preProcessing';\nimport { hydrateColumnsWidth, computeColumnTypes, createColumnsState, setColumnsState } from './gridColumnsUtils';\nexport const columnsStateInitializer = (state, props, apiRef) => {\n  var _props$initialState, _props$initialState$c, _ref, _props$columnVisibili, _props$initialState2, _props$initialState2$;\n\n  const shouldUseVisibleColumnModel = !!props.columnVisibilityModel || !!((_props$initialState = props.initialState) != null && (_props$initialState$c = _props$initialState.columns) != null && _props$initialState$c.columnVisibilityModel);\n  const columnsTypes = computeColumnTypes(props.columnTypes);\n  const columnsState = createColumnsState({\n    apiRef,\n    columnsTypes,\n    columnsToUpsert: props.columns,\n    shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,\n    currentColumnVisibilityModel: (_ref = (_props$columnVisibili = props.columnVisibilityModel) != null ? _props$columnVisibili : (_props$initialState2 = props.initialState) == null ? void 0 : (_props$initialState2$ = _props$initialState2.columns) == null ? void 0 : _props$initialState2$.columnVisibilityModel) != null ? _ref : {},\n    reset: true\n  });\n  return _extends({}, state, {\n    columns: columnsState\n  });\n};\n/**\n * @requires useGridParamsApi (method)\n * @requires useGridDimensions (method, event) - can be after\n * TODO: Impossible priority - useGridParamsApi also needs to be after useGridColumns\n */\n\nexport function useGridColumns(apiRef, props) {\n  var _props$initialState3, _props$initialState3$;\n\n  const logger = useGridLogger(apiRef, 'useGridColumns');\n  const columnsTypes = React.useMemo(() => computeColumnTypes(props.columnTypes), [props.columnTypes]);\n  /**\n   * If `initialState.columns.columnVisibilityModel` or `columnVisibilityModel` was defined during the 1st render, we are directly updating the model\n   * If not, we keep the old behavior and update the `GridColDef.hide` option (which will update the state model through the `GridColDef.hide` => `columnVisibilityModel` sync in `createColumnsState`\n   */\n\n  const shouldUseVisibleColumnModel = React.useRef(!!props.columnVisibilityModel || !!((_props$initialState3 = props.initialState) != null && (_props$initialState3$ = _props$initialState3.columns) != null && _props$initialState3$.columnVisibilityModel)).current;\n  apiRef.current.unstable_updateControlState({\n    stateId: 'visibleColumns',\n    propModel: props.columnVisibilityModel,\n    propOnChange: props.onColumnVisibilityModelChange,\n    stateSelector: gridColumnVisibilityModelSelector,\n    changeEvent: GridEvents.columnVisibilityModelChange\n  });\n  const setGridColumnsState = React.useCallback(columnsState => {\n    logger.debug('Updating columns state.');\n    apiRef.current.setState(setColumnsState(columnsState));\n    apiRef.current.forceUpdate();\n    apiRef.current.publishEvent(GridEvents.columnsChange, columnsState.all);\n  }, [logger, apiRef]);\n  /**\n   * API METHODS\n   */\n\n  const getColumn = React.useCallback(field => gridColumnLookupSelector(apiRef)[field], [apiRef]);\n  const getAllColumns = React.useCallback(() => gridColumnDefinitionsSelector(apiRef), [apiRef]);\n  const getVisibleColumns = React.useCallback(() => gridVisibleColumnDefinitionsSelector(apiRef), [apiRef]);\n  const getColumnsMeta = React.useCallback(() => gridColumnsMetaSelector(apiRef), [apiRef]);\n  const getColumnIndex = React.useCallback((field, useVisibleColumns = true) => {\n    const columns = useVisibleColumns ? gridVisibleColumnDefinitionsSelector(apiRef) : gridColumnDefinitionsSelector(apiRef);\n    return columns.findIndex(col => col.field === field);\n  }, [apiRef]);\n  const getColumnPosition = React.useCallback(field => {\n    const index = getColumnIndex(field);\n    return gridColumnPositionsSelector(apiRef)[index];\n  }, [apiRef, getColumnIndex]);\n  const setColumnVisibilityModel = React.useCallback(model => {\n    const currentModel = gridColumnVisibilityModelSelector(apiRef);\n\n    if (currentModel !== model) {\n      apiRef.current.setState(state => _extends({}, state, {\n        columns: createColumnsState({\n          apiRef,\n          columnsTypes,\n          columnsToUpsert: [],\n          shouldRegenColumnVisibilityModelFromColumns: false,\n          currentColumnVisibilityModel: model,\n          reset: false\n        })\n      }));\n      apiRef.current.forceUpdate();\n    }\n  }, [apiRef, columnsTypes]);\n  const updateColumns = React.useCallback(columns => {\n    const columnsState = createColumnsState({\n      apiRef,\n      columnsTypes,\n      columnsToUpsert: columns,\n      shouldRegenColumnVisibilityModelFromColumns: true,\n      reset: false\n    });\n    setGridColumnsState(columnsState);\n  }, [apiRef, setGridColumnsState, columnsTypes]);\n  const updateColumn = React.useCallback(column => apiRef.current.updateColumns([column]), [apiRef]);\n  const setColumnVisibility = React.useCallback((field, isVisible) => {\n    // We keep updating the `hide` option of `GridColDef` when not controlling the model to avoid any breaking change.\n    // `updateColumns` take care of updating the model itself if needs be.\n    // TODO v6: stop using the `hide` field even when the model is not defined\n    if (shouldUseVisibleColumnModel) {\n      var _columnVisibilityMode;\n\n      const columnVisibilityModel = gridColumnVisibilityModelSelector(apiRef);\n      const isCurrentlyVisible = (_columnVisibilityMode = columnVisibilityModel[field]) != null ? _columnVisibilityMode : true;\n\n      if (isVisible !== isCurrentlyVisible) {\n        const newModel = _extends({}, columnVisibilityModel, {\n          [field]: isVisible\n        });\n\n        apiRef.current.setColumnVisibilityModel(newModel);\n      }\n    } else {\n      const column = apiRef.current.getColumn(field);\n\n      const newColumn = _extends({}, column, {\n        hide: !isVisible\n      });\n\n      apiRef.current.updateColumns([newColumn]);\n      const params = {\n        field,\n        colDef: newColumn,\n        isVisible\n      };\n      apiRef.current.publishEvent(GridEvents.columnVisibilityChange, params);\n    }\n  }, [apiRef, shouldUseVisibleColumnModel]);\n  const setColumnIndex = React.useCallback((field, targetIndexPosition) => {\n    const allColumns = gridColumnFieldsSelector(apiRef);\n    const oldIndexPosition = allColumns.findIndex(col => col === field);\n\n    if (oldIndexPosition === targetIndexPosition) {\n      return;\n    }\n\n    logger.debug(\"Moving column \".concat(field, \" to index \").concat(targetIndexPosition));\n    const updatedColumns = [...allColumns];\n    updatedColumns.splice(targetIndexPosition, 0, updatedColumns.splice(oldIndexPosition, 1)[0]);\n    setGridColumnsState(_extends({}, gridColumnsSelector(apiRef.current.state), {\n      all: updatedColumns\n    }));\n    const params = {\n      field,\n      element: apiRef.current.getColumnHeaderElement(field),\n      colDef: apiRef.current.getColumn(field),\n      targetIndex: targetIndexPosition,\n      oldIndex: oldIndexPosition\n    };\n    apiRef.current.publishEvent(GridEvents.columnOrderChange, params);\n  }, [apiRef, logger, setGridColumnsState]);\n  const setColumnWidth = React.useCallback((field, width) => {\n    logger.debug(\"Updating column \".concat(field, \" width to \").concat(width));\n    const column = apiRef.current.getColumn(field);\n\n    const newColumn = _extends({}, column, {\n      width\n    });\n\n    apiRef.current.updateColumns([newColumn]);\n    apiRef.current.publishEvent(GridEvents.columnWidthChange, {\n      element: apiRef.current.getColumnHeaderElement(field),\n      colDef: newColumn,\n      width\n    });\n  }, [apiRef, logger]);\n  const columnApi = {\n    getColumn,\n    getAllColumns,\n    getColumnIndex,\n    getColumnPosition,\n    getVisibleColumns,\n    getColumnsMeta,\n    updateColumn,\n    updateColumns,\n    setColumnVisibilityModel,\n    setColumnVisibility,\n    setColumnIndex,\n    setColumnWidth\n  };\n  useGridApiMethod(apiRef, columnApi, 'GridColumnApi');\n  /**\n   * PRE-PROCESSING\n   */\n\n  const stateExportPreProcessing = React.useCallback(prevState => {\n    if (!shouldUseVisibleColumnModel) {\n      return prevState;\n    }\n\n    const columnVisibilityModelToExport = gridColumnVisibilityModelSelector(apiRef);\n    const hasHiddenColumns = Object.values(columnVisibilityModelToExport).some(value => value === false);\n\n    if (!hasHiddenColumns) {\n      return prevState;\n    }\n\n    return _extends({}, prevState, {\n      columns: {\n        columnVisibilityModel: columnVisibilityModelToExport\n      }\n    });\n  }, [apiRef, shouldUseVisibleColumnModel]);\n  const stateRestorePreProcessing = React.useCallback((params, context) => {\n    var _context$stateToResto;\n\n    if (!shouldUseVisibleColumnModel) {\n      return params;\n    }\n\n    const columnVisibilityModel = (_context$stateToResto = context.stateToRestore.columns) == null ? void 0 : _context$stateToResto.columnVisibilityModel;\n\n    if (columnVisibilityModel != null) {\n      const columnsState = createColumnsState({\n        apiRef,\n        columnsTypes,\n        columnsToUpsert: [],\n        shouldRegenColumnVisibilityModelFromColumns: false,\n        currentColumnVisibilityModel: columnVisibilityModel,\n        reset: false\n      });\n      apiRef.current.setState(setColumnsState(columnsState));\n    }\n\n    return params;\n  }, [apiRef, shouldUseVisibleColumnModel, columnsTypes]);\n  useGridRegisterPreProcessor(apiRef, 'exportState', stateExportPreProcessing);\n  useGridRegisterPreProcessor(apiRef, 'restoreState', stateRestorePreProcessing);\n  /**\n   * EVENTS\n   */\n\n  const handlePreProcessorRegister = React.useCallback(name => {\n    if (name !== 'hydrateColumns') {\n      return;\n    }\n\n    logger.info(\"Columns pre-processing have changed, regenerating the columns\");\n    const columnsState = createColumnsState({\n      apiRef,\n      columnsTypes,\n      columnsToUpsert: [],\n      shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,\n      reset: false\n    });\n    setGridColumnsState(columnsState);\n  }, [apiRef, logger, setGridColumnsState, columnsTypes, shouldUseVisibleColumnModel]);\n  const prevInnerWidth = React.useRef(null);\n\n  const handleGridSizeChange = viewportInnerSize => {\n    if (prevInnerWidth.current !== viewportInnerSize.width) {\n      prevInnerWidth.current = viewportInnerSize.width;\n      setGridColumnsState(hydrateColumnsWidth(gridColumnsSelector(apiRef.current.state), viewportInnerSize.width));\n    }\n  };\n\n  useGridApiEventHandler(apiRef, GridEvents.preProcessorRegister, handlePreProcessorRegister);\n  useGridApiEventHandler(apiRef, GridEvents.viewportInnerSizeChange, handleGridSizeChange);\n  useGridApiOptionHandler(apiRef, GridEvents.columnVisibilityChange, props.onColumnVisibilityChange);\n  /**\n   * EFFECTS\n   */\n  // The effect do not track any value defined synchronously during the 1st render by hooks called after `useGridColumns`\n  // As a consequence, the state generated by the 1st run of this useEffect will always be equal to the initialization one\n\n  const isFirstRender = React.useRef(true);\n  React.useEffect(() => {\n    if (isFirstRender.current) {\n      isFirstRender.current = false;\n      return;\n    }\n\n    logger.info(\"GridColumns have changed, new length \".concat(props.columns.length));\n    const columnsState = createColumnsState({\n      apiRef,\n      columnsTypes,\n      // If the user provides a model, we don't want to set it in the state here because it has it's dedicated `useEffect` which calls `setColumnVisibilityModel`\n      shouldRegenColumnVisibilityModelFromColumns: !shouldUseVisibleColumnModel,\n      columnsToUpsert: props.columns,\n      reset: true\n    });\n    setGridColumnsState(columnsState);\n  }, [logger, apiRef, setGridColumnsState, props.columns, columnsTypes, shouldUseVisibleColumnModel]);\n  React.useEffect(() => {\n    if (props.columnVisibilityModel !== undefined) {\n      apiRef.current.setColumnVisibilityModel(props.columnVisibilityModel);\n    }\n  }, [apiRef, logger, props.columnVisibilityModel]);\n}","map":null,"metadata":{},"sourceType":"module"}