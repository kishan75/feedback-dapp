{"ast":null,"code":"import { Stream } from '../../stream/Stream.js';\nimport { cloneIfNeeded, cloneMethod } from '../../check/symbols.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nexport class TupleArbitrary extends NextArbitrary {\n  constructor(arbs) {\n    super();\n    this.arbs = arbs;\n\n    for (let idx = 0; idx !== arbs.length; ++idx) {\n      const arb = arbs[idx];\n      if (arb == null || arb.generate == null) throw new Error(\"Invalid parameter encountered at index \".concat(idx, \": expecting an Arbitrary\"));\n    }\n  }\n\n  static makeItCloneable(vs, values) {\n    return Object.defineProperty(vs, cloneMethod, {\n      value: () => {\n        const cloned = [];\n\n        for (let idx = 0; idx !== values.length; ++idx) {\n          cloned.push(values[idx].value);\n        }\n\n        TupleArbitrary.makeItCloneable(cloned, values);\n        return cloned;\n      }\n    });\n  }\n\n  static wrapper(values) {\n    let cloneable = false;\n    const vs = [];\n    const ctxs = [];\n\n    for (let idx = 0; idx !== values.length; ++idx) {\n      const v = values[idx];\n      cloneable = cloneable || v.hasToBeCloned;\n      vs.push(v.value);\n      ctxs.push(v.context);\n    }\n\n    if (cloneable) {\n      TupleArbitrary.makeItCloneable(vs, values);\n    }\n\n    return new NextValue(vs, ctxs);\n  }\n\n  generate(mrng, biasFactor) {\n    return TupleArbitrary.wrapper(this.arbs.map(a => a.generate(mrng, biasFactor)));\n  }\n\n  canShrinkWithoutContext(value) {\n    if (!Array.isArray(value) || value.length !== this.arbs.length) {\n      return false;\n    }\n\n    for (let index = 0; index !== this.arbs.length; ++index) {\n      if (!this.arbs[index].canShrinkWithoutContext(value[index])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  shrink(value, context) {\n    let s = Stream.nil();\n    const safeContext = Array.isArray(context) ? context : [];\n\n    for (let idx = 0; idx !== this.arbs.length; ++idx) {\n      const shrinksForIndex = this.arbs[idx].shrink(value[idx], safeContext[idx]).map(v => {\n        const nextValues = value.map((v, idx) => new NextValue(cloneIfNeeded(v), safeContext[idx]));\n        return nextValues.slice(0, idx).concat([v]).concat(nextValues.slice(idx + 1));\n      }).map(values => TupleArbitrary.wrapper(values));\n      s = s.join(shrinksForIndex);\n    }\n\n    return s;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}