{"ast":null,"code":"\"use strict\";\n\nvar _slicedToArray = require(\"F:\\\\BlockChain\\\\Projects\\\\feedback-dapp\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/slicedToArray\");\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.storageSize = exports.getStateAllocations = exports.getStorageAllocations = exports.UnknownBaseContractIdError = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:storage:allocate\");\n\nconst Compiler = __importStar(require(\"../../compiler\"));\n\nconst Common = __importStar(require(\"../../common\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Utils = __importStar(require(\"../utils\"));\n\nconst Ast = __importStar(require(\"../../ast\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst Format = __importStar(require(\"../../format\"));\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst partition_1 = __importDefault(require(\"lodash/partition\"));\n\nclass UnknownBaseContractIdError extends Error {\n  constructor(derivedId, derivedName, derivedKind, baseId) {\n    const message = \"Cannot locate base contract ID \".concat(baseId, \" of \").concat(derivedKind, \" \").concat(derivedName, \" (ID \").concat(derivedId, \")\");\n    super(message);\n    this.name = \"UnknownBaseContractIdError\";\n    this.derivedId = derivedId;\n    this.derivedName = derivedName;\n    this.derivedKind = derivedKind;\n    this.baseId = baseId;\n  }\n\n}\n\nexports.UnknownBaseContractIdError = UnknownBaseContractIdError; //contracts contains only the contracts to be allocated; any base classes not\n//being allocated should just be in referenceDeclarations\n\nfunction getStorageAllocations(userDefinedTypesByCompilation) {\n  let allocations = {};\n\n  for (const compilation of Object.values(userDefinedTypesByCompilation)) {\n    const compiler = compilation.compiler,\n          userDefinedTypes = compilation.types;\n\n    for (const dataType of Object.values(compilation.types)) {\n      if (dataType.typeClass === \"struct\") {\n        try {\n          allocations = allocateStruct(dataType, userDefinedTypes, allocations, compiler);\n        } catch (_a) {//if allocation fails... oh well, allocation fails, we do nothing and just move on :P\n          //note: a better way of handling this would probably be to *mark* it\n          //as failed rather than throwing an exception as that would lead to less\n          //recomputation, but this is simpler and I don't think the recomputation\n          //should really be a problem\n        }\n      }\n    }\n  }\n\n  return allocations;\n}\n\nexports.getStorageAllocations = getStorageAllocations;\n/**\n * This function gets allocations for the state variables of the contracts;\n * this is distinct from getStorageAllocations, which gets allocations for\n * storage structs.\n *\n * While mostly state variables are kept in storage, constant ones are not.\n * And immutable ones, once those are introduced, will be kept in code!\n * (But those don't exist yet so this function doesn't handle them yet.)\n */\n\nfunction getStateAllocations(contracts, referenceDeclarations, userDefinedTypes, storageAllocations, existingAllocations = {}) {\n  let allocations = existingAllocations;\n\n  for (const contractInfo of contracts) {\n    let contract = contractInfo.contractNode,\n        immutableReferences = contractInfo.immutableReferences,\n        compiler = contractInfo.compiler,\n        compilationId = contractInfo.compilationId;\n\n    try {\n      allocations = allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations[compilationId], userDefinedTypes, storageAllocations, allocations);\n    } catch (_a) {//we're just going to allow failure here and catch the problem elsewhere\n    }\n  }\n\n  return allocations;\n}\n\nexports.getStateAllocations = getStateAllocations;\n\nfunction allocateStruct(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //NOTE: dataType here should be a *stored* type!\n  //it is up to the caller to take care of this\n  return allocateMembers(dataType.id, dataType.memberTypes, userDefinedTypes, existingAllocations, compiler);\n}\n\nfunction allocateMembers(parentId, members, userDefinedTypes, existingAllocations, compiler) {\n  let offset = 0; //will convert to BN when placing in slot\n\n  let index = Evm.Utils.WORD_SIZE - 1; //don't allocate things that have already been allocated\n\n  if (parentId in existingAllocations) {\n    return existingAllocations;\n  }\n\n  let allocations = Object.assign({}, existingAllocations); //otherwise, we'll be adding to this, so we better clone\n  //otherwise, we need to allocate\n\n  let memberAllocations = [];\n\n  for (const member of members) {\n    let size;\n\n    var _storageSizeAndAlloca = storageSizeAndAllocate(member.type, userDefinedTypes, allocations, compiler);\n\n    size = _storageSizeAndAlloca.size;\n    allocations = _storageSizeAndAlloca.allocations;\n\n    //if it's sized in words (and we're not at the start of slot) we need to start on a new slot\n    //if it's sized in bytes but there's not enough room, we also need a new slot\n    if (Utils.isWordsLength(size) ? index < Evm.Utils.WORD_SIZE - 1 : size.bytes > index + 1) {\n      index = Evm.Utils.WORD_SIZE - 1;\n      offset += 1;\n    } //otherwise, we remain in place\n\n\n    let range;\n\n    if (Utils.isWordsLength(size)) {\n      //words case\n      range = {\n        from: {\n          slot: {\n            offset: new bn_js_1.default(offset) //start at the current slot...\n\n          },\n          index: 0 //...at the beginning of the word.\n\n        },\n        to: {\n          slot: {\n            offset: new bn_js_1.default(offset + size.words - 1) //end at the current slot plus # of words minus 1...\n\n          },\n          index: Evm.Utils.WORD_SIZE - 1 //...at the end of the word.\n\n        }\n      };\n    } else {\n      //bytes case\n      range = {\n        from: {\n          slot: {\n            offset: new bn_js_1.default(offset) //start at the current slot...\n\n          },\n          index: index - (size.bytes - 1) //...early enough to fit what's being allocated.\n\n        },\n        to: {\n          slot: {\n            offset: new bn_js_1.default(offset) //end at the current slot...\n\n          },\n          index: index //...at the current position.\n\n        }\n      };\n    }\n\n    memberAllocations.push({\n      name: member.name,\n      type: member.type,\n      pointer: {\n        location: \"storage\",\n        range\n      }\n    }); //finally, adjust the current position.\n    //if it was sized in words, move down that many slots and reset position w/in slot\n\n    if (Utils.isWordsLength(size)) {\n      offset += size.words;\n      index = Evm.Utils.WORD_SIZE - 1;\n    } //if it was sized in bytes, move down an appropriate number of bytes.\n    else {\n        index -= size.bytes; //but if this puts us into the next word, move to the next word.\n\n        if (index < 0) {\n          index = Evm.Utils.WORD_SIZE - 1;\n          offset += 1;\n        }\n      }\n  } //finally, let's determine the overall siz; we're dealing with a struct, so\n  //the size is measured in words\n  //it's one plus the last word used, i.e. one plus the current word... unless the\n  //current word remains entirely unused, then it's just the current word\n  //SPECIAL CASE: if *nothing* has been used, allocate a single word (that's how\n  //empty structs behave in versions where they're legal)\n\n\n  let totalSize;\n\n  if (index === Evm.Utils.WORD_SIZE - 1 && offset !== 0) {\n    totalSize = {\n      words: offset\n    };\n  } else {\n    totalSize = {\n      words: offset + 1\n    };\n  } //having made our allocation, let's add it to allocations!\n\n\n  allocations[parentId] = {\n    members: memberAllocations,\n    size: totalSize\n  }; //...and we're done!\n\n  return allocations;\n}\n\nfunction getStateVariables(contractNode) {\n  // process for state variables\n  return contractNode.nodes.filter(node => node.nodeType === \"VariableDeclaration\" && node.stateVariable);\n}\n\nfunction allocateContractState(contract, immutableReferences, compilationId, compiler, referenceDeclarations, userDefinedTypes, storageAllocations, existingAllocations = {}) {\n  //we're going to do a 2-deep clone here\n  let allocations = Object.assign({}, ...Object.entries(existingAllocations).map(([compilationId, compilationAllocations]) => ({\n    [compilationId]: Object.assign({}, compilationAllocations)\n  })));\n\n  if (!immutableReferences) {\n    immutableReferences = {}; //also, let's set this up for convenience\n  } //base contracts are listed from most derived to most base, so we\n  //have to reverse before processing, but reverse() is in place, so we\n  //clone with slice first\n\n\n  let linearizedBaseContractsFromBase = contract.linearizedBaseContracts.slice().reverse(); //first, let's get all the variables under consideration\n\n  let variables = [].concat(...linearizedBaseContractsFromBase.map(id => {\n    let baseNode = referenceDeclarations[id];\n\n    if (baseNode === undefined) {\n      throw new UnknownBaseContractIdError(contract.id, contract.name, contract.contractKind, id);\n    }\n\n    return getStateVariables(baseNode).map(definition => ({\n      definition,\n      definedIn: baseNode\n    }));\n  })); //just in case the constant field ever gets removed\n\n  const isConstant = definition => definition.constant || definition.mutability === \"constant\"; //now: we split the variables into storage, constant, and code\n\n\n  let _partition_1$default = partition_1.default(variables, variable => isConstant(variable.definition)),\n      _partition_1$default2 = _slicedToArray(_partition_1$default, 2),\n      constantVariables = _partition_1$default2[0],\n      variableVariables = _partition_1$default2[1]; //why use this function instead of just checking\n  //definition.mutability?\n  //because of a bug in Solidity 0.6.5 that causes the mutability field\n  //not to exist.  So, we also have to check against immutableReferences.\n\n\n  const isImmutable = definition => definition.mutability === \"immutable\" || definition.id.toString() in immutableReferences;\n\n  let _partition_1$default3 = partition_1.default(variableVariables, variable => isImmutable(variable.definition)),\n      _partition_1$default4 = _slicedToArray(_partition_1$default3, 2),\n      immutableVariables = _partition_1$default4[0],\n      storageVariables = _partition_1$default4[1]; //transform storage variables into data types\n\n\n  const storageVariableTypes = storageVariables.map(variable => ({\n    name: variable.definition.name,\n    type: Ast.Import.definitionToType(variable.definition, compilationId, compiler)\n  })); //let's allocate the storage variables using a fictitious ID\n\n  const id = \"-1\";\n  const storageVariableStorageAllocations = allocateMembers(id, storageVariableTypes, userDefinedTypes, storageAllocations, compiler)[id]; //transform to new format\n\n  const storageVariableAllocations = storageVariables.map(({\n    definition,\n    definedIn\n  }, index) => ({\n    definition,\n    definedIn,\n    compilationId,\n    pointer: storageVariableStorageAllocations.members[index].pointer\n  })); //now let's create allocations for the immutables\n\n  let immutableVariableAllocations = immutableVariables.map(({\n    definition,\n    definedIn\n  }) => {\n    let references = immutableReferences[definition.id.toString()] || [];\n    let pointer;\n\n    if (references.length === 0) {\n      pointer = {\n        location: \"nowhere\"\n      };\n    } else {\n      pointer = {\n        location: \"code\",\n        start: references[0].start,\n        length: references[0].length\n      };\n    }\n\n    return {\n      definition,\n      definedIn,\n      compilationId,\n      pointer\n    };\n  }); //and let's create allocations for the constants\n\n  let constantVariableAllocations = constantVariables.map(({\n    definition,\n    definedIn\n  }) => ({\n    definition,\n    definedIn,\n    compilationId,\n    pointer: {\n      location: \"definition\",\n      definition: definition.value\n    }\n  })); //now, reweave the three together\n\n  let contractAllocation = [];\n\n  for (let variable of variables) {\n    let arrayToGrabFrom = isConstant(variable.definition) ? constantVariableAllocations : isImmutable(variable.definition) ? immutableVariableAllocations : storageVariableAllocations;\n    contractAllocation.push(arrayToGrabFrom.shift()); //note that push and shift both modify!\n  } //finally, set things and return\n\n\n  if (!allocations[compilationId]) {\n    allocations[compilationId] = {};\n  }\n\n  allocations[compilationId][contract.id] = {\n    members: contractAllocation\n  };\n  return allocations;\n} //NOTE: This wrapper function is for use in decoding ONLY, after allocation is done.\n//The allocator should (and does) instead use a direct call to storageSizeAndAllocate,\n//not to the wrapper, because it may need the allocations returned.\n\n\nfunction storageSize(dataType, userDefinedTypes, allocations, compiler) {\n  return storageSizeAndAllocate(dataType, userDefinedTypes, allocations, compiler).size;\n}\n\nexports.storageSize = storageSize;\n\nfunction storageSizeAndAllocate(dataType, userDefinedTypes, existingAllocations, compiler) {\n  //we'll only directly handle reference types here;\n  //direct types will be handled by dispatching to Basic.Allocate.byteLength\n  //in the default case\n  switch (dataType.typeClass) {\n    case \"bytes\":\n      {\n        switch (dataType.kind) {\n          case \"static\":\n            //really a basic type :)\n            return {\n              size: {\n                bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n              },\n              allocations: existingAllocations\n            };\n\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n        }\n      }\n\n    case \"string\":\n    case \"mapping\":\n      return {\n        size: {\n          words: 1\n        },\n        allocations: existingAllocations\n      };\n\n    case \"array\":\n      {\n        switch (dataType.kind) {\n          case \"dynamic\":\n            return {\n              size: {\n                words: 1\n              },\n              allocations: existingAllocations\n            };\n\n          case \"static\":\n            //static array case\n            const length = dataType.length.toNumber(); //warning! but if it's too big we have a problem\n\n            if (length === 0) {\n              //in versions of Solidity where it's legal, arrays of length 0 still take up 1 word\n              return {\n                size: {\n                  words: 1\n                },\n                allocations: existingAllocations\n              };\n            }\n\n            let _storageSizeAndAlloca2 = storageSizeAndAllocate(dataType.baseType, userDefinedTypes, existingAllocations),\n                baseSize = _storageSizeAndAlloca2.size,\n                allocations = _storageSizeAndAlloca2.allocations;\n\n            if (!Utils.isWordsLength(baseSize)) {\n              //bytes case\n              const perWord = Math.floor(Evm.Utils.WORD_SIZE / baseSize.bytes);\n              debug(\"length %o\", length);\n              const numWords = Math.ceil(length / perWord);\n              return {\n                size: {\n                  words: numWords\n                },\n                allocations\n              };\n            } else {\n              //words case\n              return {\n                size: {\n                  words: baseSize.words * length\n                },\n                allocations\n              };\n            }\n\n        }\n      }\n\n    case \"struct\":\n      {\n        let allocations = existingAllocations;\n        let allocation = allocations[dataType.id]; //may be undefined!\n\n        if (allocation === undefined) {\n          //if we don't find an allocation, we'll have to do the allocation ourselves\n          const storedType = userDefinedTypes[dataType.id];\n\n          if (!storedType) {\n            throw new Common.UnknownUserDefinedTypeError(dataType.id, Format.Types.typeString(dataType));\n          }\n\n          allocations = allocateStruct(storedType, userDefinedTypes, existingAllocations);\n          allocation = allocations[dataType.id];\n        } //having found our allocation, we can just look up its size\n\n\n        return {\n          size: allocation.size,\n          allocations\n        };\n      }\n\n    case \"userDefinedValueType\":\n      if (Compiler.Utils.solidityFamily(compiler) === \"0.8.7+\") {\n        //UDVTs were introduced in Solidity 0.8.8.  However, in that version,\n        //and that version only, they have a bug where they always take up a\n        //full word in storage regardless of the size of the underlying type.\n        return {\n          size: {\n            words: 1\n          },\n          allocations: existingAllocations\n        };\n      }\n\n    //otherwise, treat them normally\n    //DELIBERATE FALL-TRHOUGH\n\n    default:\n      //otherwise, it's a direct type\n      return {\n        size: {\n          bytes: Basic.Allocate.byteLength(dataType, userDefinedTypes)\n        },\n        allocations: existingAllocations\n      };\n  }\n}","map":null,"metadata":{},"sourceType":"script"}