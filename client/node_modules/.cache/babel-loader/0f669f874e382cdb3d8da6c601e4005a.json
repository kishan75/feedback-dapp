{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst util = require('util');\n\nconst Decoder = require('./decoder');\n\nconst Simple = require('./simple');\n\nconst utils = require('./utils');\n\nconst constants = require('./constants');\n\nconst bignumber = require('bignumber.js').BigNumber;\n\nconst NoFilter = require('nofilter');\n\nconst MT = constants.MT;\nconst SYMS = constants.SYMS;\n/**\n * Output the diagnostic format from a stream of CBOR bytes.\n *\n * @extends {stream.Transform}\n */\n\nclass Diagnose extends stream.Transform {\n  /**\n   * Creates an instance of Diagnose.\n   *\n   * @param {Object} [options={}] - options for creation\n   * @param {string} [options.separator='\\n'] - output between detected objects\n   * @param {boolean} [options.stream_errors=false] - put error info into the\n   *   output stream\n   * @param {number} [options.max_depth=-1] - -1 for \"until you run out of\n   *   memory\".  Set this to a finite positive number for un-trusted inputs.\n   *   Most standard inputs won't nest more than 100 or so levels; I've tested\n   *   into the millions before running out of memory.\n   */\n  constructor(options) {\n    const opts = Object.assign({\n      separator: '\\n',\n      stream_errors: false\n    }, options, {\n      readableObjectMode: false,\n      writableObjectMode: false\n    });\n    const separator = opts.separator;\n    delete opts.separator;\n    const stream_errors = opts.stream_errors;\n    delete opts.stream_errors;\n    super(opts);\n    this.float_bytes = -1;\n    this.separator = separator;\n    this.stream_errors = stream_errors;\n    this.parser = new Decoder(opts);\n    this.parser.on('more-bytes', this._on_more.bind(this));\n    this.parser.on('value', this._on_value.bind(this));\n    this.parser.on('start', this._on_start.bind(this));\n    this.parser.on('stop', this._on_stop.bind(this));\n    this.parser.on('data', this._on_data.bind(this));\n    this.parser.on('error', this._on_error.bind(this));\n  }\n\n  _transform(fresh, encoding, cb) {\n    return this.parser.write(fresh, encoding, cb);\n  }\n\n  _flush(cb) {\n    return this.parser._flush(er => {\n      if (this.stream_errors) {\n        if (er) {\n          this._on_error(er);\n        }\n\n        return cb();\n      } else {\n        return cb(er);\n      }\n    });\n  }\n  /**\n   * Convenience function to return a string in diagnostic format.\n   *\n   * @param {(Buffer|string)} input - the CBOR bytes to format\n   * @param {string} [encoding='hex'] - the encoding of input, ignored if\n   *   input is Buffer\n   * @param {function(Error, string): undefined} cb - callback\n   * @returns {Promise} if callback not specified\n   */\n\n\n  static diagnose(input, encoding, cb) {\n    if (input == null) {\n      throw new Error('input required');\n    }\n\n    let opts = {};\n    let encod = 'hex';\n\n    switch (typeof encoding) {\n      case 'function':\n        cb = encoding;\n        encod = utils.guessEncoding(input);\n        break;\n\n      case 'object':\n        opts = utils.extend({}, encoding);\n        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);\n        delete opts.encoding;\n        break;\n\n      default:\n        encod = encoding != null ? encoding : 'hex';\n    }\n\n    const bs = new NoFilter();\n    const d = new Diagnose(opts);\n    let p = null;\n\n    if (typeof cb === 'function') {\n      d.on('end', () => cb(null, bs.toString('utf8')));\n      d.on('error', cb);\n    } else {\n      p = new Promise((resolve, reject) => {\n        d.on('end', () => resolve(bs.toString('utf8')));\n        return d.on('error', reject);\n      });\n    }\n\n    d.pipe(bs);\n    d.end(input, encod);\n    return p;\n  }\n\n  _on_error(er) {\n    if (this.stream_errors) {\n      return this.push(er.toString());\n    } else {\n      return this.emit('error', er);\n    }\n  }\n\n  _on_more(mt, len, parent_mt, pos) {\n    if (mt === MT.SIMPLE_FLOAT) {\n      return this.float_bytes = {\n        2: 1,\n        4: 2,\n        8: 3\n      }[len];\n    }\n  }\n\n  _fore(parent_mt, pos) {\n    switch (parent_mt) {\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n      case MT.ARRAY:\n        if (pos > 0) {\n          return this.push(', ');\n        }\n\n        break;\n\n      case MT.MAP:\n        if (pos > 0) {\n          if (pos % 2) {\n            return this.push(': ');\n          } else {\n            return this.push(', ');\n          }\n        }\n\n    }\n  }\n\n  _on_value(val, parent_mt, pos) {\n    if (val === SYMS.BREAK) {\n      return;\n    }\n\n    this._fore(parent_mt, pos);\n\n    return this.push((() => {\n      switch (false) {\n        case val !== SYMS.NULL:\n          return 'null';\n\n        case val !== SYMS.UNDEFINED:\n          return 'undefined';\n\n        case typeof val !== 'string':\n          return JSON.stringify(val);\n\n        case !(this.float_bytes > 0):\n          const fb = this.float_bytes;\n          this.float_bytes = -1;\n          return util.inspect(val) + '_' + fb;\n\n        case !Buffer.isBuffer(val):\n          return 'h\\'' + val.toString('hex') + '\\'';\n\n        case !(val instanceof bignumber):\n          return val.toString();\n\n        default:\n          return util.inspect(val);\n      }\n    })());\n  }\n\n  _on_start(mt, tag, parent_mt, pos) {\n    this._fore(parent_mt, pos);\n\n    switch (mt) {\n      case MT.TAG:\n        this.push(\"\".concat(tag, \"(\"));\n        break;\n\n      case MT.ARRAY:\n        this.push('[');\n        break;\n\n      case MT.MAP:\n        this.push('{');\n        break;\n\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        this.push('(');\n        break;\n    }\n\n    if (tag === SYMS.STREAM) {\n      return this.push('_ ');\n    }\n  }\n\n  _on_stop(mt) {\n    switch (mt) {\n      case MT.TAG:\n        return this.push(')');\n\n      case MT.ARRAY:\n        return this.push(']');\n\n      case MT.MAP:\n        return this.push('}');\n\n      case MT.BYTE_STRING:\n      case MT.UTF8_STRING:\n        return this.push(')');\n    }\n  }\n\n  _on_data() {\n    return this.push(this.separator);\n  }\n\n}\n\nmodule.exports = Diagnose;","map":null,"metadata":{},"sourceType":"script"}