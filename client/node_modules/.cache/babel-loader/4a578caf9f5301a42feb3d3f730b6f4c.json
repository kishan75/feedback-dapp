{"ast":null,"code":"import { RunExecution } from './reporter/RunExecution.js';\nexport class RunnerIterator {\n  constructor(sourceValues, shrink, verbose, interruptedAsFailure) {\n    this.sourceValues = sourceValues;\n    this.shrink = shrink;\n    this.runExecution = new RunExecution(verbose, interruptedAsFailure);\n    this.currentIdx = -1;\n    this.nextValues = sourceValues;\n  }\n\n  [Symbol.iterator]() {\n    return this;\n  }\n\n  next() {\n    const nextValue = this.nextValues.next();\n\n    if (nextValue.done || this.runExecution.interrupted) {\n      return {\n        done: true,\n        value: undefined\n      };\n    }\n\n    this.currentValue = nextValue.value;\n    ++this.currentIdx;\n    return {\n      done: false,\n      value: nextValue.value.value_\n    };\n  }\n\n  handleResult(result) {\n    if (result != null && typeof result === 'string') {\n      this.runExecution.fail(this.currentValue.value_, this.currentIdx, result);\n      this.currentIdx = -1;\n      this.nextValues = this.shrink(this.currentValue);\n    } else if (result != null) {\n      if (!result.interruptExecution) {\n        this.runExecution.skip(this.currentValue.value_);\n        this.sourceValues.skippedOne();\n      } else {\n        this.runExecution.interrupt();\n      }\n    } else {\n      this.runExecution.success(this.currentValue.value_);\n    }\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}