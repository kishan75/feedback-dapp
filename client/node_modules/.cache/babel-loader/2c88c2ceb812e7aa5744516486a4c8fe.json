{"ast":null,"code":"'use strict';\n\nconst Mixin = require('../../utils/mixin');\n\nconst Tokenizer = require('../../tokenizer');\n\nconst LocationInfoTokenizerMixin = require('./tokenizer-mixin');\n\nconst LocationInfoOpenElementStackMixin = require('./open-element-stack-mixin');\n\nconst HTML = require('../../common/html'); //Aliases\n\n\nconst $ = HTML.TAG_NAMES;\n\nclass LocationInfoParserMixin extends Mixin {\n  constructor(parser) {\n    super(parser);\n    this.parser = parser;\n    this.treeAdapter = this.parser.treeAdapter;\n    this.posTracker = null;\n    this.lastStartTagToken = null;\n    this.lastFosterParentingLocation = null;\n    this.currentToken = null;\n  }\n\n  _setStartLocation(element) {\n    let loc = null;\n\n    if (this.lastStartTagToken) {\n      loc = Object.assign({}, this.lastStartTagToken.location);\n      loc.startTag = this.lastStartTagToken.location;\n    }\n\n    this.treeAdapter.setNodeSourceCodeLocation(element, loc);\n  }\n\n  _setEndLocation(element, closingToken) {\n    const loc = this.treeAdapter.getNodeSourceCodeLocation(element);\n\n    if (loc) {\n      if (closingToken.location) {\n        const ctLoc = closingToken.location;\n        const tn = this.treeAdapter.getTagName(element); // NOTE: For cases like <p> <p> </p> - First 'p' closes without a closing\n        // tag and for cases like <td> <p> </td> - 'p' closes without a closing tag.\n\n        const isClosingEndTag = closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;\n        const endLoc = {};\n\n        if (isClosingEndTag) {\n          endLoc.endTag = Object.assign({}, ctLoc);\n          endLoc.endLine = ctLoc.endLine;\n          endLoc.endCol = ctLoc.endCol;\n          endLoc.endOffset = ctLoc.endOffset;\n        } else {\n          endLoc.endLine = ctLoc.startLine;\n          endLoc.endCol = ctLoc.startCol;\n          endLoc.endOffset = ctLoc.startOffset;\n        }\n\n        this.treeAdapter.updateNodeSourceCodeLocation(element, endLoc);\n      }\n    }\n  }\n\n  _getOverriddenMethods(mxn, orig) {\n    return {\n      _bootstrap(document, fragmentContext) {\n        orig._bootstrap.call(this, document, fragmentContext);\n\n        mxn.lastStartTagToken = null;\n        mxn.lastFosterParentingLocation = null;\n        mxn.currentToken = null;\n        const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);\n        mxn.posTracker = tokenizerMixin.posTracker;\n        Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {\n          onItemPop: function (element) {\n            mxn._setEndLocation(element, mxn.currentToken);\n          }\n        });\n      },\n\n      _runParsingLoop(scriptHandler) {\n        orig._runParsingLoop.call(this, scriptHandler); // NOTE: generate location info for elements\n        // that remains on open element stack\n\n\n        for (let i = this.openElements.stackTop; i >= 0; i--) {\n          mxn._setEndLocation(this.openElements.items[i], mxn.currentToken);\n        }\n      },\n\n      //Token processing\n      _processTokenInForeignContent(token) {\n        mxn.currentToken = token;\n\n        orig._processTokenInForeignContent.call(this, token);\n      },\n\n      _processToken(token) {\n        mxn.currentToken = token;\n\n        orig._processToken.call(this, token); //NOTE: <body> and <html> are never popped from the stack, so we need to updated\n        //their end location explicitly.\n\n\n        const requireExplicitUpdate = token.type === Tokenizer.END_TAG_TOKEN && (token.tagName === $.HTML || token.tagName === $.BODY && this.openElements.hasInScope($.BODY));\n\n        if (requireExplicitUpdate) {\n          for (let i = this.openElements.stackTop; i >= 0; i--) {\n            const element = this.openElements.items[i];\n\n            if (this.treeAdapter.getTagName(element) === token.tagName) {\n              mxn._setEndLocation(element, token);\n\n              break;\n            }\n          }\n        }\n      },\n\n      //Doctype\n      _setDocumentType(token) {\n        orig._setDocumentType.call(this, token);\n\n        const documentChildren = this.treeAdapter.getChildNodes(this.document);\n        const cnLength = documentChildren.length;\n\n        for (let i = 0; i < cnLength; i++) {\n          const node = documentChildren[i];\n\n          if (this.treeAdapter.isDocumentTypeNode(node)) {\n            this.treeAdapter.setNodeSourceCodeLocation(node, token.location);\n            break;\n          }\n        }\n      },\n\n      //Elements\n      _attachElementToTree(element) {\n        //NOTE: _attachElementToTree is called from _appendElement, _insertElement and _insertTemplate methods.\n        //So we will use token location stored in this methods for the element.\n        mxn._setStartLocation(element);\n\n        mxn.lastStartTagToken = null;\n\n        orig._attachElementToTree.call(this, element);\n      },\n\n      _appendElement(token, namespaceURI) {\n        mxn.lastStartTagToken = token;\n\n        orig._appendElement.call(this, token, namespaceURI);\n      },\n\n      _insertElement(token, namespaceURI) {\n        mxn.lastStartTagToken = token;\n\n        orig._insertElement.call(this, token, namespaceURI);\n      },\n\n      _insertTemplate(token) {\n        mxn.lastStartTagToken = token;\n\n        orig._insertTemplate.call(this, token);\n\n        const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);\n        this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);\n      },\n\n      _insertFakeRootElement() {\n        orig._insertFakeRootElement.call(this);\n\n        this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);\n      },\n\n      //Comments\n      _appendCommentNode(token, parent) {\n        orig._appendCommentNode.call(this, token, parent);\n\n        const children = this.treeAdapter.getChildNodes(parent);\n        const commentNode = children[children.length - 1];\n        this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);\n      },\n\n      //Text\n      _findFosterParentingLocation() {\n        //NOTE: store last foster parenting location, so we will be able to find inserted text\n        //in case of foster parenting\n        mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);\n        return mxn.lastFosterParentingLocation;\n      },\n\n      _insertCharacters(token) {\n        orig._insertCharacters.call(this, token);\n\n        const hasFosterParent = this._shouldFosterParentOnInsertion();\n\n        const parent = hasFosterParent && mxn.lastFosterParentingLocation.parent || this.openElements.currentTmplContent || this.openElements.current;\n        const siblings = this.treeAdapter.getChildNodes(parent);\n        const textNodeIdx = hasFosterParent && mxn.lastFosterParentingLocation.beforeElement ? siblings.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1 : siblings.length - 1;\n        const textNode = siblings[textNodeIdx]; //NOTE: if we have location assigned by another token, then just update end position\n\n        const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);\n\n        if (tnLoc) {\n          const _token$location = token.location,\n                endLine = _token$location.endLine,\n                endCol = _token$location.endCol,\n                endOffset = _token$location.endOffset;\n          this.treeAdapter.updateNodeSourceCodeLocation(textNode, {\n            endLine,\n            endCol,\n            endOffset\n          });\n        } else {\n          this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);\n        }\n      }\n\n    };\n  }\n\n}\n\nmodule.exports = LocationInfoParserMixin;","map":null,"metadata":{},"sourceType":"script"}