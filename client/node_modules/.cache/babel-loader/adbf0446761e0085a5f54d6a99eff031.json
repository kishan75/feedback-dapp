{"ast":null,"code":"/**\n * @param {string} value\n * @returns {RegExp}\n * */\n\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\nfunction source(re) {\n  if (!re) return null;\n  if (typeof re === \"string\") return re;\n  return re.source;\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\n\n\nfunction lookahead(re) {\n  return concat('(?=', re, ')');\n}\n/**\n * @param {RegExp | string } re\n * @returns {string}\n */\n\n\nfunction optional(re) {\n  return concat('(', re, ')?');\n}\n/**\n * @param {...(RegExp | string) } args\n * @returns {string}\n */\n\n\nfunction concat(...args) {\n  const joined = args.map(x => source(x)).join(\"\");\n  return joined;\n}\n/**\n * Any of the passed expresssions may match\n *\n * Creates a huge this | this | that | that match\n * @param {(RegExp | string)[] } args\n * @returns {string}\n */\n\n\nfunction either(...args) {\n  const joined = '(' + args.map(x => source(x)).join(\"|\") + \")\";\n  return joined;\n}\n/*\nLanguage: HTML, XML\nWebsite: https://www.w3.org/XML/\nCategory: common\nAudit: 2020\n*/\n\n/** @type LanguageFn */\n\n\nfunction xml(hljs) {\n  // Element names can contain letters, digits, hyphens, underscores, and periods\n  const TAG_NAME_RE = concat(/[A-Z_]/, optional(/[A-Z0-9_.-]*:/), /[A-Z0-9_.-]*/);\n  const XML_IDENT_RE = /[A-Za-z0-9._:-]+/;\n  const XML_ENTITIES = {\n    className: 'symbol',\n    begin: /&[a-z]+;|&#[0-9]+;|&#x[a-f0-9]+;/\n  };\n  const XML_META_KEYWORDS = {\n    begin: /\\s/,\n    contains: [{\n      className: 'meta-keyword',\n      begin: /#?[a-z_][a-z1-9_-]+/,\n      illegal: /\\n/\n    }]\n  };\n  const XML_META_PAR_KEYWORDS = hljs.inherit(XML_META_KEYWORDS, {\n    begin: /\\(/,\n    end: /\\)/\n  });\n  const APOS_META_STRING_MODE = hljs.inherit(hljs.APOS_STRING_MODE, {\n    className: 'meta-string'\n  });\n  const QUOTE_META_STRING_MODE = hljs.inherit(hljs.QUOTE_STRING_MODE, {\n    className: 'meta-string'\n  });\n  const TAG_INTERNALS = {\n    endsWithParent: true,\n    illegal: /</,\n    relevance: 0,\n    contains: [{\n      className: 'attr',\n      begin: XML_IDENT_RE,\n      relevance: 0\n    }, {\n      begin: /=\\s*/,\n      relevance: 0,\n      contains: [{\n        className: 'string',\n        endsParent: true,\n        variants: [{\n          begin: /\"/,\n          end: /\"/,\n          contains: [XML_ENTITIES]\n        }, {\n          begin: /'/,\n          end: /'/,\n          contains: [XML_ENTITIES]\n        }, {\n          begin: /[^\\s\"'=<>`]+/\n        }]\n      }]\n    }]\n  };\n  return {\n    name: 'HTML, XML',\n    aliases: ['html', 'xhtml', 'rss', 'atom', 'xjb', 'xsd', 'xsl', 'plist', 'wsf', 'svg'],\n    case_insensitive: true,\n    contains: [{\n      className: 'meta',\n      begin: /<![a-z]/,\n      end: />/,\n      relevance: 10,\n      contains: [XML_META_KEYWORDS, QUOTE_META_STRING_MODE, APOS_META_STRING_MODE, XML_META_PAR_KEYWORDS, {\n        begin: /\\[/,\n        end: /\\]/,\n        contains: [{\n          className: 'meta',\n          begin: /<![a-z]/,\n          end: />/,\n          contains: [XML_META_KEYWORDS, XML_META_PAR_KEYWORDS, QUOTE_META_STRING_MODE, APOS_META_STRING_MODE]\n        }]\n      }]\n    }, hljs.COMMENT(/<!--/, /-->/, {\n      relevance: 10\n    }), {\n      begin: /<!\\[CDATA\\[/,\n      end: /\\]\\]>/,\n      relevance: 10\n    }, XML_ENTITIES, {\n      className: 'meta',\n      begin: /<\\?xml/,\n      end: /\\?>/,\n      relevance: 10\n    }, {\n      className: 'tag',\n\n      /*\n      The lookahead pattern (?=...) ensures that 'begin' only matches\n      '<style' as a single word, followed by a whitespace or an\n      ending braket. The '$' is needed for the lexeme to be recognized\n      by hljs.subMode() that tests lexemes outside the stream.\n      */\n      begin: /<style(?=\\s|>)/,\n      end: />/,\n      keywords: {\n        name: 'style'\n      },\n      contains: [TAG_INTERNALS],\n      starts: {\n        end: /<\\/style>/,\n        returnEnd: true,\n        subLanguage: ['css', 'xml']\n      }\n    }, {\n      className: 'tag',\n      // See the comment in the <style tag about the lookahead pattern\n      begin: /<script(?=\\s|>)/,\n      end: />/,\n      keywords: {\n        name: 'script'\n      },\n      contains: [TAG_INTERNALS],\n      starts: {\n        end: /<\\/script>/,\n        returnEnd: true,\n        subLanguage: ['javascript', 'handlebars', 'xml']\n      }\n    }, // we need this for now for jSX\n    {\n      className: 'tag',\n      begin: /<>|<\\/>/\n    }, // open tag\n    {\n      className: 'tag',\n      begin: concat(/</, lookahead(concat(TAG_NAME_RE, // <tag/>\n      // <tag>\n      // <tag ...\n      either(/\\/>/, />/, /\\s/)))),\n      end: /\\/?>/,\n      contains: [{\n        className: 'name',\n        begin: TAG_NAME_RE,\n        relevance: 0,\n        starts: TAG_INTERNALS\n      }]\n    }, // close tag\n    {\n      className: 'tag',\n      begin: concat(/<\\//, lookahead(concat(TAG_NAME_RE, />/))),\n      contains: [{\n        className: 'name',\n        begin: TAG_NAME_RE,\n        relevance: 0\n      }, {\n        begin: />/,\n        relevance: 0,\n        endsParent: true\n      }]\n    }]\n  };\n}\n\nmodule.exports = xml;","map":null,"metadata":{},"sourceType":"script"}