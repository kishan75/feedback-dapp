{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.infoToCompilations = exports.collectUserDefinedTypesAndTaggedOutputs = exports.simpleShimSourceMap = exports.getContractNode = exports.shimContracts = exports.shimArtifacts = exports.shimCompilation = exports.shimCompilations = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:compilations:utils\");\n\nconst Ast = __importStar(require(\"../ast\"));\n\nconst Format = __importStar(require(\"../format\"));\n\nconst errors_1 = require(\"../errors\");\n\nfunction shimCompilations(inputCompilations, shimmedCompilationIdPrefix = \"shimmedcompilation\") {\n  return inputCompilations.map((compilation, compilationIndex) => shimCompilation(compilation, \"\".concat(shimmedCompilationIdPrefix, \"Number(\").concat(compilationIndex, \")\")));\n}\n\nexports.shimCompilations = shimCompilations;\n\nfunction shimCompilation(inputCompilation, shimmedCompilationId = \"shimmedcompilation\") {\n  return Object.assign(Object.assign({}, shimContracts(inputCompilation.contracts, {\n    files: inputCompilation.sourceIndexes,\n    sources: inputCompilation.sources,\n    shimmedCompilationId,\n    compiler: inputCompilation.compiler\n  })), {\n    compiler: inputCompilation.compiler\n  });\n}\n\nexports.shimCompilation = shimCompilation;\n/**\n * wrapper around shimContracts that just returns\n * the result in a one-element array (keeping the old name\n * shimArtifacts for compatibility)\n */\n\nfunction shimArtifacts(artifacts, files, shimmedCompilationId = \"shimmedcompilation\") {\n  return [shimContracts(artifacts, {\n    files,\n    shimmedCompilationId\n  })];\n}\n\nexports.shimArtifacts = shimArtifacts;\n/**\n * shims a bunch of contracts (\"artifacts\", though not necessarily)\n * to a compilation.  usually used via one of the above functions.\n * Note: if you pass in options.sources, options.files will be ignored.\n * Note: if you pass in options.sources, sources will not have\n * compiler set unless you also pass in options.compiler; in this case\n * you should set that up separately, as in shimCompilation().\n */\n\nfunction shimContracts(artifacts, options = {}) {\n  const files = options.files,\n        inputSources = options.sources;\n  const shimmedCompilationId = options.shimmedCompilationId || \"shimmedcompilation\";\n  let contracts = [];\n  let sources = [];\n  let unreliableSourceOrder = false;\n\n  for (let artifact of artifacts) {\n    let contractName = artifact.contractName,\n        bytecode = artifact.bytecode,\n        sourceMap = artifact.sourceMap,\n        deployedBytecode = artifact.deployedBytecode,\n        deployedSourceMap = artifact.deployedSourceMap,\n        immutableReferences = artifact.immutableReferences,\n        sourcePath = artifact.sourcePath,\n        source = artifact.source,\n        ast = artifact.ast,\n        abi = artifact.abi,\n        compiler = artifact.compiler,\n        generatedSources = artifact.generatedSources,\n        deployedGeneratedSources = artifact.deployedGeneratedSources;\n\n    if (artifact.contract_name) {\n      //just in case\n      contractName = artifact.contract_name; //dunno what's up w/ the type of contract_name, but it needs coercing\n    }\n\n    debug(\"contractName: %s\", contractName);\n    let contractObject = {\n      contractName,\n      bytecode,\n      sourceMap,\n      deployedBytecode,\n      deployedSourceMap,\n      immutableReferences,\n      abi,\n      generatedSources: normalizeGeneratedSources(generatedSources, compiler),\n      deployedGeneratedSources: normalizeGeneratedSources(deployedGeneratedSources, compiler),\n      compiler\n    };\n    let sourceObject = {\n      sourcePath,\n      source,\n      ast: ast,\n      compiler,\n      language: inferLanguage(ast, compiler, sourcePath)\n    }; //ast needs to be coerced because schema doesn't quite match our types here...\n    //if files or sources was passed, trust that to determine the source index\n\n    if (files || inputSources) {\n      //note: we never set the unreliableSourceOrder flag in this branch;\n      //we just trust files/sources.  If this info is bad, then, uh, too bad.\n      const index = inputSources ? inputSources.findIndex(source => source.sourcePath === sourcePath) : files.indexOf(sourcePath);\n\n      if (!inputSources) {\n        //if inputSources was passed, we'll handle this separately below\n        sourceObject.id = index.toString(); //HACK\n\n        sources[index] = sourceObject;\n      }\n\n      contractObject.primarySourceId = index.toString(); //HACK\n    } else {\n      //if neither was passed, attempt to determine it from the ast\n      let index;\n\n      if (sourceObject.ast) {\n        //note: this works for both Solidity and Vyper\n        index = sourceIndexForAst(sourceObject.ast); //sourceObject.ast for typing reasons\n      } else if (compiler && compiler.name === \"vyper\") {\n        index = 0; //if it's Vyper but there's no AST, we can\n        //assume that it was compiled alone and therefore has index 0\n      } //if that didn't work, try the source map\n\n\n      if (index === undefined && (sourceMap || deployedSourceMap)) {\n        const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n        index = extractPrimarySource(sourceMapString);\n      } //else leave undefined for now\n\n\n      var _getIndexToAddAt = getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder);\n\n      index = _getIndexToAddAt.index;\n      unreliableSourceOrder = _getIndexToAddAt.unreliableSourceOrder;\n\n      if (index !== null) {\n        //if we're in this case, inputSources was not passed\n        sourceObject.id = index.toString(); //HACK\n\n        sources[index] = sourceObject;\n        contractObject.primarySourceId = index.toString();\n      }\n    }\n\n    contracts.push(contractObject);\n  } //now: check for id overlap with internal sources\n  //(don't bother if inputSources or files was passed)\n\n\n  if (!inputSources && !files) {\n    for (let contract of contracts) {\n      const generatedSources = contract.generatedSources,\n            deployedGeneratedSources = contract.deployedGeneratedSources;\n\n      for (let index in generatedSources) {\n        if (index in sources) {\n          unreliableSourceOrder = true;\n        }\n      }\n\n      for (let index in deployedGeneratedSources) {\n        if (index in sources) {\n          unreliableSourceOrder = true;\n        }\n      }\n    }\n  }\n\n  let compiler;\n\n  if (options.compiler) {\n    compiler = options.compiler;\n  } else if (!unreliableSourceOrder && contracts.length > 0) {\n    //if things were actually compiled together, we should just be able\n    //to pick an arbitrary one\n    compiler = contracts[0].compiler;\n  } //if input sources was passed, set up the sources object directly :)\n\n\n  if (inputSources) {\n    sources = inputSources.map(({\n      sourcePath,\n      contents: source,\n      ast,\n      language\n    }, index) => ({\n      sourcePath,\n      source,\n      ast: ast,\n      language,\n      id: index.toString(),\n      compiler //redundant but let's include it\n\n    }));\n  }\n\n  return {\n    id: shimmedCompilationId,\n    unreliableSourceOrder,\n    sources,\n    contracts,\n    compiler\n  };\n}\n\nexports.shimContracts = shimContracts; //note: this works for Vyper too!\n\nfunction sourceIndexForAst(ast) {\n  if (Array.isArray(ast)) {\n    //special handling for old Vyper versions\n    ast = ast[0];\n  }\n\n  if (!ast) {\n    return undefined;\n  }\n\n  return parseInt(ast.src.split(\":\")[2]); //src is given as start:length:file.\n  //we want just the file.\n}\n\nfunction getContractNode(contract, compilation) {\n  const contractName = contract.contractName,\n        sourceMap = contract.sourceMap,\n        deployedSourceMap = contract.deployedSourceMap,\n        primarySourceId = contract.primarySourceId;\n  const unreliableSourceOrder = compilation.unreliableSourceOrder,\n        sources = compilation.sources;\n  let sourcesToCheck; //we will attempt to locate the primary source;\n  //if we can't find it, we'll just check every source in this\n  //compilation.\n\n  if (primarySourceId !== undefined) {\n    sourcesToCheck = [sources.find(source => source && source.id === primarySourceId)];\n  } else if (!unreliableSourceOrder && (deployedSourceMap || sourceMap)) {\n    const sourceMapString = simpleShimSourceMap(deployedSourceMap || sourceMap);\n    let sourceId = extractPrimarySource(sourceMapString);\n    sourcesToCheck = [sources[sourceId]];\n  } else {\n    //WARNING: if we end up in this case, we could get the wrong contract!\n    //(but we shouldn't end up here)\n    sourcesToCheck = sources;\n  }\n\n  return sourcesToCheck.reduce((foundNode, source) => {\n    if (foundNode || !source) {\n      return foundNode;\n    }\n\n    if (!source.ast || source.language !== \"Solidity\") {\n      //ignore non-Solidity ASTs for now, we don't support them yet\n      return undefined;\n    }\n\n    return source.ast.nodes.find(node => node.nodeType === \"ContractDefinition\" && node.name === contractName);\n  }, undefined);\n}\n\nexports.getContractNode = getContractNode;\n/**\n * extract the primary source from a source map\n * (i.e., the source for the first instruction, found\n * between the second and third colons)\n */\n\nfunction extractPrimarySource(sourceMap) {\n  if (!sourceMap) {\n    //HACK?\n    return 0; //in this case (e.g. a Vyper contract with an old-style\n    //source map) we infer that it was compiled by itself\n  }\n\n  return parseInt(sourceMap.match(/^[^:]*:[^:]*:([^:]*):/)[1] || \"0\");\n}\n\nfunction normalizeGeneratedSources(generatedSources, compiler) {\n  if (!generatedSources) {\n    return [];\n  }\n\n  if (!isGeneratedSources(generatedSources)) {\n    return generatedSources; //if already normalizeed, leave alone\n  }\n\n  let sources = []; //output\n\n  for (let source of generatedSources) {\n    sources[source.id] = {\n      id: source.id.toString(),\n      sourcePath: source.name,\n      source: source.contents,\n      //ast needs to be coerced because schema doesn't quite match our types here...\n      ast: source.ast,\n      compiler: compiler,\n      language: source.language\n    };\n  }\n\n  return sources;\n} //HACK\n\n\nfunction isGeneratedSources(sources) {\n  //note: for some reason arr.includes(undefined) returns true on sparse arrays\n  //if sources.length === 0, it's ambiguous; we'll exclude it as not needing normalization\n  return sources.length > 0 && !sources.includes(undefined) && (sources[0].contents !== undefined || sources[0].name !== undefined);\n} //HACK, maybe?\n\n\nfunction inferLanguage(ast, compiler, sourcePath) {\n  if (ast) {\n    if (ast.nodeType === \"SourceUnit\") {\n      return \"Solidity\";\n    } else if (ast.nodeType && ast.nodeType.startsWith(\"Yul\")) {\n      //Every Yul source I've seen has YulBlock as the root, but\n      //I'm not sure that that's *always* the case\n      return \"Yul\";\n    } else if (Array.isArray(ast) || ast.ast_type === \"Module\") {\n      return \"Vyper\";\n    }\n  } else if (compiler) {\n    if (compiler.name === \"vyper\") {\n      return \"Vyper\";\n    } else if (compiler.name === \"solc\") {\n      //assuming sources compiled with solc without sourcePath are Solidity\n      if (sourcePath && sourcePath.endsWith(\".yul\")) {\n        return \"Yul\";\n      } else {\n        return \"Solidity\";\n      }\n    } else {\n      return undefined;\n    }\n  } else {\n    return undefined;\n  }\n}\n\nfunction getIndexToAddAt(sourceObject, index, sources, unreliableSourceOrder) {\n  //first: is this already there? only add it if it's not.\n  //(we determine this by sourcePath if present, and the actual source\n  //contents if not)\n  debug(\"sourcePath: %s\", sourceObject.sourcePath);\n  debug(\"given index: %d\", index);\n  debug(\"sources: %o\", sources.map(source => source.sourcePath));\n\n  if (sources.every(existingSource => existingSource.sourcePath !== sourceObject.sourcePath || !sourceObject.sourcePath && !existingSource.sourcePath && existingSource.source !== sourceObject.source)) {\n    if (unreliableSourceOrder || index === undefined || index in sources) {\n      //if we can't add it at the correct spot, set the\n      //unreliable source order flag\n      debug(\"collision!\");\n      unreliableSourceOrder = true;\n    } //otherwise, just leave things alone\n\n\n    if (unreliableSourceOrder) {\n      //in case of unreliable source order, we'll ignore what indices\n      //things are *supposed* to have and just append things to the end\n      index = sources.length;\n    }\n\n    return {\n      index,\n      unreliableSourceOrder\n    };\n  } else {\n    //return index: null indicates don't add this because it's\n    //already present\n    debug(\"already present, not adding\");\n    return {\n      index: null,\n      unreliableSourceOrder\n    };\n  }\n}\n/**\n * convert Vyper source maps to solidity ones\n * (note we won't bother handling the case where the compressed\n * version doesn't exist; that will have to wait for a later version)\n */\n\n\nfunction simpleShimSourceMap(sourceMap) {\n  if (sourceMap === undefined) {\n    return undefined; //undefined case\n  } else if (typeof sourceMap === \"object\") {\n    return sourceMap.pc_pos_map_compressed; //Vyper object case\n  } else {\n    try {\n      return JSON.parse(sourceMap).pc_pos_map_compressed; //Vyper JSON case\n    } catch (_) {\n      return sourceMap; //Solidity case\n    }\n  }\n}\n\nexports.simpleShimSourceMap = simpleShimSourceMap;\n/**\n * collects user defined types & tagged outputs for a given set of compilations,\n * returning both the definition nodes and (for the types) the type objects\n *\n * \"Tagged outputs\" means user-defined things that are output by a contract\n * (not input to a contract), and which are distinguished by (potentially\n * ambiguous) selectors.  So, events and custom errors are tagged outputs.\n * Function arguments are not tagged outputs (they're not outputs).\n * Return values are not tagged outputs (they don't have a selector).\n * Built-in errors (Error(string) and Panic(uint))... OK I guess those could\n * be considered tagged outputs, but we're only looking at user-defined ones\n * here.\n */\n\nfunction collectUserDefinedTypesAndTaggedOutputs(compilations) {\n  let references = {};\n  let types = {};\n\n  for (const compilation of compilations) {\n    references[compilation.id] = {};\n    types[compilation.id] = {\n      compiler: compilation.compiler,\n      types: {}\n    };\n\n    for (const source of compilation.sources) {\n      if (!source) {\n        continue; //remember, sources could be empty if shimmed!\n      }\n\n      const ast = source.ast,\n            compiler = source.compiler,\n            language = source.language;\n\n      if (language === \"Solidity\" && ast) {\n        //don't check Yul or Vyper sources!\n        for (const node of ast.nodes) {\n          if (node.nodeType === \"StructDefinition\" || node.nodeType === \"EnumDefinition\" || node.nodeType === \"UserDefinedValueTypeDefinition\" || node.nodeType === \"ContractDefinition\") {\n            references[compilation.id][node.id] = node; //we don't have all the references yet, but we actually don't need them :)\n\n            const dataType = Ast.Import.definitionToStoredType(node, compilation.id, compiler, references[compilation.id]);\n            types[compilation.id].types[dataType.id] = dataType;\n          } else if (node.nodeType === \"EventDefinition\" || node.nodeType === \"ErrorDefinition\") {\n            references[compilation.id][node.id] = node;\n          }\n\n          if (node.nodeType === \"ContractDefinition\") {\n            for (const subNode of node.nodes) {\n              if (subNode.nodeType === \"StructDefinition\" || subNode.nodeType === \"EnumDefinition\" || subNode.nodeType === \"UserDefinedValueTypeDefinition\") {\n                references[compilation.id][subNode.id] = subNode; //we don't have all the references yet, but we only need the\n                //reference to the defining contract, which we just added above!\n\n                const dataType = Ast.Import.definitionToStoredType(subNode, compilation.id, compiler, references[compilation.id]);\n                types[compilation.id].types[dataType.id] = dataType;\n              } else if (subNode.nodeType === \"EventDefinition\" || subNode.nodeType === \"ErrorDefinition\") {\n                references[compilation.id][subNode.id] = subNode;\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return {\n    definitions: references,\n    typesByCompilation: types,\n    types: Format.Types.forgetCompilations(types)\n  };\n}\n\nexports.collectUserDefinedTypesAndTaggedOutputs = collectUserDefinedTypesAndTaggedOutputs;\n\nfunction projectInfoIsCodecStyle(info) {\n  return Boolean(info.compilations);\n}\n\nfunction projectInfoIsCommonStyle(info) {\n  return Boolean(info.commonCompilations);\n}\n\nfunction projectInfoIsArtifacts(info) {\n  return Boolean(info.artifacts);\n}\n\nfunction infoToCompilations(projectInfo) {\n  if (!projectInfo) {\n    throw new errors_1.NoProjectInfoError();\n  }\n\n  if (projectInfoIsCodecStyle(projectInfo)) {\n    return projectInfo.compilations;\n  } else if (projectInfoIsCommonStyle(projectInfo)) {\n    return shimCompilations(projectInfo.commonCompilations);\n  } else if (projectInfoIsArtifacts(projectInfo)) {\n    return shimArtifacts(projectInfo.artifacts);\n  }\n}\n\nexports.infoToCompilations = infoToCompilations;","map":null,"metadata":{},"sourceType":"script"}