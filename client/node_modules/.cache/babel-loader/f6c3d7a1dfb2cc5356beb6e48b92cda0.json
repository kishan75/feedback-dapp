{"ast":null,"code":"import { Stream } from '../../stream/Stream.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\nimport { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { getDepthContextFor } from './helpers/DepthContext.js';\nexport class FrequencyArbitrary extends NextArbitrary {\n  constructor(warbs, constraints, context) {\n    super();\n    this.warbs = warbs;\n    this.constraints = constraints;\n    this.context = context;\n    let currentWeight = 0;\n    this.cumulatedWeights = [];\n\n    for (let idx = 0; idx !== warbs.length; ++idx) {\n      currentWeight += warbs[idx].weight;\n      this.cumulatedWeights.push(currentWeight);\n    }\n\n    this.totalWeight = currentWeight;\n  }\n\n  static fromOld(warbs, constraints, label) {\n    return convertFromNext(FrequencyArbitrary.from(warbs.map(w => Object.assign(Object.assign({}, w), {\n      arbitrary: convertToNext(w.arbitrary)\n    })), constraints, label));\n  }\n\n  static from(warbs, constraints, label) {\n    if (warbs.length === 0) {\n      throw new Error(\"\".concat(label, \" expects at least one weighted arbitrary\"));\n    }\n\n    let totalWeight = 0;\n\n    for (let idx = 0; idx !== warbs.length; ++idx) {\n      const currentArbitrary = warbs[idx].arbitrary;\n\n      if (currentArbitrary === undefined) {\n        throw new Error(\"\".concat(label, \" expects arbitraries to be specified\"));\n      }\n\n      const currentWeight = warbs[idx].weight;\n      totalWeight += currentWeight;\n\n      if (!Number.isInteger(currentWeight)) {\n        throw new Error(\"\".concat(label, \" expects weights to be integer values\"));\n      }\n\n      if (currentWeight < 0) {\n        throw new Error(\"\".concat(label, \" expects weights to be superior or equal to 0\"));\n      }\n    }\n\n    if (totalWeight <= 0) {\n      throw new Error(\"\".concat(label, \" expects the sum of weights to be strictly superior to 0\"));\n    }\n\n    return new FrequencyArbitrary(warbs, constraints, getDepthContextFor(constraints.depthIdentifier));\n  }\n\n  generate(mrng, biasFactor) {\n    if (this.mustGenerateFirst()) {\n      return this.safeGenerateForIndex(mrng, 0, biasFactor);\n    }\n\n    const selected = mrng.nextInt(this.computeNegDepthBenefit(), this.totalWeight - 1);\n\n    for (let idx = 0; idx !== this.cumulatedWeights.length; ++idx) {\n      if (selected < this.cumulatedWeights[idx]) {\n        return this.safeGenerateForIndex(mrng, idx, biasFactor);\n      }\n    }\n\n    throw new Error(\"Unable to generate from fc.frequency\");\n  }\n\n  canShrinkWithoutContext(value) {\n    return this.canShrinkWithoutContextIndex(value) !== -1;\n  }\n\n  shrink(value, context) {\n    if (context !== undefined) {\n      const safeContext = context;\n      const selectedIndex = safeContext.selectedIndex;\n      const originalBias = safeContext.originalBias;\n      const originalArbitrary = this.warbs[selectedIndex].arbitrary;\n      const originalShrinks = originalArbitrary.shrink(value, safeContext.originalContext).map(v => this.mapIntoNextValue(selectedIndex, v, null, originalBias));\n\n      if (safeContext.clonedMrngForFallbackFirst !== null) {\n        if (safeContext.cachedGeneratedForFirst === undefined) {\n          safeContext.cachedGeneratedForFirst = this.safeGenerateForIndex(safeContext.clonedMrngForFallbackFirst, 0, originalBias);\n        }\n\n        const valueFromFirst = safeContext.cachedGeneratedForFirst;\n        return Stream.of(valueFromFirst).join(originalShrinks);\n      }\n\n      return originalShrinks;\n    }\n\n    const potentialSelectedIndex = this.canShrinkWithoutContextIndex(value);\n\n    if (potentialSelectedIndex === -1) {\n      return Stream.nil();\n    }\n\n    return this.defaultShrinkForFirst(potentialSelectedIndex).join(this.warbs[potentialSelectedIndex].arbitrary.shrink(value, undefined).map(v => this.mapIntoNextValue(potentialSelectedIndex, v, null, undefined)));\n  }\n\n  defaultShrinkForFirst(selectedIndex) {\n    ++this.context.depth;\n\n    try {\n      if (!this.mustFallbackToFirstInShrink(selectedIndex) || this.warbs[0].fallbackValue === undefined) {\n        return Stream.nil();\n      }\n    } finally {\n      --this.context.depth;\n    }\n\n    const rawShrinkValue = new NextValue(this.warbs[0].fallbackValue.default, undefined);\n    return Stream.of(this.mapIntoNextValue(0, rawShrinkValue, null, undefined));\n  }\n\n  canShrinkWithoutContextIndex(value) {\n    if (this.mustGenerateFirst()) {\n      return this.warbs[0].arbitrary.canShrinkWithoutContext(value) ? 0 : -1;\n    }\n\n    try {\n      ++this.context.depth;\n\n      for (let idx = 0; idx !== this.warbs.length; ++idx) {\n        const warb = this.warbs[idx];\n\n        if (warb.weight !== 0 && warb.arbitrary.canShrinkWithoutContext(value)) {\n          return idx;\n        }\n      }\n\n      return -1;\n    } finally {\n      --this.context.depth;\n    }\n  }\n\n  mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor) {\n    const context = {\n      selectedIndex: idx,\n      originalBias: biasFactor,\n      originalContext: value.context,\n      clonedMrngForFallbackFirst\n    };\n    return new NextValue(value.value, context);\n  }\n\n  safeGenerateForIndex(mrng, idx, biasFactor) {\n    ++this.context.depth;\n\n    try {\n      const value = this.warbs[idx].arbitrary.generate(mrng, biasFactor);\n      const clonedMrngForFallbackFirst = this.mustFallbackToFirstInShrink(idx) ? mrng.clone() : null;\n      return this.mapIntoNextValue(idx, value, clonedMrngForFallbackFirst, biasFactor);\n    } finally {\n      --this.context.depth;\n    }\n  }\n\n  mustGenerateFirst() {\n    return this.constraints.maxDepth !== undefined && this.constraints.maxDepth <= this.context.depth;\n  }\n\n  mustFallbackToFirstInShrink(idx) {\n    return idx !== 0 && !!this.constraints.withCrossShrink && this.warbs[0].weight !== 0;\n  }\n\n  computeNegDepthBenefit() {\n    const depthFactor = this.constraints.depthFactor;\n\n    if (depthFactor === undefined || depthFactor <= 0) {\n      return 0;\n    }\n\n    const depthBenefit = Math.floor(Math.pow(1 + depthFactor, this.context.depth)) - 1;\n    return -Math.min(this.warbs[0].weight * depthBenefit, Number.MAX_SAFE_INTEGER) || 0;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}