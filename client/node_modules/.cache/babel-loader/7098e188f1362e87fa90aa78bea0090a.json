{"ast":null,"code":"const hljs = require('highlight.js');\n\nconst cheerio = require('cheerio');\n\nconst camelCase = require('camelcase');\n\nconst chalk = require('chalk');\n\nconst stripAnsi = require('strip-ansi');\n\nconst merge = require('lodash.merge');\n\nconst stripIndent = require('strip-indent');\n\nconst detectIndent = require('detect-indent');\n\nconst darkPalette = {\n  addition: chalk.green,\n  attr: chalk.yellow,\n  attribute: chalk.blue,\n  attrString: chalk.cyan,\n  base: chalk.white,\n  builtIn: chalk.blue,\n  builtInName: chalk.blue,\n  bullet: chalk.magenta,\n  class: chalk.green,\n  code: chalk.yellow,\n  comment: chalk.white.dim,\n  deletion: chalk.red,\n  doctag: chalk.blue,\n  emphasis: chalk.magenta,\n  function: chalk.white,\n  formula: chalk.green,\n  keyword: chalk.red,\n  lineNumbers: chalk.grey,\n  literal: chalk.magenta,\n  link: chalk.blue.underline,\n  meta: chalk.cyan,\n  name: chalk.cyan,\n  number: chalk.green,\n  params: chalk.blue,\n  quote: chalk.gray,\n  regexp: chalk.magenta,\n  selectorAttr: chalk.green,\n  selectorClass: chalk.yellow,\n  selectorId: chalk.blue,\n  selectorPseudo: chalk.cyan,\n  selectorTag: chalk.magenta,\n  string: chalk.yellow,\n  strong: chalk.red,\n  subst: chalk.cyan,\n  symbol: chalk.cyan,\n  tag: chalk.blue,\n  templateTag: chalk.magenta,\n  templateVariable: chalk.green,\n  title: chalk.green,\n  trailingSpace: chalk,\n  type: chalk.magenta,\n  variable: chalk.red\n};\n\nconst filter = (node, opts) => {\n  let color;\n  let text;\n  let childText;\n\n  if (node.type === 'text') {\n    text = node.data;\n    return text;\n  }\n\n  if (node.name === 'span' && node.type === 'tag') {\n    color = camelCase(node.attribs.class.split('-')[1]);\n  }\n\n  if (node.childNodes && node.childNodes.length > 0) {\n    childText = node.childNodes.map(childNode => filter(childNode, opts)).join('');\n\n    if (typeof color === 'string') {\n      return opts.colors[color](childText);\n    }\n\n    return childText;\n  }\n\n  return '';\n};\n\nconst findLongestLine = (text, opts) => {\n  let tabPad = '';\n\n  if (opts.$indent.tabs) {\n    tabPad = String().padEnd(opts.consoleTabWidth, ' ');\n  }\n\n  const lines = stripAnsi(text).replace(/\\t/g, tabPad).split('\\n');\n  let max = 0;\n  lines.forEach(line => {\n    if (line.length > max) {\n      max = line.length;\n    }\n  });\n  return max;\n};\n\nconst padLine = (line, padding) => {\n  const padStr = String().padStart(padding, ' ');\n  return padStr + line + padStr;\n};\n\nconst getIndentStr = opts => {\n  if (opts.$indent.tabs) {\n    return String().padStart(1, '\\t');\n  } // Opts.$indent.spaces === true\n\n\n  if (opts.tabsToSpaces === 0) {\n    return '\\u0000';\n  }\n\n  return String().padEnd(opts.tabsToSpaces, ' ');\n};\n\nconst syntaxHlStr = (lang, script, opts, indentStart) => {\n  const indentStr = getIndentStr(opts);\n\n  if (opts.$indent.tabs) {\n    script = script.replace(/\\t/g, indentStr);\n  }\n\n  if (opts.$indent.spaces) {\n    script = script.replace(/\\t/g, indentStr);\n  }\n\n  if (indentStart) {\n    script = indentStr + script;\n  }\n\n  const code = hljs.highlight(lang, script).value;\n  const html = \"<code>\".concat(code, \"</code>\");\n  const $body = cheerio.load(html).root().find('code')[0];\n  const output = filter($body, opts);\n  return output;\n};\n\nconst syntaxHlJson = (json, opts) => {\n  const indentStr = getIndentStr(opts);\n\n  try {\n    json = JSON.stringify(json, (key, val) => {\n      if (val instanceof Function) {\n        return \"[FUNCTION]\".concat(String(val), \"[FUNCTION]\");\n      }\n\n      return val;\n    }, indentStr);\n  } catch (err) {\n    err.message = 'ðŸ¦…  Chromafi: ' + err.message;\n    throw new Error(err);\n  }\n\n  const highlighted = json.replace(/(\"(\\\\u[a-zA-Z0-9]{4}|\\\\[^u]|[^\\\\\"])*\"(\\s*:)?|\\b(true|false|null)\\b|-?\\d+(?:\\.\\d*)?(?:[eE][+-]?\\d+)?)/g, match => {\n    let colorClass = 'number'; // eslint-disable-next-line unicorn/prefer-starts-ends-with\n\n    if (/^\"/.test(match)) {\n      // eslint-disable-next-line unicorn/prefer-starts-ends-with\n      if (/:$/.test(match)) {\n        if (match.includes('-')) {\n          colorClass = 'attrString';\n          match = match.replace(/\"/g, '\\'');\n        } else {\n          colorClass = 'attr';\n          match = match.replace(/\"/g, '');\n        }\n      } else {\n        colorClass = 'string';\n\n        if (match.substr(1, 10) === '[FUNCTION]' && match.substr(match.length - 11, 10) === '[FUNCTION]') {\n          colorClass = 'function';\n        } else {\n          match = match.replace(/\"/g, '\\'');\n          match = match.replace(/\\\\n/g, '\\n');\n          match = match.replace(/\\\\t/g, indentStr);\n        }\n      }\n    } else if (/true|false/.test(match)) {\n      colorClass = 'literal';\n    } else if (/null/.test(match)) {\n      colorClass = 'literal';\n    }\n\n    return opts.colors[colorClass](match);\n  });\n\n  const getFnStrIndent = (fnStr, opts) => {\n    fnStr = fnStr.replace(/\\t/g, indentStr);\n    const indent = detectIndent(fnStr);\n\n    if (opts.$indent.spaces) {\n      const indentLevel = indent.amount / opts.tabsToSpaces;\n      return indentLevel;\n    }\n\n    if (opts.$indent.tabs) {\n      const indentLevel = indent.amount;\n      return indentLevel;\n    }\n  };\n\n  const lines = highlighted.split('\\n').map(line => {\n    const fnParts = line.split('[FUNCTION]');\n\n    if (fnParts.length === 3) {\n      const plain = stripAnsi(line);\n      let outerIndent;\n\n      if (opts.$indent.spaces) {\n        outerIndent = plain.match(/^[ \\\\t]*/)[0].length / opts.tabsToSpaces;\n      }\n\n      if (opts.$indent.tabs) {\n        outerIndent = plain.match(/^\\t*/)[0].length;\n      }\n\n      const fnStr = fnParts[1].replace(/\"/g, '\\'').replace(/\\\\n/g, '\\n').replace(/\\\\t/g, '\\t');\n      const innerIndent = getFnStrIndent(fnStr, opts);\n      const indentOffset = Math.abs(outerIndent - (innerIndent - 1));\n      const re = new RegExp(\"\\n(\\t){\".concat(indentOffset, \"}\"), 'g');\n      const reTabbed = fnStr.replace(re, '\\n').replace(/\\\\t/g, indentStr);\n      const preFn = fnParts[0].substr(0, fnParts[0].length - 1);\n      const postFn = fnParts[2].substr(1);\n      const jsHighlighted = syntaxHlStr('javascript', reTabbed, opts);\n      return preFn + jsHighlighted + postFn;\n    }\n\n    return line;\n  }).join('\\n');\n  return lines;\n};\n\nconst lineNumberPad = (number, opts) => {\n  if (!opts.lineNumbers) {\n    return '';\n  }\n\n  let output = '';\n  const offsetLineN = number + (opts.lineNumberStart - 1);\n\n  if (opts.$indent.spaces) {\n    const padStr = String().padStart(opts.lineNumberPad, ' ');\n    const prePad = opts.lineNumberPad + opts.$maxDigitWidth;\n    output = String(offsetLineN).padStart(prePad) + padStr;\n  } // Indent using spaces - up to the tabwidth required to contain number str\n\n\n  if (opts.$indent.tabs) {\n    output = String(offsetLineN).padStart(opts.$maxTabSpace, ' ');\n  }\n\n  return opts.colors.lineNumbers(output);\n};\n\nconst cropPadAndNumber = (text, opts) => {\n  let output = '';\n  const lines = text.split('\\n');\n  const maxDigitWidth = String(lines.length + (opts.lineNumberStart - 1)).length; // Tabs needed to contain digits (so we dont break code tab indentation)\n\n  const tabsNeeded = Math.ceil(maxDigitWidth / opts.consoleTabWidth);\n  const maxTabSpace = tabsNeeded * opts.consoleTabWidth;\n  const longestLineLen = findLongestLine(text, opts);\n  opts.$maxTabSpace = maxTabSpace;\n  opts.$maxDigitWidth = maxDigitWidth;\n  lines.forEach((line, i) => {\n    const lineNumber = i + 1;\n\n    if (lineNumber < opts.firstLine || lineNumber > opts.lastLine) {\n      return;\n    }\n\n    const lineNo = lineNumberPad(lineNumber, opts);\n    const tabCount = (line.match(/\\t/g) || []).length;\n    const tabAdjust = tabCount * opts.consoleTabWidth;\n    const plain = stripAnsi(line).replace(/\\t/g, '');\n    let runLengthLine;\n\n    if (opts.lineEndPad === true) {\n      const linePad = String().padEnd(longestLineLen - plain.length - tabAdjust, ' ');\n      runLengthLine = line + opts.colors.trailingSpace(linePad);\n    } else {\n      runLengthLine = line;\n    }\n\n    let lineOutput;\n\n    if (opts.tabsToSpaces === false) {\n      lineOutput = lineNo + runLengthLine;\n    }\n\n    if (typeof opts.tabsToSpaces === 'number') {\n      lineOutput = lineNo + padLine(runLengthLine, opts.codePad);\n    }\n\n    output += lineOutput + '\\n';\n  });\n  return opts.colors.base(output);\n};\n\nconst decorate = (ansiStr, opts) => {\n  // AnsiMark has been removed for causing problems.\n  ansiStr = cropPadAndNumber(ansiStr, opts);\n  return ansiStr;\n};\n\nconst nameifyArrowFn = (fn, opts) => {\n  if (Reflect.has(fn, 'prototype') && Reflect.has(fn.prototype, 'constructor')) {\n    return '';\n  }\n\n  return \"\".concat(opts.arrowKeyword, \" \").concat(fn.name, \" = \");\n};\n\nconst procOpts = (opts = {}) => {\n  let options = {\n    lineNumbers: true,\n    lang: 'javascript',\n    lineNumberPad: 0,\n    lineNumberStart: 1,\n    start: 1,\n    end: Infinity,\n    stripIndent: true,\n    codePad: 1,\n    colors: darkPalette,\n    tabsToSpaces: 4,\n    consoleTabWidth: 8,\n    arrowKeyword: 'const',\n    lineEndPad: true\n  };\n  options = merge(options, opts);\n  options.$indent = {\n    spaces: typeof options.tabsToSpaces === 'number',\n    tabs: typeof options.tabsToSpaces === 'boolean' && options.tabsToSpaces === false,\n    size: typeof options.tabsToSpaces === 'number' ? options.tabsToSpaces : 1\n  };\n  return options;\n};\n\nconst chromafi = (value, opts) => {\n  opts = procOpts(opts);\n\n  if (typeof value === 'function') {\n    value = nameifyArrowFn(value, opts) + String(value);\n    const indentStart = true;\n    value = syntaxHlStr('javascript', value, opts, indentStart);\n    value = stripIndent(value);\n    value = decorate(value, opts);\n    return value;\n  }\n\n  if (typeof value === 'string') {\n    value = syntaxHlStr(opts.lang, value, opts);\n    value = decorate(value, opts);\n    return value;\n  }\n\n  if (typeof value === 'object') {\n    value = syntaxHlJson(value, opts);\n    value = decorate(value, opts);\n    return value;\n  }\n\n  throw new Error('ðŸ¦…  Chromafi: You must pass a function, string or object.');\n};\n\nchromafi.hljs = hljs; // Expose hljs for modification\n\nmodule.exports = chromafi;","map":null,"metadata":{},"sourceType":"script"}