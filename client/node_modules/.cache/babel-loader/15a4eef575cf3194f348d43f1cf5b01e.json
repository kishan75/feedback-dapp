{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeBasic = void 0;\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Evm = __importStar(require(\"../../evm\")); //UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n\n/**\n * Handles encoding of basic types; yes the input type is broader than\n * it should be but it's hard to fix this without causing other problems,\n * sorry!\n * @Category Encoding (low-level)\n */\n\n\nfunction encodeBasic(input) {\n  let bytes;\n\n  switch (input.type.typeClass) {\n    case \"userDefinedValueType\":\n      return encodeBasic(input.value);\n\n    case \"uint\":\n    case \"int\":\n      return Conversion.toBytes(input.value.asBN, Evm.Utils.WORD_SIZE);\n\n    case \"enum\":\n      return Conversion.toBytes(input.value.numericAsBN, Evm.Utils.WORD_SIZE);\n\n    case \"bool\":\n      {\n        bytes = new Uint8Array(Evm.Utils.WORD_SIZE); //is initialized to zeroes\n\n        if (input.value.asBoolean) {\n          bytes[Evm.Utils.WORD_SIZE - 1] = 1;\n        }\n\n        return bytes;\n      }\n\n    case \"bytes\":\n      switch (input.type.kind) {\n        //deliberately not handling dynamic case!\n        case \"static\":\n          bytes = Conversion.toBytes(input.value.asHex);\n          let padded = new Uint8Array(Evm.Utils.WORD_SIZE); //initialized to zeroes\n\n          padded.set(bytes);\n          return padded;\n      }\n\n    case \"address\":\n      return Conversion.toBytes(input.value.asAddress, Evm.Utils.WORD_SIZE);\n\n    case \"contract\":\n      return Conversion.toBytes(input.value.address, Evm.Utils.WORD_SIZE);\n\n    case \"function\":\n      {\n        switch (input.type.visibility) {\n          //for our purposes here, we will NOT count internal functions as a\n          //basic type!  so no handling of internal case\n          case \"external\":\n            let coercedInput = input;\n            let encoded = new Uint8Array(Evm.Utils.WORD_SIZE); //starts filled w/0s\n\n            let addressBytes = Conversion.toBytes(coercedInput.value.contract.address); //should already be correct length\n\n            let selectorBytes = Conversion.toBytes(coercedInput.value.selector); //should already be correct length\n\n            encoded.set(addressBytes);\n            encoded.set(selectorBytes, Evm.Utils.ADDRESS_SIZE); //set it after the address\n\n            return encoded;\n        }\n\n        break; //to satisfy TS\n      }\n\n    case \"fixed\":\n    case \"ufixed\":\n      let bigValue = input.value.asBig;\n      let shiftedValue = Conversion.shiftBigUp(bigValue, input.type.places);\n      return Conversion.toBytes(shiftedValue, Evm.Utils.WORD_SIZE);\n  }\n}\n\nexports.encodeBasic = encodeBasic;","map":null,"metadata":{},"sourceType":"script"}