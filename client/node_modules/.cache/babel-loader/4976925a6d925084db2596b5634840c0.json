{"ast":null,"code":"import _slicedToArray from \"F:\\\\BlockChain\\\\Projects\\\\feedback-dapp\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nexport class ReplayPath {\n  static parse(replayPathStr) {\n    const _replayPathStr$split = replayPathStr.split(':'),\n          _replayPathStr$split2 = _slicedToArray(_replayPathStr$split, 2),\n          serializedCount = _replayPathStr$split2[0],\n          serializedChanges = _replayPathStr$split2[1];\n\n    const counts = this.parseCounts(serializedCount);\n    const changes = this.parseChanges(serializedChanges);\n    return this.parseOccurences(counts, changes);\n  }\n\n  static stringify(replayPath) {\n    const occurences = this.countOccurences(replayPath);\n    const serializedCount = this.stringifyCounts(occurences);\n    const serializedChanges = this.stringifyChanges(occurences);\n    return \"\".concat(serializedCount, \":\").concat(serializedChanges);\n  }\n\n  static intToB64(n) {\n    if (n < 26) return String.fromCharCode(n + 65);\n    if (n < 52) return String.fromCharCode(n + 97 - 26);\n    if (n < 62) return String.fromCharCode(n + 48 - 52);\n    return String.fromCharCode(n === 62 ? 43 : 47);\n  }\n\n  static b64ToInt(c) {\n    if (c >= 'a') return c.charCodeAt(0) - 97 + 26;\n    if (c >= 'A') return c.charCodeAt(0) - 65;\n    if (c >= '0') return c.charCodeAt(0) - 48 + 52;\n    return c === '+' ? 62 : 63;\n  }\n\n  static countOccurences(replayPath) {\n    return replayPath.reduce((counts, cur) => {\n      if (counts.length === 0 || counts[counts.length - 1].count === 64 || counts[counts.length - 1].value !== cur) counts.push({\n        value: cur,\n        count: 1\n      });else counts[counts.length - 1].count += 1;\n      return counts;\n    }, []);\n  }\n\n  static parseOccurences(counts, changes) {\n    const replayPath = [];\n\n    for (let idx = 0; idx !== counts.length; ++idx) {\n      const count = counts[idx];\n      const value = changes[idx];\n\n      for (let num = 0; num !== count; ++num) replayPath.push(value);\n    }\n\n    return replayPath;\n  }\n\n  static stringifyChanges(occurences) {\n    let serializedChanges = '';\n\n    for (let idx = 0; idx < occurences.length; idx += 6) {\n      const changesInt = occurences.slice(idx, idx + 6).reduceRight((prev, cur) => prev * 2 + (cur.value ? 1 : 0), 0);\n      serializedChanges += this.intToB64(changesInt);\n    }\n\n    return serializedChanges;\n  }\n\n  static parseChanges(serializedChanges) {\n    const changesInt = serializedChanges.split('').map(c => this.b64ToInt(c));\n    const changes = [];\n\n    for (let idx = 0; idx !== changesInt.length; ++idx) {\n      let current = changesInt[idx];\n\n      for (let n = 0; n !== 6; ++n, current >>= 1) {\n        changes.push(current % 2 === 1);\n      }\n    }\n\n    return changes;\n  }\n\n  static stringifyCounts(occurences) {\n    return occurences.map(({\n      count\n    }) => this.intToB64(count - 1)).join('');\n  }\n\n  static parseCounts(serializedCount) {\n    return serializedCount.split('').map(c => this.b64ToInt(c) + 1);\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}