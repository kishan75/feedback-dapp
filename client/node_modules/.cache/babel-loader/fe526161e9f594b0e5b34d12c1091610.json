{"ast":null,"code":"import { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';\nimport { NextValue } from '../../check/arbitrary/definition/NextValue.js';\nimport { cloneMethod } from '../../check/symbols.js';\nimport { Stream } from '../../stream/Stream.js';\nimport { asyncStringify, asyncToStringMethod, stringify, toStringMethod } from '../../utils/stringify.js';\n\nfunction prettyPrint(seenValuesStrings) {\n  return \"Stream(\".concat(seenValuesStrings.join(','), \"\\u2026)\");\n}\n\nexport class StreamArbitrary extends NextArbitrary {\n  constructor(arb) {\n    super();\n    this.arb = arb;\n  }\n\n  generate(mrng, biasFactor) {\n    const appliedBiasFactor = biasFactor !== undefined && mrng.nextInt(1, biasFactor) === 1 ? biasFactor : undefined;\n\n    const enrichedProducer = () => {\n      const seenValues = [];\n\n      const g = function* (arb, clonedMrng) {\n        while (true) {\n          const value = arb.generate(clonedMrng, appliedBiasFactor).value;\n          seenValues.push(value);\n          yield value;\n        }\n      };\n\n      const s = new Stream(g(this.arb, mrng.clone()));\n      return Object.defineProperties(s, {\n        toString: {\n          value: () => prettyPrint(seenValues.map(stringify))\n        },\n        [toStringMethod]: {\n          value: () => prettyPrint(seenValues.map(stringify))\n        },\n        [asyncToStringMethod]: {\n          value: async () => prettyPrint((await Promise.all(seenValues.map(asyncStringify))))\n        },\n        [cloneMethod]: {\n          value: enrichedProducer,\n          enumerable: true\n        }\n      });\n    };\n\n    return new NextValue(enrichedProducer(), undefined);\n  }\n\n  canShrinkWithoutContext(value) {\n    return false;\n  }\n\n  shrink(_value, _context) {\n    return Stream.nil();\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}