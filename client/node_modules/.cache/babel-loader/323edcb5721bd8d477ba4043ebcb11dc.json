{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.decodeRevert = exports.decodeReturndata = exports.decodeEvent = exports.decodeCalldata = exports.decodeVariable = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:core\");\n\nconst Ast = __importStar(require(\"./ast\"));\n\nconst AbiData = __importStar(require(\"./abi-data\"));\n\nconst Topic = __importStar(require(\"./topic\"));\n\nconst Evm = __importStar(require(\"./evm\"));\n\nconst Contexts = __importStar(require(\"./contexts\"));\n\nconst abify_1 = require(\"./abify\");\n\nconst Conversion = __importStar(require(\"./conversion\"));\n\nconst errors_1 = require(\"./errors\");\n\nconst read_1 = __importDefault(require(\"./read\"));\n\nconst decode_1 = __importDefault(require(\"./decode\")); // untyped import since no @types/web3-utils exists\n\n\nconst Web3Utils = require(\"web3-utils\");\n/**\n * @Category Decoding\n */\n\n\nfunction* decodeVariable(definition, pointer, info, compilationId) {\n  let compiler = info.currentContext.compiler;\n  let dataType = Ast.Import.definitionToType(definition, compilationId, compiler);\n  return yield* decode_1.default(dataType, pointer, info); //no need to pass an offset\n}\n\nexports.decodeVariable = decodeVariable;\n/**\n * @Category Decoding\n */\n\nfunction* decodeCalldata(info, isConstructor //ignored if context! trust context instead if have\n) {\n  const context = info.currentContext;\n\n  if (context === null) {\n    //if we don't know the contract ID, we can't decode\n    if (isConstructor) {\n      return {\n        kind: \"create\",\n        decodingMode: \"full\",\n        bytecode: Conversion.toHexString(info.state.calldata)\n      };\n    } else {\n      return {\n        kind: \"unknown\",\n        decodingMode: \"full\",\n        data: Conversion.toHexString(info.state.calldata)\n      };\n    }\n  }\n\n  const contextHash = context.context;\n  const contractType = Contexts.Import.contextToType(context);\n  isConstructor = context.isConstructor;\n  const allocations = info.allocations.calldata;\n  let allocation;\n  let selector; //first: is this a creation call?\n\n  if (isConstructor) {\n    allocation = (allocations.constructorAllocations[contextHash] || {\n      input: undefined\n    }).input;\n  } else {\n    //skipping any error-handling on this read, as a calldata read can't throw anyway\n    let rawSelector = yield* read_1.default({\n      location: \"calldata\",\n      start: 0,\n      length: Evm.Utils.SELECTOR_SIZE\n    }, info.state);\n    selector = Conversion.toHexString(rawSelector);\n    allocation = ((allocations.functionAllocations[contextHash] || {})[selector] || {\n      input: undefined\n    }).input;\n  }\n\n  if (allocation === undefined) {\n    let abiEntry = null;\n\n    if (info.state.calldata.length === 0) {\n      //to hell with reads, let's just be direct\n      abiEntry = context.fallbackAbi.receive || context.fallbackAbi.fallback;\n    } else {\n      abiEntry = context.fallbackAbi.fallback;\n    }\n\n    return {\n      kind: \"message\",\n      class: contractType,\n      abi: abiEntry,\n      data: Conversion.toHexString(info.state.calldata),\n      decodingMode: \"full\"\n    };\n  }\n\n  let decodingMode = allocation.allocationMode; //starts out this way, degrades to ABI if necessary\n\n  debug(\"calldata decoding mode: %s\", decodingMode); //you can't map with a generator, so we have to do this map manually\n\n  let decodedArguments = [];\n\n  for (const argumentAllocation of allocation.arguments) {\n    let value;\n    let dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n\n    try {\n      value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n        abiPointerBase: allocation.offset,\n        allowRetry: decodingMode === \"full\"\n      });\n    } catch (error) {\n      if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n        debug(\"problem! retrying as ABI\");\n        debug(\"error: %O\", error); //if a retry happens, we've got to do several things in order to switch to ABI mode:\n        //1. mark that we're switching to ABI mode;\n\n        decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n        decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n          value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n        })); //3. retry this particular decode in ABI mode.\n        //(no try/catch on this one because we can't actually handle errors here!\n        //not that they should be occurring)\n\n        value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n        argumentAllocation.pointer, info, {\n          abiPointerBase: allocation.offset\n        }); //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n        //so we don't need to do anything special there.\n      } else {\n        //we shouldn't be getting other exceptions, but if we do, we don't know\n        //how to handle them, so uhhhh just rethrow I guess??\n        throw error;\n      }\n    }\n\n    const name = argumentAllocation.name;\n    decodedArguments.push(name //deliberate general falsiness test\n    ? {\n      name,\n      value\n    } : {\n      value\n    });\n  }\n\n  if (isConstructor) {\n    return {\n      kind: \"constructor\",\n      class: contractType,\n      arguments: decodedArguments,\n      abi: allocation.abi,\n      bytecode: Conversion.toHexString(info.state.calldata.slice(0, allocation.offset)),\n      decodingMode\n    };\n  } else {\n    return {\n      kind: \"function\",\n      class: contractType,\n      abi: allocation.abi,\n      arguments: decodedArguments,\n      selector,\n      decodingMode\n    };\n  }\n}\n\nexports.decodeCalldata = decodeCalldata;\n/**\n * @Category Decoding\n */\n\nfunction* decodeEvent(info, address, options = {}) {\n  const allocations = info.allocations.event;\n  const extras = options.extras || \"off\";\n  let rawSelector;\n  let selector;\n  let contractAllocations; //for non-anonymous events\n\n  let libraryAllocations; //similar\n\n  let contractAnonymousAllocations;\n  let libraryAnonymousAllocations;\n  const topicsCount = info.state.eventtopics.length; //yeah, it's not great to read directly from the state like this (bypassing read), but what are you gonna do?\n\n  if (allocations[topicsCount]) {\n    if (topicsCount > 0) {\n      rawSelector = yield* read_1.default({\n        location: \"eventtopic\",\n        topic: 0\n      }, info.state);\n      selector = Conversion.toHexString(rawSelector);\n\n      if (allocations[topicsCount].bySelector[selector]) {\n        var _allocations$topicsCo = allocations[topicsCount].bySelector[selector];\n        contractAllocations = _allocations$topicsCo.contract;\n        libraryAllocations = _allocations$topicsCo.library;\n      } else {\n        debug(\"no allocations for that selector!\");\n        contractAllocations = {};\n        libraryAllocations = {};\n      }\n    } else {\n      //if we don't have a selector, it means we don't have any non-anonymous events\n      contractAllocations = {};\n      libraryAllocations = {};\n    } //now: let's get our allocations for anonymous events\n\n\n    var _allocations$topicsCo2 = allocations[topicsCount].anonymous;\n    contractAnonymousAllocations = _allocations$topicsCo2.contract;\n    libraryAnonymousAllocations = _allocations$topicsCo2.library;\n  } else {\n    //if there's not even an allocation for the topics count, we can't\n    //decode; we could do this the honest way of setting all four allocation\n    //objects to {}, but let's just short circuit\n    debug(\"no allocations for that topic count!\");\n    return [];\n  } //now: what contract are we (probably) dealing with? let's get its code to find out\n\n\n  const codeBytes = yield {\n    type: \"code\",\n    address\n  };\n  const codeAsHex = Conversion.toHexString(codeBytes);\n  const contractContext = Contexts.Utils.findContext(info.contexts, codeAsHex);\n  let possibleContractAllocations; //excludes anonymous events\n\n  let possibleContractAnonymousAllocations;\n  let possibleExtraAllocations; //excludes anonymous events\n\n  let possibleExtraAnonymousAllocations;\n  const emittingContextHash = (contractContext || {\n    context: undefined\n  }).context;\n\n  if (emittingContextHash) {\n    //if we found the contract, maybe it's from that contract\n    const contractAllocation = contractAllocations[emittingContextHash];\n    const contractAnonymousAllocation = contractAnonymousAllocations[emittingContextHash];\n    possibleContractAllocations = contractAllocation || [];\n    possibleContractAnonymousAllocations = contractAnonymousAllocation || []; //also, we need to set up the extras (everything that's from a\n    //non-library contract but *not* this one)\n\n    possibleExtraAllocations = [].concat(...Object.entries(contractAllocations).filter(([key, _]) => key !== emittingContextHash).map(([_, value]) => value));\n    possibleExtraAnonymousAllocations = [].concat(...Object.entries(contractAnonymousAllocations).filter(([key, _]) => key !== emittingContextHash).map(([_, value]) => value));\n  } else {\n    //if we couldn't determine the contract, well, we have to assume it's from a library\n    debug(\"couldn't find context\");\n    possibleContractAllocations = [];\n    possibleContractAnonymousAllocations = []; //or it's an extra, which could be any of the contracts\n\n    possibleExtraAllocations = [].concat(...Object.values(contractAllocations));\n    possibleExtraAnonymousAllocations = [].concat(...Object.values(contractAnonymousAllocations));\n  } //now we get all the library allocations!\n\n\n  const possibleLibraryAllocations = [].concat(...Object.values(libraryAllocations));\n  const possibleLibraryAnonymousAllocations = [].concat(...Object.values(libraryAnonymousAllocations)); //now we put it all together!\n\n  const possibleAllocations = possibleContractAllocations.concat(possibleLibraryAllocations);\n  const possibleAnonymousAllocations = possibleContractAnonymousAllocations.concat(possibleLibraryAnonymousAllocations);\n  const possibleAllocationsTotalMinusExtras = possibleAllocations.concat(possibleAnonymousAllocations); //...and also there's the extras\n\n  const possibleExtraAllocationsTotal = possibleExtraAllocations.concat(possibleExtraAnonymousAllocations);\n  const possibleAllocationsTotal = possibleAllocationsTotalMinusExtras.concat([null], //HACK: add sentinel value before the extras\n  possibleExtraAllocationsTotal); //whew!\n\n  let decodings = [];\n\n  allocationAttempts: for (const allocation of possibleAllocationsTotal) {\n    debug(\"trying allocation: %O\", allocation); //first: check for our sentinel value for extras (yeah, kind of HACKy)\n\n    if (allocation === null) {\n      switch (extras) {\n        case \"on\":\n          continue allocationAttempts;\n        //ignore the sentinel and continue\n\n        case \"off\":\n          break allocationAttempts;\n        //don't include extras; stop here\n\n        case \"necessary\":\n          //stop on the sentinel and exclude extras *unless* there are no decodings yet\n          if (decodings.length > 0) {\n            break allocationAttempts;\n          } else {\n            continue allocationAttempts;\n          }\n\n      }\n    } //second: do a name check so we can skip decoding if name is wrong\n    //(this will likely be a more detailed check in the future)\n\n\n    if (options.name !== undefined && allocation.abi.name !== options.name) {\n      continue;\n    } //now: the main part!\n\n\n    let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n\n    const contextHash = allocation.contextHash;\n    const attemptContext = info.contexts[contextHash];\n    const emittingContractType = Contexts.Import.contextToType(attemptContext);\n    const contractType = allocation.definedIn; //you can't map with a generator, so we have to do this map manually\n\n    let decodedArguments = [];\n\n    for (const argumentAllocation of allocation.arguments) {\n      let value; //if in full mode, use the allocation's listed data type.\n      //if in ABI mode, abify it before use.\n\n      let dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes);\n\n      try {\n        value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n          strictAbiMode: true,\n          allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n\n        });\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n          //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n            value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n          })); //3. retry this particular decode in ABI mode.\n\n          try {\n            value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n            argumentAllocation.pointer, info, {\n              strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n              //retries no longer allowed, not that this has an effect\n\n            });\n          } catch (_) {\n            //if an error occurred on the retry, this isn't a valid decoding!\n            debug(\"rejected due to exception on retry\");\n            continue allocationAttempts;\n          } //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n          //so we don't need to do anything special there.\n\n        } else {\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", error);\n          continue allocationAttempts;\n        }\n      }\n\n      const name = argumentAllocation.name;\n      const indexed = argumentAllocation.pointer.location === \"eventtopic\";\n      decodedArguments.push(name //deliberate general falsiness test\n      ? {\n        name,\n        indexed,\n        value\n      } : {\n        indexed,\n        value\n      });\n    }\n\n    if (!options.disableChecks) {\n      //OK, so, having decoded the result, the question is: does it reencode to the original?\n      //NOTE: we skip this check if disableChecks is passed! (it shouldn't be passed :P )\n      //first, we have to filter out the indexed arguments, and also get rid of the name information\n      const nonIndexedValues = decodedArguments.filter(argument => !argument.indexed).map(argument => argument.value); //now, we can encode!\n\n      const reEncodedData = AbiData.Encode.encodeTupleAbi(nonIndexedValues, info.allocations.abi);\n      const encodedData = info.state.eventdata; //again, not great to read this directly, but oh well\n      //are they equal?\n\n      if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n        //if not, this allocation doesn't work\n        debug(\"rejected due to [non-indexed] mismatch\");\n        continue;\n      }\n    } //one last check -- let's check that the indexed arguments match up, too\n    //(we won't skip this even if disableChecks was passed)\n\n\n    const indexedValues = decodedArguments.filter(argument => argument.indexed).map(argument => argument.value);\n    const reEncodedTopics = indexedValues.map(Topic.Encode.encodeTopic);\n    const encodedTopics = info.state.eventtopics; //now: do *these* match?\n\n    const selectorAdjustment = allocation.anonymous ? 0 : 1;\n\n    for (let i = 0; i < reEncodedTopics.length; i++) {\n      if (!Evm.Utils.equalData(reEncodedTopics[i], encodedTopics[i + selectorAdjustment])) {\n        debug(\"rejected due to indexed mismatch\");\n        continue allocationAttempts;\n      }\n    } //if we've made it here, the allocation works!  hooray!\n\n\n    debug(\"allocation accepted!\");\n    let decoding;\n\n    if (allocation.abi.anonymous) {\n      decoding = {\n        kind: \"anonymous\",\n        definedIn: contractType,\n        class: emittingContractType,\n        abi: allocation.abi,\n        arguments: decodedArguments,\n        decodingMode\n      };\n    } else {\n      decoding = {\n        kind: \"event\",\n        definedIn: contractType,\n        class: emittingContractType,\n        abi: allocation.abi,\n        arguments: decodedArguments,\n        selector,\n        decodingMode\n      };\n    }\n\n    decodings.push(decoding); //if we've made this far (so this allocation works), and we were passed an\n    //ID, and it matches this ID, bail out & return this as the *only* decoding\n\n    if (options.id && allocation.id === options.id) {\n      return [decoding];\n    }\n  }\n\n  return decodings;\n}\n\nexports.decodeEvent = decodeEvent;\nconst errorSelector = Conversion.toBytes(Web3Utils.soliditySha3({\n  type: \"string\",\n  value: \"Error(string)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst panicSelector = Conversion.toBytes(Web3Utils.soliditySha3({\n  type: \"string\",\n  value: \"Panic(uint256)\"\n})).subarray(0, Evm.Utils.SELECTOR_SIZE);\nconst defaultRevertAllocations = [{\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: errorSelector,\n  abi: {\n    name: \"Error\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"string\",\n      internalType: \"string\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: errorSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"string\",\n      typeHint: \"string\"\n    }\n  }]\n}, {\n  kind: \"revert\",\n  allocationMode: \"full\",\n  selector: panicSelector,\n  abi: {\n    name: \"Panic\",\n    type: \"error\",\n    inputs: [{\n      name: \"\",\n      type: \"uint256\",\n      internalType: \"uint256\"\n    }]\n  },\n  definedIn: null,\n  arguments: [{\n    name: \"\",\n    pointer: {\n      location: \"returndata\",\n      start: panicSelector.length,\n      length: Evm.Utils.WORD_SIZE\n    },\n    type: {\n      typeClass: \"uint\",\n      bits: Evm.Utils.WORD_SIZE * 8,\n      typeHint: \"uint256\"\n    }\n  }]\n}];\nconst defaultEmptyAllocations = [{\n  kind: \"failure\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}, {\n  kind: \"selfdestruct\",\n  allocationMode: \"full\",\n  selector: new Uint8Array(),\n  arguments: []\n}];\n/**\n * If there are multiple possibilities, they're always returned in\n * the order: return, revert, returnmessage, failure, empty, bytecode, unknownbytecode\n * Moreover, within \"revert\", builtin ones are put above custom ones\n * @Category Decoding\n */\n\nfunction* decodeReturndata(info, successAllocation, //null here must be explicit\nstatus, //you can pass this to indicate that you know the status,\nid //useful when status = false\n) {\n  let possibleAllocations;\n  const selector = Conversion.toHexString(info.state.returndata.slice(0, 4));\n  const contextHash = (info.currentContext || {\n    context: \"\"\n  }).context; //HACK: \"\" is used to represent no context\n\n  const customRevertAllocations = ((info.allocations.returndata || {\n    [contextHash]: {}\n  })[contextHash] || {\n    [selector]: []\n  })[selector] || [];\n\n  if (successAllocation === null) {\n    possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations];\n  } else {\n    switch (successAllocation.kind) {\n      case \"return\":\n        possibleAllocations = [successAllocation, ...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations];\n        break;\n\n      case \"bytecode\":\n        possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, ...defaultEmptyAllocations, successAllocation];\n        break;\n\n      case \"returnmessage\":\n        possibleAllocations = [...defaultRevertAllocations, ...customRevertAllocations, successAllocation, ...defaultEmptyAllocations];\n        break;\n      //Other cases shouldn't happen so I'm leaving them to cause errors!\n    }\n  }\n\n  let decodings = [];\n\n  allocationAttempts: for (const allocation of possibleAllocations) {\n    debug(\"trying allocation: %O\", allocation); //before we attempt to use this allocation, we check: does the selector match?\n\n    let encodedData = info.state.returndata; //again, not great to read this directly, but oh well\n\n    const encodedPrefix = encodedData.subarray(0, allocation.selector.length);\n\n    if (!Evm.Utils.equalData(encodedPrefix, allocation.selector)) {\n      continue;\n    }\n\n    encodedData = encodedData.subarray(allocation.selector.length); //slice off the selector for later\n    //also we check, does the status match?\n\n    if (status !== undefined) {\n      const successKinds = [\"return\", \"selfdestruct\", \"bytecode\", \"returnmessage\"];\n      const failKinds = [\"failure\", \"revert\"];\n\n      if (status) {\n        if (!successKinds.includes(allocation.kind)) {\n          continue;\n        }\n      } else {\n        if (!failKinds.includes(allocation.kind)) {\n          continue;\n        }\n      }\n    }\n\n    if (allocation.kind === \"bytecode\") {\n      //bytecode is special and can't really be integrated with the other cases.\n      //so it gets its own function.\n      const decoding = yield* decodeBytecode(info);\n\n      if (decoding) {\n        decodings.push(decoding);\n      }\n\n      continue;\n    }\n\n    if (allocation.kind === \"returnmessage\") {\n      //this kind is also special, though thankfully it's easier\n      const decoding = {\n        kind: \"returnmessage\",\n        status: true,\n        data: Conversion.toHexString(info.state.returndata),\n        decodingMode: allocation.allocationMode\n      };\n      decodings.push(decoding);\n      continue;\n    }\n\n    let decodingMode = allocation.allocationMode; //starts out here; degrades to abi if necessary\n    //you can't map with a generator, so we have to do this map manually\n\n    let decodedArguments = [];\n\n    for (const argumentAllocation of allocation.arguments) {\n      let value; //if in full mode, use the allocation's listed data type.\n      //if in ABI mode, abify it before use.\n\n      let dataType = decodingMode === \"full\" ? argumentAllocation.type : abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes); //now, let's decode!\n\n      try {\n        value = yield* decode_1.default(dataType, argumentAllocation.pointer, info, {\n          abiPointerBase: allocation.selector.length,\n          strictAbiMode: true,\n          allowRetry: decodingMode === \"full\" //this option is unnecessary but including for clarity\n\n        });\n        debug(\"value on first try: %O\", value);\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry && decodingMode === \"full\") {\n          debug(\"retry!\"); //if a retry happens, we've got to do several things in order to switch to ABI mode:\n          //1. mark that we're switching to ABI mode;\n\n          decodingMode = \"abi\"; //2. abify all previously decoded values;\n\n          decodedArguments = decodedArguments.map(argumentDecoding => Object.assign(Object.assign({}, argumentDecoding), {\n            value: abify_1.abifyResult(argumentDecoding.value, info.userDefinedTypes)\n          })); //3. retry this particular decode in ABI mode.\n\n          try {\n            value = yield* decode_1.default(abify_1.abifyType(argumentAllocation.type, info.userDefinedTypes), //type is now abified!\n            argumentAllocation.pointer, info, {\n              abiPointerBase: allocation.selector.length,\n              strictAbiMode: true //turns on STRICT MODE to cause more errors to be thrown\n              //retries no longer allowed, not that this has an effect\n\n            });\n            debug(\"value on retry: %O\", value);\n          } catch (_) {\n            //if an error occurred on the retry, this isn't a valid decoding!\n            debug(\"rejected due to exception on retry\");\n            continue allocationAttempts;\n          } //4. the remaining parameters will then automatically be decoded in ABI mode due to (1),\n          //so we don't need to do anything special there.\n\n        } else {\n          //if any other sort of error occurred, this isn't a valid decoding!\n          debug(\"rejected due to exception on first try: %O\", error);\n          continue allocationAttempts;\n        }\n      }\n\n      const name = argumentAllocation.name;\n      decodedArguments.push(name //deliberate general falsiness test\n      ? {\n        name,\n        value\n      } : {\n        value\n      });\n    } //OK, so, having decoded the result, the question is: does it reencode to the original?\n    //first, we have to filter out the indexed arguments, and also get rid of the name information\n\n\n    debug(\"decodedArguments: %O\", decodedArguments);\n    const decodedArgumentValues = decodedArguments.map(argument => argument.value);\n    const reEncodedData = AbiData.Encode.encodeTupleAbi(decodedArgumentValues, info.allocations.abi); //are they equal? note the selector has been stripped off encodedData!\n\n    if (!Evm.Utils.equalData(reEncodedData, encodedData)) {\n      //if not, this allocation doesn't work\n      debug(\"rejected due to mismatch\");\n      continue;\n    } //if we've made it here, the allocation works!  hooray!\n\n\n    debug(\"allocation accepted!\");\n    let decoding;\n\n    switch (allocation.kind) {\n      case \"return\":\n        decoding = {\n          kind: \"return\",\n          status: true,\n          arguments: decodedArguments,\n          decodingMode\n        };\n        break;\n\n      case \"revert\":\n        decoding = {\n          kind: \"revert\",\n          abi: allocation.abi,\n          definedIn: allocation.definedIn,\n          status: false,\n          arguments: decodedArguments,\n          decodingMode\n        };\n        break;\n\n      case \"selfdestruct\":\n        decoding = {\n          kind: \"selfdestruct\",\n          status: true,\n          decodingMode\n        };\n        break;\n\n      case \"failure\":\n        decoding = {\n          kind: \"failure\",\n          status: false,\n          decodingMode\n        };\n        break;\n    }\n\n    decodings.push(decoding); //if we've made this far (so this allocation works), and we were passed an\n    //ID, and it matches this ID, bail out & return this as the *only* decoding\n\n    if (id && allocation.kind === \"revert\" && allocation.id === id) {\n      return [decoding];\n    }\n  }\n\n  return decodings;\n}\n\nexports.decodeReturndata = decodeReturndata; //note: requires the bytecode to be in returndata, not code\n\nfunction* decodeBytecode(info) {\n  let decodingMode = \"full\"; //as always, degrade as necessary\n\n  const bytecode = Conversion.toHexString(info.state.returndata);\n  const context = Contexts.Utils.findContext(info.contexts, bytecode);\n\n  if (!context) {\n    return {\n      kind: \"unknownbytecode\",\n      status: true,\n      decodingMode: \"full\",\n      bytecode\n    };\n  }\n\n  const contractType = Contexts.Import.contextToType(context); //now: ignore original allocation (which we didn't even pass :) )\n  //and lookup allocation by context\n\n  const allocation = info.allocations.calldata.constructorAllocations[context.context].output;\n  debug(\"bytecode allocation: %O\", allocation); //now: add immutables if applicable\n\n  let immutables;\n\n  if (allocation.immutables) {\n    immutables = []; //NOTE: if we're in here, we can assume decodingMode === \"full\"\n\n    for (const variable of allocation.immutables) {\n      const dataType = variable.type; //we don't conditioning on decodingMode here because we know it\n\n      let value;\n\n      try {\n        value = yield* decode_1.default(dataType, variable.pointer, info, {\n          allowRetry: true,\n          strictAbiMode: true,\n          paddingMode: \"defaultOrZero\"\n        });\n      } catch (error) {\n        if (error instanceof errors_1.StopDecodingError && error.allowRetry) {\n          //we \"retry\" by... not bothering with immutables :P\n          //(but we do set the mode to ABI)\n          decodingMode = \"abi\";\n          immutables = undefined;\n          break;\n        } else {\n          //otherwise, this isn't a valid decoding I guess\n          return null;\n        }\n      }\n\n      immutables.push({\n        name: variable.name,\n        class: variable.definedIn,\n        value\n      });\n    }\n  }\n\n  let decoding = {\n    kind: \"bytecode\",\n    status: true,\n    decodingMode,\n    bytecode,\n    immutables,\n    class: contractType\n  }; //finally: add address if applicable\n\n  if (allocation.delegatecallGuard) {\n    decoding.address = Web3Utils.toChecksumAddress(bytecode.slice(4, 4 + 2 * Evm.Utils.ADDRESS_SIZE) //4 = \"0x73\".length\n    );\n  }\n\n  return decoding;\n}\n/**\n * Decodes the return data from a failed call.\n *\n * @param returndata The returned data, as a Uint8Array.\n * @return An array of possible decodings.  At the moment it's\n *   impossible for there to be more than one.  (If the call didn't actually\n *   fail, or failed in a nonstandard way, you may get no decodings at all, though!)\n *\n *   Decodings can either be decodings of revert messages, or decodings\n *   indicating that there was no revert message.  If somehow both were to be\n *   possible, they'd go in that order, although as mentioned, there (at least\n *   currently) isn't any way for that to occur.\n * @Category Decoding convenience\n */\n\n\nfunction decodeRevert(returndata) {\n  //coercing because TS doesn't know it'll finish in one go\n  return decodeReturndata({\n    allocations: {},\n    state: {\n      storage: {},\n      returndata\n    }\n  }, null, false).next().value;\n}\n\nexports.decodeRevert = decodeRevert;","map":null,"metadata":{},"sourceType":"script"}