{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Utils = exports.Types = void 0;\n/**\n * # Codec Output Format\n *\n * ## Module information\n *\n * This module primarily defines TypeScript types for the output format\n * used in results provided by packages\n * `@truffle/decoder@^4.0.0` and `@truffle/codec@^0.1.0`.\n *\n * See below for complete listing or continue reading\n * [Format information](#format-information) to learn about this format.\n *\n * ### How to import\n *\n * Import either as part of Codec or by itself:\n *\n * ```typescript\n * // when importing entire Codec, use Codec.Format.*:\n * import * as Codec from \"@truffle/codec\";\n *\n * // or import Format directly:\n * import { Format } from \"@truffle/codec\";\n * ```\n *\n * ![Example struct decoding](media://example-struct-decoding.png)\n *\n * ## Format information\n *\n * This format is intended for use in smart contract and dapp development\n * tools and libraries, and for use in display contexts, such as when\n * building on-screen components to show transaction and smart contract\n * state information.\n *\n * This format seeks to provide an exhaustive schema for JavaScript\n * objects to encode **lossless**, **machine-readable** representations of\n * all possible Solidity and ABI data types and all possible values of those\n * types.\n *\n * This format targets types and values understood by the\n * [Solidity programming language](https://solidity.readthedocs.io) and\n * the [Contract ABI specification](https://solidity.readthedocs.io/en/v0.5.3/abi-spec.html),\n * within the context of the [Ethereum Virtual Machine](https://ethereum.github.io/yellowpaper/paper.pdf)\n * (EVM) and in raw data for transactions and logs according to the\n * [Ethereum JSON RPC](https://github.com/ethereum/wiki/wiki/JSON-RPC).\n *\n * Objects in this format may be deeply nested and/or contain circular\n * dependencies. As such, **do not** serialize objects in this format or\n * otherwise attempt to display them in full without considering potential\n * risk. **Objects in this format are for the machine to read, not humans!**\n * This module provides utilities for inspecting objects in this format,\n * including the **safe** [[Format.Utils.Inspect.ResultInspector]] wrapper\n * (for [util.inspect](https://nodejs.org/api/util.html#util_util_inspect_object_options)),\n * and the **unsafe** [[Format.Utils.Inspect.unsafeNativize]] function. For more\n * information, please see the documentation for those utilities.\n *\n * ### Specification\n *\n * Individual decoded values are represented by objects of the type\n * [[Format.Values.Result]], which contain the following fields:\n *   1. `type`: This is a [[Format.Types.Type|`Type`]] object describing the value's\n *     type.  Each `Type` has a `typeClass` field describing the overall broad type,\n *     such as `\"uint\"` or `\"bytes\"`, together with additional information that gives\n *     the specific type.  For full detail, see [[Format.Types]].\n *\n *   2. `kind`: This is either `\"value\"`, in which case the `Result` is a\n *     [[Format.Values.Value|`Value`]], or `\"error\"`, in which case the `Result` is an\n *     [[Format.Errors.ErrorResult|`ErrorResult`]].  In the former case, there will be\n *     a `value` field containin the decoded value.  In the latter case, there will be\n *     an `error` field indicating what went wrong.  *Warning*: When decoding a\n *     complex type, such as an array, mapping, or array, getting a kind of `\"value\"`\n *     does not necessarily mean the individual elements were decoded successfully.\n *     Even if the `Result` for the array (mapping, struct) as a whole has kind\n *     `\"value\"`, the elements might still have kind `\"error\"`.\n *\n *   3. `value`: As mentioned, this is included when `kind` is equal to `\"value\"`.\n *     It contains information about the actual decoded value.  See\n *     [[Format.Values|`Format.Values`]] for more information.\n *\n *   4. `error`: The alternative to `value`.  Generally includes information about\n *     the raw data that led to the error.  See [[Format.Errors|`Format.Errors`]] for\n *     more information.\n *\n *   5. `reference`: This field is a debugger-only feature and does not\n *      apply to results returned by  @truffle/decoder, so it won't be documented here.\n *\n * ### Values vs. errors\n *\n * It's worth taking a moment here to answer the question: What counts as a value,\n * and what counts as an error?\n *\n * In general, the answer is that anything that can be generated via Solidity\n * alone (i.e. no assembly), with correctly-encoded inputs, and without making use\n * of compiler bugs, is a value, not an error.  That means that, for instance, the\n * following things are values, not errors:\n *   - A variable of contract type whose address does not actually hold a\n *     contract of that type;\n *   - An external function pointer that does not correspond to a valid\n *     function;\n *   - A string containing invalid UTF-8;\n *   - ..., etc.\n *\n * By contrast, the following *are* errors:\n *   - A `bool` which is neither `false` (0) nor `true` (1);\n *   - An `enum` which is out of range;\n *   - ..., etc.\n *\n * (You may be wondering about the enum case here, because if you go sufficiently\n * far back, to Solidity 0.4.4 or earlier, it *was* possible to generate\n * out-of-range enums without resorting to assembly or compiler bugs.  However,\n * enums are only supported in full mode (see\n * [Notes on decoding modes](../#decoding-modes)),\n * which only supports 0.4.12 and later, so\n * we consider out-of-range enums an error.  There are also additional technical\n * reasons why supporting out-of-range enums as a value would be difficult.)\n *\n * There are three special cases here that are likely worthy of note.\n *\n * Firstly, internal function pointers currently can't be meaningfully\n * decoded via @truffle/decoder.  However, they decode to a bare-bones value,\n * not an error, as it is (in a sense) our own fault that we can't decode\n * these, so it doesn't make sense to report an error, which would mean that\n * something is wrong with the encoded data itself.  This value that it\n * decodes to will give the program counter values it corresponds to, but\n * will not include the function name or defining class, as @truffle/decoder\n * is not presently capable of that.  For now, full decoding of internal\n * function pointers remains a debugger-only feature.  (But limited support for\n * this via @truffle/decoder is planned for the future.)\n *\n * (When using the debugger, an invalid internal function pointer will decode to an\n * error.  However, when using @truffle/decoder, we have no way of discerning whether\n * the pointer is valid or not, so internal function pointers will always decode to\n * a value, if an uninformative one.)\n *\n * Secondly, when decoding events, it is impossible to decode indexed parameters\n * of reference type.  Thus, these decode to an error\n * (`IndexedReferenceTypeError`, which see) rather than to a value.\n *\n * Thirdly, the decoder is currently limited when it comes to decoding state\n * variables that are declared constant, and not all such variables are yet\n * supported in decoding; attempting to decode one of these that is not currently\n * supported will yield an error.\n *\n * Similarly, there are various things that decode to errors for technical reasons.\n * Objects with encoded length fields larger than what fits in a JavaScript safe\n * integer, or pointed to by pointers with values larger than what fits in a\n * JavaScript safe integer, will decode to errors, even if they may technically be\n * legal.  Such cases are impractical to handle and should never come up in real\n * use so we decode them to errors.  Errors may also be returned in case of an\n * error in attempting to read the data to be decoded.\n *\n * Finally, except when decoding events, we do not return an error if the pointers\n * in an ABI-encoded array or tuple are arranged in a nonstandard way, or if\n * strings or bytestrings are incorrectly padded, because it is not worth the\n * trouble to detect these conditions.\n *\n *\n * ## Notes on this documentation\n *\n * Most of this doesn't have explanatory documentation\n * because it's largely self-explanatory, but particularly\n * non-obvious parts have been documented for clarity.\n *\n * A note on optional fields: A number of types or values\n * have optional fields.  These contain helpful\n * but non-essential information, or information which\n * for technical reasons we can't guarantee we can determine.\n *\n * @category Data\n *\n * @packageDocumentation\n */\n\nconst common_1 = require(\"./common\");\n\nObject.defineProperty(exports, \"Types\", {\n  enumerable: true,\n  get: function () {\n    return common_1.Types;\n  }\n});\n\nconst Utils = __importStar(require(\"./utils\"));\n\nexports.Utils = Utils;","map":null,"metadata":{},"sourceType":"script"}