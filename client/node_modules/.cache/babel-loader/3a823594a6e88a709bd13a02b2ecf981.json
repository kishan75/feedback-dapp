{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.encodeTupleAbi = exports.encodeAbi = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:encode\");\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Basic = __importStar(require(\"../../basic\"));\n\nconst Bytes = __importStar(require(\"../../bytes\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst allocate_1 = require(\"../allocate\");\n\nconst sum_1 = __importDefault(require(\"lodash/sum\")); //UGH -- it turns out TypeScript can't handle nested tagged unions\n//see: https://github.com/microsoft/TypeScript/issues/18758\n//so, I'm just going to have to throw in a bunch of type coercions >_>\n\n/**\n * @Category Encoding (low-level)\n */\n\n\nfunction encodeAbi(input, allocations) {\n  //errors can't be encoded\n  if (input.kind === \"error\") {\n    return undefined;\n  }\n\n  let bytes; //TypeScript can at least infer in the rest of this that we're looking\n  //at a value, not an error!  But that's hardly enough...\n\n  switch (input.type.typeClass) {\n    case \"mapping\":\n    case \"magic\":\n    case \"type\":\n      //none of these can go in the ABI\n      return undefined;\n\n    case \"bytes\":\n      switch (input.type.kind) {\n        case \"static\":\n          return Basic.Encode.encodeBasic(input);\n\n        case \"dynamic\":\n          bytes = Bytes.Encode.encodeBytes(input);\n          return padAndPrependLength(bytes);\n      }\n\n    case \"string\":\n      bytes = Bytes.Encode.encodeBytes(input);\n      return padAndPrependLength(bytes);\n\n    case \"function\":\n      {\n        switch (input.type.visibility) {\n          case \"internal\":\n            return undefined;\n          //internal functions can't go in the ABI!\n          //Yes, technically we could defer to encodeBasic here, but,\n          //c'mon, that's not how the function's supposed to be used\n\n          case \"external\":\n            return Basic.Encode.encodeBasic(input);\n        }\n      }\n    //now for the serious cases\n\n    case \"array\":\n      {\n        let coercedInput = input;\n\n        if (coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        let staticEncoding = encodeTupleAbi(coercedInput.value, allocations);\n\n        switch (input.type.kind) {\n          case \"static\":\n            return staticEncoding;\n\n          case \"dynamic\":\n            let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + staticEncoding.length); //leave room for length\n\n            encoded.set(staticEncoding, Evm.Utils.WORD_SIZE); //again, leave room for length beforehand\n\n            let lengthBytes = Conversion.toBytes(coercedInput.value.length, Evm.Utils.WORD_SIZE);\n            encoded.set(lengthBytes); //and now we set the length\n\n            return encoded;\n        }\n      }\n\n    case \"struct\":\n      {\n        let coercedInput = input;\n\n        if (coercedInput.reference !== undefined) {\n          return undefined; //circular values can't be encoded\n        }\n\n        return encodeTupleAbi(coercedInput.value.map(({\n          value\n        }) => value), allocations);\n      }\n\n    case \"tuple\":\n      //WARNING: This case is written in a way that involves a bunch of unnecessary recomputation!\n      //(That may not be apparent from this one line, but it's true)\n      //I'm writing it this way anyway for simplicity, to avoid rewriting the encoder\n      //However it may be worth revisiting this in the future if performance turns out to be a problem\n      return encodeTupleAbi(input.value.map(({\n        value\n      }) => value), allocations);\n\n    default:\n      return Basic.Encode.encodeBasic(input);\n  }\n}\n\nexports.encodeAbi = encodeAbi;\n/**\n * @Category Encoding (low-level)\n */\n\nfunction padAndPrependLength(bytes) {\n  let length = bytes.length;\n  let paddedLength = Evm.Utils.WORD_SIZE * Math.ceil(length / Evm.Utils.WORD_SIZE);\n  let encoded = new Uint8Array(Evm.Utils.WORD_SIZE + paddedLength);\n  encoded.set(bytes, Evm.Utils.WORD_SIZE); //start 32 in to leave room for the length beforehand\n\n  let lengthBytes = Conversion.toBytes(length, Evm.Utils.WORD_SIZE);\n  encoded.set(lengthBytes); //and now we set the length\n\n  return encoded;\n}\n/**\n * @Category Encoding (low-level)\n */\n\n\nfunction encodeTupleAbi(tuple, allocations) {\n  let elementEncodings = tuple.map(element => encodeAbi(element, allocations));\n\n  if (elementEncodings.some(element => element === undefined)) {\n    return undefined;\n  }\n\n  let elementSizeInfo = tuple.map(element => allocate_1.abiSizeInfo(element.type, allocations)); //heads and tails here are as discussed in the ABI docs;\n  //for a static type the head is the encoding and the tail is empty,\n  //for a dynamic type the head is the pointer and the tail is the encoding\n\n  let heads = [];\n  let tails = []; //but first, we need to figure out where the first tail will start,\n  //by adding up the sizes of all the heads (we can easily do this in\n  //advance via elementSizeInfo, without needing to know the particular\n  //values of the heads)\n\n  let startOfNextTail = sum_1.default(elementSizeInfo.map(elementInfo => elementInfo.size));\n\n  for (let i = 0; i < tuple.length; i++) {\n    let head;\n    let tail;\n\n    if (!elementSizeInfo[i].dynamic) {\n      //static case\n      head = elementEncodings[i];\n      tail = new Uint8Array(); //empty array\n    } else {\n      //dynamic case\n      head = Conversion.toBytes(startOfNextTail, Evm.Utils.WORD_SIZE);\n      tail = elementEncodings[i];\n    }\n\n    heads.push(head);\n    tails.push(tail);\n    startOfNextTail += tail.length;\n  } //finally, we need to concatenate everything together!\n  //since we're dealing with Uint8Arrays, we have to do this manually\n\n\n  let totalSize = startOfNextTail;\n  let encoded = new Uint8Array(totalSize);\n  let position = 0;\n\n  for (let head of heads) {\n    encoded.set(head, position);\n    position += head.length;\n  }\n\n  for (let tail of tails) {\n    encoded.set(tail, position);\n    position += tail.length;\n  }\n\n  return encoded;\n}\n\nexports.encodeTupleAbi = encodeTupleAbi;","map":null,"metadata":{},"sourceType":"script"}