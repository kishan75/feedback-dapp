{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.cleanBool = exports.countDecimalPlaces = exports.shiftBigDown = exports.shiftBigUp = exports.toBytes = exports.toHexString = exports.toBig = exports.toBigInt = exports.toSignedBN = exports.toBN = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:conversion\");\n\nconst bn_js_1 = __importDefault(require(\"bn.js\"));\n\nconst big_js_1 = __importDefault(require(\"big.js\"));\n/**\n * @param bytes - undefined | string | number | BN | Uint8Array | Big\n * @return {BN}\n */\n\n\nfunction toBN(bytes) {\n  if (bytes === undefined) {\n    return undefined;\n  } else if (typeof bytes == \"string\") {\n    return new bn_js_1.default(bytes, 16);\n  } else if (typeof bytes == \"number\" || bn_js_1.default.isBN(bytes)) {\n    return new bn_js_1.default(bytes);\n  } else if (bytes instanceof big_js_1.default) {\n    return new bn_js_1.default(bytes.toFixed()); //warning, better hope input is integer!\n    //note: going through string may seem silly but it's actually not terrible here,\n    //since BN is binary-based and Big is decimal-based\n    //[toFixed is like toString except it guarantees scientific notation is not used]\n  } else if (typeof bytes.reduce === \"function\") {\n    return bytes.reduce((num, byte) => num.shln(8).addn(byte), new bn_js_1.default(0));\n  }\n}\n\nexports.toBN = toBN;\n/**\n * @param bytes - Uint8Array\n * @return {BN}\n */\n\nfunction toSignedBN(bytes) {\n  if (bytes[0] < 0x80) {\n    // if first bit is 0\n    return toBN(bytes);\n  } else {\n    return toBN(bytes.map(b => 0xff - b)).addn(1).neg();\n  }\n}\n\nexports.toSignedBN = toSignedBN;\n\nfunction toBigInt(value) {\n  //BN is binary-based, so we convert by means of a hex string in order\n  //to avoid having to do a binary-decimal conversion and back :P\n  return !value.isNeg() ? BigInt(\"0x\" + value.toString(16)) : -BigInt(\"0x\" + value.neg().toString(16)); //can't directly make negative BigInt from hex string\n}\n\nexports.toBigInt = toBigInt;\n\nfunction toBig(value) {\n  //note: going through string may seem silly but it's actually not terrible here,\n  //since BN (& number) is binary-based and Big is decimal-based\n  return new big_js_1.default(value.toString());\n}\n\nexports.toBig = toBig;\n/**\n * @param bytes - Uint8Array | BN\n * @param padLength - number - minimum desired byte length (left-pad with zeroes)\n * @param padRight - boolean - causes padding to occur on right instead of left\n * @return {string}\n */\n\nfunction toHexString(bytes, padLength = 0, padRight = false) {\n  if (bn_js_1.default.isBN(bytes)) {\n    bytes = toBytes(bytes);\n  }\n\n  const pad = s => \"\".concat(\"00\".slice(0, 2 - s.length)).concat(s); //                                          0  1  2  3  4\n  //                                 0  1  2  3  4  5  6  7\n  // bytes.length:        5  -  0x(          e5 c2 aa 09 11 )\n  // length (preferred):  8  -  0x( 00 00 00 e5 c2 aa 09 11 )\n  //                                `--.---'\n  //                                     offset 3\n\n\n  if (bytes.length < padLength) {\n    let prior = bytes;\n    bytes = new Uint8Array(padLength);\n\n    if (padRight) {\n      //unusual case: pad on right\n      bytes.set(prior);\n    } else {\n      //usual case\n      bytes.set(prior, padLength - prior.length);\n    }\n  }\n\n  debug(\"bytes: %o\", bytes);\n  let string = bytes.reduce((str, byte) => \"\".concat(str).concat(pad(byte.toString(16))), \"\");\n  return \"0x\".concat(string);\n}\n\nexports.toHexString = toHexString;\n\nfunction toBytes(data, length = 0) {\n  //note that length is a minimum output length\n  //strings will be 0-padded on left\n  //numbers/BNs will be sign-padded on left\n  //NOTE: if a number/BN is passed in that is too big for the given length,\n  //you will get an error!\n  //(note that strings passed in should be hex strings; this is not for converting\n  //generic strings to hex)\n  if (typeof data === \"string\") {\n    let hex = data; //renaming for clarity\n\n    if (hex.startsWith(\"0x\")) {\n      hex = hex.slice(2);\n    }\n\n    if (hex === \"\") {\n      //this special case is necessary because the match below will return null,\n      //not an empty array, when given an empty string\n      return new Uint8Array(0);\n    }\n\n    if (hex.length % 2 == 1) {\n      hex = \"0\".concat(hex);\n    }\n\n    let bytes = new Uint8Array(hex.match(/.{2}/g).map(byte => parseInt(byte, 16)));\n\n    if (bytes.length < length) {\n      let prior = bytes;\n      bytes = new Uint8Array(length);\n      bytes.set(prior, length - prior.length);\n    }\n\n    return bytes;\n  } else {\n    // BN/Big/number case\n    if (typeof data === \"number\") {\n      data = new bn_js_1.default(data);\n    } else if (data instanceof big_js_1.default) {\n      //note: going through string may seem silly but it's actually not terrible here,\n      //since BN is binary-based and Big is decimal-based\n      data = new bn_js_1.default(data.toFixed()); //[toFixed is like toString except it guarantees scientific notation is not used]\n    } //note that the argument for toTwos is given in bits\n\n\n    return data.toTwos(length * 8).toArrayLike(Uint8Array, \"be\", length); //big-endian\n  }\n}\n\nexports.toBytes = toBytes; //computes value * 10**decimalPlaces\n\nfunction shiftBigUp(value, decimalPlaces) {\n  let newValue = new big_js_1.default(value);\n  newValue.e += decimalPlaces;\n  return newValue;\n}\n\nexports.shiftBigUp = shiftBigUp; //computes value * 10**-decimalPlaces\n\nfunction shiftBigDown(value, decimalPlaces) {\n  let newValue = new big_js_1.default(value);\n  newValue.e -= decimalPlaces;\n  return newValue;\n}\n\nexports.shiftBigDown = shiftBigDown; //we don't need this yet, but we will eventually\n\nfunction countDecimalPlaces(value) {\n  return Math.max(0, value.c.length - value.e - 1);\n}\n\nexports.countDecimalPlaces = countDecimalPlaces; //converts out of range booleans to true; something of a HACK\n//NOTE: does NOT do this recursively inside structs, arrays, etc!\n//I mean, those aren't elementary and therefore aren't in the domain\n//anyway, but still\n\nfunction cleanBool(result) {\n  switch (result.kind) {\n    case \"value\":\n      return result;\n\n    case \"error\":\n      switch (result.error.kind) {\n        case \"BoolOutOfRangeError\":\n          //return true\n          return {\n            type: result.type,\n            kind: \"value\",\n            value: {\n              asBoolean: true\n            }\n          };\n\n        default:\n          return result;\n      }\n\n  }\n}\n\nexports.cleanBool = cleanBool;","map":null,"metadata":{},"sourceType":"script"}