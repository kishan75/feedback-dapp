{"ast":null,"code":"import prand from 'pure-rand';\nimport { VerbosityLevel } from './VerbosityLevel.js';\nexport class QualifiedParameters {\n  constructor(op) {\n    const p = op || {};\n    this.seed = QualifiedParameters.readSeed(p);\n    this.randomType = QualifiedParameters.readRandomType(p);\n    this.numRuns = QualifiedParameters.readNumRuns(p);\n    this.verbose = QualifiedParameters.readVerbose(p);\n    this.maxSkipsPerRun = QualifiedParameters.readOrDefault(p, 'maxSkipsPerRun', 100);\n    this.timeout = QualifiedParameters.readOrDefault(p, 'timeout', null);\n    this.skipAllAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'skipAllAfterTimeLimit', null);\n    this.interruptAfterTimeLimit = QualifiedParameters.readOrDefault(p, 'interruptAfterTimeLimit', null);\n    this.markInterruptAsFailure = QualifiedParameters.readBoolean(p, 'markInterruptAsFailure');\n    this.skipEqualValues = QualifiedParameters.readBoolean(p, 'skipEqualValues');\n    this.ignoreEqualValues = QualifiedParameters.readBoolean(p, 'ignoreEqualValues');\n    this.logger = QualifiedParameters.readOrDefault(p, 'logger', v => {\n      console.log(v);\n    });\n    this.path = QualifiedParameters.readOrDefault(p, 'path', '');\n    this.unbiased = QualifiedParameters.readBoolean(p, 'unbiased');\n    this.examples = QualifiedParameters.readOrDefault(p, 'examples', []);\n    this.endOnFailure = QualifiedParameters.readBoolean(p, 'endOnFailure');\n    this.reporter = QualifiedParameters.readOrDefault(p, 'reporter', null);\n    this.asyncReporter = QualifiedParameters.readOrDefault(p, 'asyncReporter', null);\n  }\n\n  toParameters() {\n    const orUndefined = value => value !== null ? value : undefined;\n\n    return {\n      seed: this.seed,\n      randomType: this.randomType,\n      numRuns: this.numRuns,\n      maxSkipsPerRun: this.maxSkipsPerRun,\n      timeout: orUndefined(this.timeout),\n      skipAllAfterTimeLimit: orUndefined(this.skipAllAfterTimeLimit),\n      interruptAfterTimeLimit: orUndefined(this.interruptAfterTimeLimit),\n      markInterruptAsFailure: this.markInterruptAsFailure,\n      skipEqualValues: this.skipEqualValues,\n      ignoreEqualValues: this.ignoreEqualValues,\n      path: this.path,\n      logger: this.logger,\n      unbiased: this.unbiased,\n      verbose: this.verbose,\n      examples: this.examples,\n      endOnFailure: this.endOnFailure,\n      reporter: orUndefined(this.reporter),\n      asyncReporter: orUndefined(this.asyncReporter)\n    };\n  }\n\n  static read(op) {\n    return new QualifiedParameters(op);\n  }\n\n}\n\nQualifiedParameters.readSeed = p => {\n  if (p.seed == null) return Date.now() ^ Math.random() * 0x100000000;\n  const seed32 = p.seed | 0;\n  if (p.seed === seed32) return seed32;\n  const gap = p.seed - seed32;\n  return seed32 ^ gap * 0x100000000;\n};\n\nQualifiedParameters.readRandomType = p => {\n  if (p.randomType == null) return prand.xorshift128plus;\n\n  if (typeof p.randomType === 'string') {\n    switch (p.randomType) {\n      case 'mersenne':\n        return prand.mersenne;\n\n      case 'congruential':\n        return prand.congruential;\n\n      case 'congruential32':\n        return prand.congruential32;\n\n      case 'xorshift128plus':\n        return prand.xorshift128plus;\n\n      case 'xoroshiro128plus':\n        return prand.xoroshiro128plus;\n\n      default:\n        throw new Error(\"Invalid random specified: '\".concat(p.randomType, \"'\"));\n    }\n  }\n\n  return p.randomType;\n};\n\nQualifiedParameters.readNumRuns = p => {\n  const defaultValue = 100;\n  if (p.numRuns != null) return p.numRuns;\n  if (p.num_runs != null) return p.num_runs;\n  return defaultValue;\n};\n\nQualifiedParameters.readVerbose = p => {\n  if (p.verbose == null) return VerbosityLevel.None;\n\n  if (typeof p.verbose === 'boolean') {\n    return p.verbose === true ? VerbosityLevel.Verbose : VerbosityLevel.None;\n  }\n\n  if (p.verbose <= VerbosityLevel.None) {\n    return VerbosityLevel.None;\n  }\n\n  if (p.verbose >= VerbosityLevel.VeryVerbose) {\n    return VerbosityLevel.VeryVerbose;\n  }\n\n  return p.verbose | 0;\n};\n\nQualifiedParameters.readBoolean = (p, key) => p[key] === true;\n\nQualifiedParameters.readOrDefault = (p, key, defaultValue) => {\n  const value = p[key];\n  return value != null ? value : defaultValue;\n};","map":null,"metadata":{},"sourceType":"module"}