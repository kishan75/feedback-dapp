{"ast":null,"code":"import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { array } from './array.js';\nimport { base64 } from './base64.js';\nimport { MaxLengthUpperBound } from './_internals/helpers/MaxLengthFromMinLength.js';\nimport { extractStringConstraints } from './_internals/helpers/StringConstraintsExtractor.js';\nimport { codePointsToStringMapper, codePointsToStringUnmapper } from './_internals/mappers/CodePointsToString.js';\nimport { stringToBase64Mapper, stringToBase64Unmapper } from './_internals/mappers/StringToBase64.js';\n\nfunction base64String(...args) {\n  const constraints = extractStringConstraints(args);\n  const _constraints$minLengt = constraints.minLength,\n        unscaledMinLength = _constraints$minLengt === void 0 ? 0 : _constraints$minLengt,\n        _constraints$maxLengt = constraints.maxLength,\n        unscaledMaxLength = _constraints$maxLengt === void 0 ? MaxLengthUpperBound : _constraints$maxLengt,\n        size = constraints.size;\n  const minLength = unscaledMinLength + 3 - (unscaledMinLength + 3) % 4;\n  const maxLength = unscaledMaxLength - unscaledMaxLength % 4;\n  const requestedSize = constraints.maxLength === undefined && size === undefined ? '=' : size;\n  if (minLength > maxLength) throw new Error('Minimal length should be inferior or equal to maximal length');\n  if (minLength % 4 !== 0) throw new Error('Minimal length of base64 strings must be a multiple of 4');\n  if (maxLength % 4 !== 0) throw new Error('Maximal length of base64 strings must be a multiple of 4');\n  return convertFromNext(convertToNext(array(base64(), {\n    minLength,\n    maxLength,\n    size: requestedSize\n  })).map(codePointsToStringMapper, codePointsToStringUnmapper).map(stringToBase64Mapper, stringToBase64Unmapper));\n}\n\nexport { base64String };","map":null,"metadata":{},"sourceType":"module"}