{"ast":null,"code":"import { MaxLengthUpperBound } from '../helpers/MaxLengthFromMinLength.js';\nexport function patternsToStringMapper(tab) {\n  return tab.join('');\n}\nexport function patternsToStringUnmapperFor(patternsArb, constraints) {\n  return function patternsToStringUnmapper(value) {\n    if (typeof value !== 'string') {\n      throw new Error('Unsupported value');\n    }\n\n    const minLength = constraints.minLength !== undefined ? constraints.minLength : 0;\n    const maxLength = constraints.maxLength !== undefined ? constraints.maxLength : MaxLengthUpperBound;\n\n    if (value.length === 0) {\n      if (minLength > 0) {\n        throw new Error('Unable to unmap received string');\n      }\n\n      return [];\n    }\n\n    const stack = [{\n      endIndexChunks: 0,\n      nextStartIndex: 1,\n      chunks: []\n    }];\n\n    while (stack.length > 0) {\n      const last = stack.pop();\n\n      for (let index = last.nextStartIndex; index <= value.length; ++index) {\n        const chunk = value.substring(last.endIndexChunks, index);\n\n        if (patternsArb.canShrinkWithoutContext(chunk)) {\n          const newChunks = last.chunks.concat([chunk]);\n\n          if (index === value.length) {\n            if (newChunks.length < minLength || newChunks.length > maxLength) {\n              break;\n            }\n\n            return newChunks;\n          }\n\n          stack.push({\n            endIndexChunks: last.endIndexChunks,\n            nextStartIndex: index + 1,\n            chunks: last.chunks\n          });\n          stack.push({\n            endIndexChunks: index,\n            nextStartIndex: index + 1,\n            chunks: newChunks\n          });\n          break;\n        }\n      }\n    }\n\n    throw new Error('Unable to unmap received string');\n  };\n}","map":null,"metadata":{},"sourceType":"module"}