{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.collectAllocationInfo = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:abi-data:allocate:utils\");\n\nconst Compilations = __importStar(require(\"../../compilations\"));\n\nconst compile_common_1 = require(\"@truffle/compile-common\");\n\nconst Contexts = __importStar(require(\"../../contexts\"));\n\nconst Abi = __importStar(require(\"@truffle/abi-utils\"));\n\nfunction collectAllocationInfo(compilations) {\n  let contexts = {};\n  let deployedContexts = {};\n  let contractsAndContexts = [];\n\n  for (const compilation of compilations) {\n    for (const contract of compilation.contracts) {\n      const node = Compilations.Utils.getContractNode(contract, compilation);\n      let deployedContext = undefined;\n      let constructorContext = undefined;\n      const deployedBytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.deployedBytecode);\n      const bytecode = compile_common_1.Shims.NewToLegacy.forBytecode(contract.bytecode);\n\n      if (deployedBytecode && deployedBytecode !== \"0x\") {\n        deployedContext = Contexts.Utils.makeContext(contract, node, compilation);\n        contexts[deployedContext.context] = deployedContext; //note that we don't set up deployedContexts until after normalization!\n      }\n\n      if (bytecode && bytecode !== \"0x\") {\n        constructorContext = Contexts.Utils.makeContext(contract, node, compilation, true);\n        contexts[constructorContext.context] = constructorContext;\n      }\n\n      contractsAndContexts.push({\n        contract,\n        node,\n        deployedContext,\n        constructorContext,\n        compilationId: compilation.id\n      });\n    }\n  }\n\n  debug(\"known contexts: %o\", Object.keys(contexts));\n  contexts = Contexts.Utils.normalizeContexts(contexts);\n  deployedContexts = Object.assign({}, ...Object.values(contexts).map(context => !context.isConstructor ? {\n    [context.context]: context\n  } : {}));\n\n  for (const contractAndContexts of contractsAndContexts) {\n    //change everything to normalized version\n    if (contractAndContexts.deployedContext) {\n      contractAndContexts.deployedContext = contexts[contractAndContexts.deployedContext.context]; //get normalized version\n    }\n\n    if (contractAndContexts.constructorContext) {\n      contractAndContexts.constructorContext = contexts[contractAndContexts.constructorContext.context]; //get normalized version\n    }\n  }\n\n  const allocationInfo = contractsAndContexts.map(({\n    contract: {\n      abi,\n      compiler,\n      immutableReferences\n    },\n    compilationId,\n    node,\n    deployedContext,\n    constructorContext\n  }) => ({\n    abi: Abi.normalize(abi),\n    compilationId,\n    compiler,\n    contractNode: node,\n    deployedContext,\n    constructorContext,\n    immutableReferences\n  }));\n  return {\n    contexts,\n    deployedContexts,\n    contractsAndContexts,\n    allocationInfo\n  };\n}\n\nexports.collectAllocationInfo = collectAllocationInfo;","map":null,"metadata":{},"sourceType":"script"}