{"ast":null,"code":"import { add64, isEqual64, isStrictlyPositive64, isStrictlySmaller64, substract64, Unit64 } from '../_internals/helpers/ArrayInt64.js';\nimport { arrayInt64 } from '../_internals/ArrayInt64Arbitrary.js';\nimport { doubleToIndex, indexToDouble } from '../_internals/helpers/DoubleHelpers.js';\nimport { convertFromNext, convertToNext } from '../../check/arbitrary/definition/Converters.js';\n\nfunction safeDoubleToIndex(d, constraintsLabel) {\n  if (Number.isNaN(d)) {\n    throw new Error('fc.doubleNext constraints.' + constraintsLabel + ' must be a 32-bit float');\n  }\n\n  return doubleToIndex(d);\n}\n\nfunction unmapperDoubleToIndex(value) {\n  if (typeof value !== 'number') throw new Error('Unsupported type');\n  return doubleToIndex(value);\n}\n\nexport function doubleNext(constraints = {}) {\n  const _constraints$noDefaul = constraints.noDefaultInfinity,\n        noDefaultInfinity = _constraints$noDefaul === void 0 ? false : _constraints$noDefaul,\n        _constraints$noNaN = constraints.noNaN,\n        noNaN = _constraints$noNaN === void 0 ? false : _constraints$noNaN,\n        _constraints$min = constraints.min,\n        min = _constraints$min === void 0 ? noDefaultInfinity ? -Number.MAX_VALUE : Number.NEGATIVE_INFINITY : _constraints$min,\n        _constraints$max = constraints.max,\n        max = _constraints$max === void 0 ? noDefaultInfinity ? Number.MAX_VALUE : Number.POSITIVE_INFINITY : _constraints$max;\n  const minIndex = safeDoubleToIndex(min, 'min');\n  const maxIndex = safeDoubleToIndex(max, 'max');\n\n  if (isStrictlySmaller64(maxIndex, minIndex)) {\n    throw new Error('fc.doubleNext constraints.min must be smaller or equal to constraints.max');\n  }\n\n  if (noNaN) {\n    return convertFromNext(convertToNext(arrayInt64(minIndex, maxIndex)).map(indexToDouble, unmapperDoubleToIndex));\n  }\n\n  const positiveMaxIdx = isStrictlyPositive64(maxIndex);\n  const minIndexWithNaN = positiveMaxIdx ? minIndex : substract64(minIndex, Unit64);\n  const maxIndexWithNaN = positiveMaxIdx ? add64(maxIndex, Unit64) : maxIndex;\n  return convertFromNext(convertToNext(arrayInt64(minIndexWithNaN, maxIndexWithNaN)).map(index => {\n    if (isStrictlySmaller64(maxIndex, index) || isStrictlySmaller64(index, minIndex)) return Number.NaN;else return indexToDouble(index);\n  }, value => {\n    if (typeof value !== 'number') throw new Error('Unsupported type');\n    if (Number.isNaN(value)) return !isEqual64(maxIndex, maxIndexWithNaN) ? maxIndexWithNaN : minIndexWithNaN;\n    return doubleToIndex(value);\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}