{"ast":null,"code":"import { VerbosityLevel } from '../configuration/VerbosityLevel.js';\nimport { ExecutionStatus } from './ExecutionStatus.js';\nexport class RunExecution {\n  constructor(verbosity, interruptedAsFailure) {\n    this.verbosity = verbosity;\n    this.interruptedAsFailure = interruptedAsFailure;\n\n    this.isSuccess = () => this.pathToFailure == null;\n\n    this.firstFailure = () => this.pathToFailure ? +this.pathToFailure.split(':')[0] : -1;\n\n    this.numShrinks = () => this.pathToFailure ? this.pathToFailure.split(':').length - 1 : 0;\n\n    this.rootExecutionTrees = [];\n    this.currentLevelExecutionTrees = this.rootExecutionTrees;\n    this.failure = null;\n    this.numSkips = 0;\n    this.numSuccesses = 0;\n    this.interrupted = false;\n  }\n\n  appendExecutionTree(status, value) {\n    const currentTree = {\n      status,\n      value,\n      children: []\n    };\n    this.currentLevelExecutionTrees.push(currentTree);\n    return currentTree;\n  }\n\n  fail(value, id, message) {\n    if (this.verbosity >= VerbosityLevel.Verbose) {\n      const currentTree = this.appendExecutionTree(ExecutionStatus.Failure, value);\n      this.currentLevelExecutionTrees = currentTree.children;\n    }\n\n    if (this.pathToFailure == null) this.pathToFailure = \"\".concat(id);else this.pathToFailure += \":\".concat(id);\n    this.value = value;\n    this.failure = message;\n  }\n\n  skip(value) {\n    if (this.verbosity >= VerbosityLevel.VeryVerbose) {\n      this.appendExecutionTree(ExecutionStatus.Skipped, value);\n    }\n\n    if (this.pathToFailure == null) {\n      ++this.numSkips;\n    }\n  }\n\n  success(value) {\n    if (this.verbosity >= VerbosityLevel.VeryVerbose) {\n      this.appendExecutionTree(ExecutionStatus.Success, value);\n    }\n\n    if (this.pathToFailure == null) {\n      ++this.numSuccesses;\n    }\n  }\n\n  interrupt() {\n    this.interrupted = true;\n  }\n\n  extractFailures() {\n    if (this.isSuccess()) {\n      return [];\n    }\n\n    const failures = [];\n    let cursor = this.rootExecutionTrees;\n\n    while (cursor.length > 0 && cursor[cursor.length - 1].status === ExecutionStatus.Failure) {\n      const failureTree = cursor[cursor.length - 1];\n      failures.push(failureTree.value);\n      cursor = failureTree.children;\n    }\n\n    return failures;\n  }\n\n  toRunDetails(seed, basePath, maxSkips, qParams) {\n    if (!this.isSuccess()) {\n      return {\n        failed: true,\n        interrupted: this.interrupted,\n        numRuns: this.firstFailure() + 1 - this.numSkips,\n        numSkips: this.numSkips,\n        numShrinks: this.numShrinks(),\n        seed,\n        counterexample: this.value,\n        counterexamplePath: RunExecution.mergePaths(basePath, this.pathToFailure),\n        error: this.failure,\n        failures: this.extractFailures(),\n        executionSummary: this.rootExecutionTrees,\n        verbose: this.verbosity,\n        runConfiguration: qParams.toParameters()\n      };\n    }\n\n    const failed = this.numSkips > maxSkips || this.interrupted && this.interruptedAsFailure;\n    return {\n      failed,\n      interrupted: this.interrupted,\n      numRuns: this.numSuccesses,\n      numSkips: this.numSkips,\n      numShrinks: 0,\n      seed,\n      counterexample: null,\n      counterexamplePath: null,\n      error: null,\n      failures: [],\n      executionSummary: this.rootExecutionTrees,\n      verbose: this.verbosity,\n      runConfiguration: qParams.toParameters()\n    };\n  }\n\n}\n\nRunExecution.mergePaths = (offsetPath, path) => {\n  if (offsetPath.length === 0) return path;\n  const offsetItems = offsetPath.split(':');\n  const remainingItems = path.split(':');\n  const middle = +offsetItems[offsetItems.length - 1] + +remainingItems[0];\n  return [...offsetItems.slice(0, offsetItems.length - 1), \"\".concat(middle), ...remainingItems.slice(1)].join(':');\n};","map":null,"metadata":{},"sourceType":"module"}