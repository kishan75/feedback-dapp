{"ast":null,"code":"const debug = require(\"debug\")(\"contract:manual-send\");\n\nconst ethers = require(\"ethers\");\n\nconst Utils = require(\"./utils\");\n\nconst _require = require(\"web3-core-helpers\"),\n      formatters = _require.formatters; //used for reproducing web3's behavior\n//this is less manual now, it uses ethers, whew\n//(it's still more manual than using web3)\n\n\nasync function sendTransactionManual(web3, params, promiEvent) {\n  debug(\"executing manually!\"); //set up ethers provider\n\n  const ethersProvider = new ethers.providers.Web3Provider(web3.currentProvider); //let's clone params and set it up properly\n\n  const _setUpParameters = setUpParameters(params, web3),\n        transaction = _setUpParameters.transaction,\n        from = _setUpParameters.from; //now: if the from address is in the wallet, web3 will sign the transaction before\n  //sending, so we have to account for that\n\n\n  const account = web3.eth.accounts.wallet[from];\n  const ethersSigner = account ? new ethers.Wallet(account.privateKey, ethersProvider) : ethersProvider.getSigner(from);\n  debug(\"got signer\");\n  let txHash, receipt, ethersResponse;\n\n  try {\n    //note: the following code won't work with ethers v5.\n    //wth ethers v5, in the getSigner() case, you'll need to\n    //use sendUncheckedTransaction instead of sendTransaction.\n    //I don't know why.\n    ethersResponse = await ethersSigner.sendTransaction(transaction);\n    txHash = ethersResponse.hash;\n    receipt = await ethersProvider.waitForTransaction(txHash);\n    debug(\"no error\");\n  } catch (error) {\n    var _handleError = handleError(error);\n\n    txHash = _handleError.txHash;\n    receipt = _handleError.receipt;\n\n    if (!receipt) {\n      receipt = await ethersProvider.waitForTransaction(txHash);\n    }\n  }\n\n  debug(\"txHash: %s\", txHash);\n  receipt = translateReceipt(receipt);\n  promiEvent.setTransactionHash(txHash); //this here is why I wrote this function @_@\n\n  return await handleResult(receipt, transaction.to == null);\n}\n\nfunction handleError(error) {\n  debug(\"error: %O\", error);\n\n  if (error.data && error.data.hash) {\n    //ganache v7.x\n    return {\n      txHash: error.data.hash\n    };\n  } else if (error.data && Object.keys(error.data).length === 3) {\n    //ganache v2.x\n    //error.data will have 3 keys: stack, name, and the txHash\n    const transactionHash = Object.keys(error.data).find(key => key !== \"stack\" && key !== \"name\");\n    return {\n      txHash: transactionHash\n    };\n  } else if (error.transactionHash && error.receipt) {\n    return {\n      txHash: error.transactionHash,\n      receipt: error.receipt\n    };\n  } else {\n    throw error; //rethrow unexpected errors\n  }\n}\n\nasync function handleResult(receipt, isDeployment) {\n  const deploymentFailedMessage = \"The contract code couldn't be stored, please check your gas limit.\";\n\n  if (receipt.status) {\n    if (isDeployment) {\n      //in the deployment case, web3 might error even when technically successful @_@\n      if ((await web3.eth.getCode(receipt.contractAddress)) === \"0x\") {\n        throw new Error(deploymentFailedMessage);\n      }\n    }\n\n    return receipt;\n  } else {\n    //otherwise: we have to mimic web3's errors @_@\n    if (isDeployment) {\n      //deployment case\n      throw new Error(deploymentFailedMessage);\n    }\n\n    throw new Error(\"Transaction has been reverted by the EVM:\" + \"\\n\" + JSON.stringify(receipt));\n  }\n}\n\nfunction setUpParameters(params, web3) {\n  let transaction = Object.assign({}, params);\n  transaction.from = transaction.from != undefined ? transaction.from : web3.eth.defaultAccount; //now let's have web3 check our inputs\n\n  transaction = formatters.inputTransactionFormatter(transaction); //warning, not a pure fn\n  //...but ethers uses gasLimit instead of gas like web3\n\n  transaction.gasLimit = transaction.gas;\n  delete transaction.gas; //also, it insists \"from\" be kept separate\n\n  const _transaction = transaction,\n        from = _transaction.from;\n  delete transaction.from;\n  return {\n    transaction,\n    from\n  };\n} //translate the receipt to web3 format by converting BigNumbers\n//(note: these are *ethers* BigNumbers) to numbers\n\n\nfunction translateReceipt(receipt) {\n  return Object.assign({}, ...Object.entries(receipt).map(([key, value]) => ({\n    [key]: Utils.is_big_number(value) ? value.toNumber() : value\n  })));\n}\n\nmodule.exports = {\n  sendTransactionManual\n};","map":null,"metadata":{},"sourceType":"script"}