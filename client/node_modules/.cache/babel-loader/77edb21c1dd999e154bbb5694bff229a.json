{"ast":null,"code":"import { stringify, possiblyAsyncStringify } from '../../../utils/stringify.js';\nimport { VerbosityLevel } from '../configuration/VerbosityLevel.js';\nimport { ExecutionStatus } from '../reporter/ExecutionStatus.js';\n\nfunction formatHints(hints) {\n  if (hints.length === 1) {\n    return \"Hint: \".concat(hints[0]);\n  }\n\n  return hints.map((h, idx) => \"Hint (\".concat(idx + 1, \"): \").concat(h)).join('\\n');\n}\n\nfunction formatFailures(failures, stringifyOne) {\n  return \"Encountered failures were:\\n- \".concat(failures.map(stringifyOne).join('\\n- '));\n}\n\nfunction formatExecutionSummary(executionTrees, stringifyOne) {\n  const summaryLines = [];\n  const remainingTreesAndDepth = [];\n\n  for (const tree of executionTrees.slice().reverse()) {\n    remainingTreesAndDepth.push({\n      depth: 1,\n      tree\n    });\n  }\n\n  while (remainingTreesAndDepth.length !== 0) {\n    const currentTreeAndDepth = remainingTreesAndDepth.pop();\n    const currentTree = currentTreeAndDepth.tree;\n    const currentDepth = currentTreeAndDepth.depth;\n    const statusIcon = currentTree.status === ExecutionStatus.Success ? '\\x1b[32m\\u221A\\x1b[0m' : currentTree.status === ExecutionStatus.Failure ? '\\x1b[31m\\xD7\\x1b[0m' : '\\x1b[33m!\\x1b[0m';\n    const leftPadding = Array(currentDepth).join('. ');\n    summaryLines.push(\"\".concat(leftPadding).concat(statusIcon, \" \").concat(stringifyOne(currentTree.value)));\n\n    for (const tree of currentTree.children.slice().reverse()) {\n      remainingTreesAndDepth.push({\n        depth: currentDepth + 1,\n        tree\n      });\n    }\n  }\n\n  return \"Execution summary:\\n\".concat(summaryLines.join('\\n'));\n}\n\nfunction preFormatTooManySkipped(out, stringifyOne) {\n  const message = \"Failed to run property, too many pre-condition failures encountered\\n{ seed: \".concat(out.seed, \" }\\n\\nRan \").concat(out.numRuns, \" time(s)\\nSkipped \").concat(out.numSkips, \" time(s)\");\n  let details = null;\n  const hints = ['Try to reduce the number of rejected values by combining map, flatMap and built-in arbitraries', 'Increase failure tolerance by setting maxSkipsPerRun to an higher value'];\n\n  if (out.verbose >= VerbosityLevel.VeryVerbose) {\n    details = formatExecutionSummary(out.executionSummary, stringifyOne);\n  } else {\n    hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');\n  }\n\n  return {\n    message,\n    details,\n    hints\n  };\n}\n\nfunction preFormatFailure(out, stringifyOne) {\n  const message = \"Property failed after \".concat(out.numRuns, \" tests\\n{ seed: \").concat(out.seed, \", path: \\\"\").concat(out.counterexamplePath, \"\\\", endOnFailure: true }\\nCounterexample: \").concat(stringifyOne(out.counterexample), \"\\nShrunk \").concat(out.numShrinks, \" time(s)\\nGot error: \").concat(out.error);\n  let details = null;\n  const hints = [];\n\n  if (out.verbose >= VerbosityLevel.VeryVerbose) {\n    details = formatExecutionSummary(out.executionSummary, stringifyOne);\n  } else if (out.verbose === VerbosityLevel.Verbose) {\n    details = formatFailures(out.failures, stringifyOne);\n  } else {\n    hints.push('Enable verbose mode in order to have the list of all failing values encountered during the run');\n  }\n\n  return {\n    message,\n    details,\n    hints\n  };\n}\n\nfunction preFormatEarlyInterrupted(out, stringifyOne) {\n  const message = \"Property interrupted after \".concat(out.numRuns, \" tests\\n{ seed: \").concat(out.seed, \" }\");\n  let details = null;\n  const hints = [];\n\n  if (out.verbose >= VerbosityLevel.VeryVerbose) {\n    details = formatExecutionSummary(out.executionSummary, stringifyOne);\n  } else {\n    hints.push('Enable verbose mode at level VeryVerbose in order to check all generated values and their associated status');\n  }\n\n  return {\n    message,\n    details,\n    hints\n  };\n}\n\nfunction defaultReportMessageInternal(out, stringifyOne) {\n  if (!out.failed) return;\n\n  const _ref = out.counterexamplePath === null ? out.interrupted ? preFormatEarlyInterrupted(out, stringifyOne) : preFormatTooManySkipped(out, stringifyOne) : preFormatFailure(out, stringifyOne),\n        message = _ref.message,\n        details = _ref.details,\n        hints = _ref.hints;\n\n  let errorMessage = message;\n  if (details != null) errorMessage += \"\\n\\n\".concat(details);\n  if (hints.length > 0) errorMessage += \"\\n\\n\".concat(formatHints(hints));\n  return errorMessage;\n}\n\nfunction defaultReportMessage(out) {\n  return defaultReportMessageInternal(out, stringify);\n}\n\nasync function asyncDefaultReportMessage(out) {\n  const pendingStringifieds = [];\n\n  function stringifyOne(value) {\n    const stringified = possiblyAsyncStringify(value);\n\n    if (typeof stringified === 'string') {\n      return stringified;\n    }\n\n    pendingStringifieds.push(Promise.all([value, stringified]));\n    return '\\u2026';\n  }\n\n  const firstTryMessage = defaultReportMessageInternal(out, stringifyOne);\n\n  if (pendingStringifieds.length === 0) {\n    return firstTryMessage;\n  }\n\n  const registeredValues = new Map((await Promise.all(pendingStringifieds)));\n\n  function stringifySecond(value) {\n    const asyncStringifiedIfRegistered = registeredValues.get(value);\n\n    if (asyncStringifiedIfRegistered !== undefined) {\n      return asyncStringifiedIfRegistered;\n    }\n\n    return stringify(value);\n  }\n\n  return defaultReportMessageInternal(out, stringifySecond);\n}\n\nfunction throwIfFailed(out) {\n  if (!out.failed) return;\n  throw new Error(defaultReportMessage(out));\n}\n\nasync function asyncThrowIfFailed(out) {\n  if (!out.failed) return;\n  throw new Error((await asyncDefaultReportMessage(out)));\n}\n\nexport function reportRunDetails(out) {\n  if (out.runConfiguration.asyncReporter) return out.runConfiguration.asyncReporter(out);else if (out.runConfiguration.reporter) return out.runConfiguration.reporter(out);else return throwIfFailed(out);\n}\nexport async function asyncReportRunDetails(out) {\n  if (out.runConfiguration.asyncReporter) return out.runConfiguration.asyncReporter(out);else if (out.runConfiguration.reporter) return out.runConfiguration.reporter(out);else return asyncThrowIfFailed(out);\n}\nexport { defaultReportMessage, asyncDefaultReportMessage };","map":null,"metadata":{},"sourceType":"module"}