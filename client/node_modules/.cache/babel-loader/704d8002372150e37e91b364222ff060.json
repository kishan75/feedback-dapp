{"ast":null,"code":"import _slicedToArray from \"F:\\\\BlockChain\\\\Projects\\\\feedback-dapp\\\\client\\\\node_modules\\\\@babel\\\\runtime/helpers/esm/slicedToArray\";\nimport { Stream } from '../../../stream/Stream.js';\nimport { cloneMethod, hasCloneMethod } from '../../symbols.js';\nimport { NextValue } from './NextValue.js';\nexport class NextArbitrary {\n  filter(refinement) {\n    return new FilterArbitrary(this, refinement);\n  }\n\n  map(mapper, unmapper) {\n    return new MapArbitrary(this, mapper, unmapper);\n  }\n\n  chain(chainer) {\n    return new ChainArbitrary(this, chainer);\n  }\n\n  noShrink() {\n    return new NoShrinkArbitrary(this);\n  }\n\n  noBias() {\n    return new NoBiasArbitrary(this);\n  }\n\n}\n\nclass ChainArbitrary extends NextArbitrary {\n  constructor(arb, chainer) {\n    super();\n    this.arb = arb;\n    this.chainer = chainer;\n  }\n\n  generate(mrng, biasFactor) {\n    const clonedMrng = mrng.clone();\n    const src = this.arb.generate(mrng, biasFactor);\n    return this.valueChainer(src, mrng, clonedMrng, biasFactor);\n  }\n\n  canShrinkWithoutContext(value) {\n    return false;\n  }\n\n  shrink(value, context) {\n    if (this.isSafeContext(context)) {\n      return (!context.stoppedForOriginal ? this.arb.shrink(context.originalValue, context.originalContext).map(v => this.valueChainer(v, context.clonedMrng.clone(), context.clonedMrng, context.originalBias)) : Stream.nil()).join(context.chainedArbitrary.shrink(value, context.chainedContext).map(dst => {\n        const newContext = Object.assign(Object.assign({}, context), {\n          chainedContext: dst.context,\n          stoppedForOriginal: true\n        });\n        return new NextValue(dst.value_, newContext);\n      }));\n    }\n\n    return Stream.nil();\n  }\n\n  valueChainer(v, generateMrng, clonedMrng, biasFactor) {\n    const chainedArbitrary = this.chainer(v.value_);\n    const dst = chainedArbitrary.generate(generateMrng, biasFactor);\n    const context = {\n      originalBias: biasFactor,\n      originalValue: v.value_,\n      originalContext: v.context,\n      stoppedForOriginal: false,\n      chainedArbitrary,\n      chainedContext: dst.context,\n      clonedMrng\n    };\n    return new NextValue(dst.value_, context);\n  }\n\n  isSafeContext(context) {\n    return context != null && typeof context === 'object' && 'originalBias' in context && 'originalValue' in context && 'originalContext' in context && 'stoppedForOriginal' in context && 'chainedArbitrary' in context && 'chainedContext' in context && 'clonedMrng' in context;\n  }\n\n}\n\nclass MapArbitrary extends NextArbitrary {\n  constructor(arb, mapper, unmapper) {\n    super();\n    this.arb = arb;\n    this.mapper = mapper;\n    this.unmapper = unmapper;\n    this.bindValueMapper = this.valueMapper.bind(this);\n  }\n\n  generate(mrng, biasFactor) {\n    const g = this.arb.generate(mrng, biasFactor);\n    return this.valueMapper(g);\n  }\n\n  canShrinkWithoutContext(value) {\n    if (this.unmapper !== undefined) {\n      try {\n        const unmapped = this.unmapper(value);\n        return this.arb.canShrinkWithoutContext(unmapped);\n      } catch (_err) {\n        return false;\n      }\n    }\n\n    return false;\n  }\n\n  shrink(value, context) {\n    if (this.isSafeContext(context)) {\n      return this.arb.shrink(context.originalValue, context.originalContext).map(this.bindValueMapper);\n    }\n\n    if (this.unmapper !== undefined) {\n      const unmapped = this.unmapper(value);\n      return this.arb.shrink(unmapped, undefined).map(this.bindValueMapper);\n    }\n\n    return Stream.nil();\n  }\n\n  mapperWithCloneIfNeeded(v) {\n    const sourceValue = v.value;\n    const mappedValue = this.mapper(sourceValue);\n\n    if (v.hasToBeCloned && (typeof mappedValue === 'object' && mappedValue !== null || typeof mappedValue === 'function') && Object.isExtensible(mappedValue) && !hasCloneMethod(mappedValue)) {\n      Object.defineProperty(mappedValue, cloneMethod, {\n        get: () => () => this.mapperWithCloneIfNeeded(v)[0]\n      });\n    }\n\n    return [mappedValue, sourceValue];\n  }\n\n  valueMapper(v) {\n    const _this$mapperWithClone = this.mapperWithCloneIfNeeded(v),\n          _this$mapperWithClone2 = _slicedToArray(_this$mapperWithClone, 2),\n          mappedValue = _this$mapperWithClone2[0],\n          sourceValue = _this$mapperWithClone2[1];\n\n    const context = {\n      originalValue: sourceValue,\n      originalContext: v.context\n    };\n    return new NextValue(mappedValue, context);\n  }\n\n  isSafeContext(context) {\n    return context != null && typeof context === 'object' && 'originalValue' in context && 'originalContext' in context;\n  }\n\n}\n\nclass FilterArbitrary extends NextArbitrary {\n  constructor(arb, refinement) {\n    super();\n    this.arb = arb;\n    this.refinement = refinement;\n    this.bindRefinementOnValue = this.refinementOnValue.bind(this);\n  }\n\n  generate(mrng, biasFactor) {\n    while (true) {\n      const g = this.arb.generate(mrng, biasFactor);\n\n      if (this.refinementOnValue(g)) {\n        return g;\n      }\n    }\n  }\n\n  canShrinkWithoutContext(value) {\n    return this.arb.canShrinkWithoutContext(value) && this.refinement(value);\n  }\n\n  shrink(value, context) {\n    return this.arb.shrink(value, context).filter(this.bindRefinementOnValue);\n  }\n\n  refinementOnValue(v) {\n    return this.refinement(v.value);\n  }\n\n}\n\nclass NoShrinkArbitrary extends NextArbitrary {\n  constructor(arb) {\n    super();\n    this.arb = arb;\n  }\n\n  generate(mrng, biasFactor) {\n    return this.arb.generate(mrng, biasFactor);\n  }\n\n  canShrinkWithoutContext(value) {\n    return this.arb.canShrinkWithoutContext(value);\n  }\n\n  shrink(_value, _context) {\n    return Stream.nil();\n  }\n\n  noShrink() {\n    return this;\n  }\n\n}\n\nclass NoBiasArbitrary extends NextArbitrary {\n  constructor(arb) {\n    super();\n    this.arb = arb;\n  }\n\n  generate(mrng, _biasFactor) {\n    return this.arb.generate(mrng, undefined);\n  }\n\n  canShrinkWithoutContext(value) {\n    return this.arb.canShrinkWithoutContext(value);\n  }\n\n  shrink(value, context) {\n    return this.arb.shrink(value, context);\n  }\n\n  noBias() {\n    return this;\n  }\n\n}\n\nexport function assertIsNextArbitrary(instance) {\n  if (typeof instance !== 'object' || instance === null || !('generate' in instance) || !('shrink' in instance) || 'shrinkableFor' in instance) {\n    throw new Error('Unexpected value received: not an instance of NextArbitrary');\n  }\n}","map":null,"metadata":{},"sourceType":"module"}