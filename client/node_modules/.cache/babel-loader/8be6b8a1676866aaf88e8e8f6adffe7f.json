{"ast":null,"code":"import { convertFromNext, convertToNext } from '../check/arbitrary/definition/Converters.js';\nimport { set } from './set.js';\nimport { tuple } from './tuple.js';\nimport { restrictedIntegerArbitraryBuilder } from './_internals/builders/RestrictedIntegerArbitraryBuilder.js';\nimport { maxGeneratedLengthFromSizeForArbitrary, MaxLengthUpperBound } from './_internals/helpers/MaxLengthFromMinLength.js';\n\nfunction extractMaxIndex(indexesAndValues) {\n  let maxIndex = -1;\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    maxIndex = Math.max(maxIndex, indexesAndValues[index][0]);\n  }\n\n  return maxIndex;\n}\n\nfunction arrayFromItems(length, indexesAndValues) {\n  const array = Array(length);\n\n  for (let index = 0; index !== indexesAndValues.length; ++index) {\n    const it = indexesAndValues[index];\n    if (it[0] < length) array[it[0]] = it[1];\n  }\n\n  return array;\n}\n\nexport function sparseArray(arb, constraints = {}) {\n  const size = constraints.size,\n        _constraints$minNumEl = constraints.minNumElements,\n        minNumElements = _constraints$minNumEl === void 0 ? 0 : _constraints$minNumEl,\n        _constraints$maxLengt = constraints.maxLength,\n        maxLength = _constraints$maxLengt === void 0 ? MaxLengthUpperBound : _constraints$maxLengt,\n        _constraints$maxNumEl = constraints.maxNumElements,\n        maxNumElements = _constraints$maxNumEl === void 0 ? maxLength : _constraints$maxNumEl,\n        noTrailingHole = constraints.noTrailingHole;\n  const maxGeneratedNumElements = maxGeneratedLengthFromSizeForArbitrary(size, minNumElements, maxNumElements, constraints.maxNumElements !== undefined);\n  const maxGeneratedLength = maxGeneratedLengthFromSizeForArbitrary(size, maxGeneratedNumElements, maxLength, constraints.maxLength !== undefined);\n\n  if (minNumElements > maxLength) {\n    throw new Error(\"The minimal number of non-hole elements cannot be higher than the maximal length of the array\");\n  }\n\n  if (minNumElements > maxNumElements) {\n    throw new Error(\"The minimal number of non-hole elements cannot be higher than the maximal number of non-holes\");\n  }\n\n  const resultedMaxNumElements = Math.min(maxNumElements, maxLength);\n  const resultedSizeMaxNumElements = constraints.maxNumElements !== undefined || size !== undefined ? size : '=';\n  const maxGeneratedIndexAuthorized = Math.max(maxGeneratedLength - 1, 0);\n  const maxIndexAuthorized = Math.max(maxLength - 1, 0);\n  const sparseArrayNoTrailingHole = convertFromNext(convertToNext(set(tuple(restrictedIntegerArbitraryBuilder(0, maxGeneratedIndexAuthorized, maxIndexAuthorized), arb), {\n    size: resultedSizeMaxNumElements,\n    minLength: minNumElements,\n    maxLength: resultedMaxNumElements,\n    compare: {\n      selector: item => item[0]\n    }\n  })).map(items => {\n    const lastIndex = extractMaxIndex(items);\n    return arrayFromItems(lastIndex + 1, items);\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    if (noTrailingHole && value.length !== 0 && !(value.length - 1 in value)) {\n      throw new Error('No trailing hole');\n    }\n\n    return Object.entries(value).map(entry => [Number(entry[0]), entry[1]]);\n  }));\n\n  if (noTrailingHole || maxLength === minNumElements) {\n    return sparseArrayNoTrailingHole;\n  }\n\n  return convertFromNext(convertToNext(tuple(sparseArrayNoTrailingHole, restrictedIntegerArbitraryBuilder(minNumElements, maxGeneratedLength, maxLength))).map(data => {\n    const sparse = data[0];\n    const targetLength = data[1];\n\n    if (sparse.length >= targetLength) {\n      return sparse;\n    }\n\n    const longerSparse = sparse.slice();\n    longerSparse.length = targetLength;\n    return longerSparse;\n  }, value => {\n    if (!Array.isArray(value)) {\n      throw new Error('Not supported entry type');\n    }\n\n    return [value, value.length];\n  }));\n}","map":null,"metadata":{},"sourceType":"module"}