{"ast":null,"code":"\"use strict\";\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.formatFunctionLike = exports.ReturndataDecodingInspector = exports.LogDecodingInspector = exports.CalldataDecodingInspector = exports.nativizeEventArgs = exports.nativizeReturn = exports.nativize = exports.unsafeNativize = exports.ResultInspector = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:export\");\n\nconst os_1 = __importDefault(require(\"os\"));\n\nconst util_1 = __importDefault(require(\"util\"));\n\nconst Format = __importStar(require(\"./format\"));\n\nconst Conversion = __importStar(require(\"./conversion\"));\n\nconst inspect_1 = require(\"./format/utils/inspect\");\n\nObject.defineProperty(exports, \"ResultInspector\", {\n  enumerable: true,\n  get: function () {\n    return inspect_1.ResultInspector;\n  }\n});\nObject.defineProperty(exports, \"unsafeNativize\", {\n  enumerable: true,\n  get: function () {\n    return inspect_1.unsafeNativize;\n  }\n});\n/**\n * This function is similar to\n * [[Format.Utils.Inspect.unsafeNativize|unsafeNativize]], but is intended to\n * be safe, and also allows for different output formats.  The only currently\n * supported format is \"ethers\", which is intended to match the way that\n * Truffle Contract currently returns values (based on the Ethers decoder).  As\n * such, it only handles ABI types, and in addition does not handle the types\n * fixed, ufixed, or function.  Note that in these cases it returns `undefined`\n * rather than throwing, as we want this function to be used in contexts where\n * it had better not throw.  It also does not handle circularities, for similar\n * reasons.\n *\n * To handle numeric types, this function takes an optional numberFormatter\n * option that tells it how to handle numbers; this function should take a\n * BigInt as input.  By default, this function will be the identity, and so\n * numbers will be represented as BigInts.\n *\n * Note that this function begins by calling abify, so out-of-range enums (that\n * aren't so out-of-range as to be padding errors) will not return `undefined`.\n * Out-of-range booleans similarly will return true rather than `undefined`.\n * However, other range errors may return `undefined`; this may technically be a\n * slight incompatibility with existing behavior, but should not be relevant\n * except in quite unusual cases.\n *\n * In order to match the behavior for tuples, tuples will be transformed into\n * arrays, but named entries will additionally be keyed by name.  Moreover,\n * indexed variables of reference type will be nativized to an undecoded hex\n * string.\n */\n\nfunction nativize(result, options = {}) {\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativize(result, numberFormatter);\n  }\n}\n\nexports.nativize = nativize;\n\nfunction ethersCompatibleNativize(result, numberFormatter = x => x) {\n  //note: the original version of this function began by calling abify,\n  //but we don't do that here because abify requires a userDefinedTypes\n  //parameter and we don't want that.\n  //However, it only needs that to handle getting the types right.  Since\n  //we don't care about that here, we instead do away with abify and handle\n  //such matters ourselves (which is less convenient, yeah).\n  switch (result.kind) {\n    case \"error\":\n      switch (result.error.kind) {\n        case \"IndexedReferenceTypeError\":\n          //strictly speaking for arrays ethers will fail to decode\n          //rather than do this, but, eh\n          return result.error.raw;\n\n        case \"EnumOutOfRangeError\":\n          return numberFormatter(Conversion.toBigInt(result.error.rawAsBN));\n\n        default:\n          return undefined;\n      }\n\n    case \"value\":\n      switch (result.type.typeClass) {\n        case \"uint\":\n        case \"int\":\n          const asBN = result.value.asBN;\n          return numberFormatter(Conversion.toBigInt(asBN));\n\n        case \"enum\":\n          const numericAsBN = result.value.numericAsBN;\n          return numberFormatter(Conversion.toBigInt(numericAsBN));\n\n        case \"bool\":\n          return result.value.asBoolean;\n\n        case \"bytes\":\n          const asHex = result.value.asHex;\n          return asHex !== \"0x\" ? asHex : null;\n\n        case \"address\":\n          return result.value.asAddress;\n\n        case \"contract\":\n          return result.value.address;\n\n        case \"string\":\n          {\n            const coercedResult = result;\n\n            switch (coercedResult.value.kind) {\n              case \"valid\":\n                return coercedResult.value.asString;\n\n              case \"malformed\":\n                // this will turn malformed utf-8 into replacement characters (U+FFFD) (WARNING)\n                // note we need to cut off the 0x prefix\n                return Buffer.from(coercedResult.value.asHex.slice(2), \"hex\").toString();\n            }\n          }\n\n        case \"userDefinedValueType\":\n          return ethersCompatibleNativize(result.value, numberFormatter);\n\n        case \"array\":\n          return result.value.map(value => ethersCompatibleNativize(value, numberFormatter));\n\n        case \"tuple\":\n        case \"struct\":\n          //in this case, we need the result to be an array, but also\n          //to have the field names (where extant) as keys\n          const nativized = [];\n          const pairs = result.value;\n\n          for (const _ref of pairs) {\n            const name = _ref.name;\n            const value = _ref.value;\n            const nativizedValue = ethersCompatibleNativize(value, numberFormatter);\n            nativized.push(nativizedValue);\n\n            if (name) {\n              nativized[name] = nativizedValue;\n            }\n          }\n\n          return nativized;\n\n        case \"function\":\n          switch (result.type.visibility) {\n            case \"external\":\n              const coercedResult = result; //ethers per se doesn't handle this, but web3's hacked version will\n              //sometimes decode these as just a bytes24, so let's do that\n\n              return coercedResult.value.contract.address.toLowerCase() + coercedResult.value.selector.slice(2);\n\n            case \"internal\":\n              return undefined;\n          }\n\n        case \"fixed\":\n        case \"ufixed\":\n        default:\n          return undefined;\n      }\n\n  }\n}\n/**\n * This function is similar to [[nativize]], but takes\n * a [[ReturndataDecoding]].  If there's only one returned value, it\n * will be run through compatibleNativize but otherwise unaltered;\n * otherwise the results will be put in an object.\n *\n * Note that if the ReturndataDecoding is not a [[ReturnDecoding]],\n * this will just return `undefined`.\n */\n\n\nfunction nativizeReturn(decoding, options = {}) {\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativizeReturn(decoding, numberFormatter);\n  }\n}\n\nexports.nativizeReturn = nativizeReturn;\n\nfunction ethersCompatibleNativizeReturn(decoding, numberFormatter = x => x) {\n  if (decoding.kind !== \"return\") {\n    return undefined;\n  }\n\n  if (decoding.arguments.length === 1) {\n    return ethersCompatibleNativize(decoding.arguments[0].value, numberFormatter);\n  }\n\n  const result = {};\n\n  for (let i = 0; i < decoding.arguments.length; i++) {\n    const _decoding$arguments$i = decoding.arguments[i],\n          name = _decoding$arguments$i.name,\n          value = _decoding$arguments$i.value;\n    const nativized = ethersCompatibleNativize(value, numberFormatter);\n    result[i] = nativized;\n\n    if (name) {\n      result[name] = nativized;\n    }\n  }\n\n  return result;\n}\n/**\n * This function is similar to [[compatibleNativize]], but takes\n * a [[LogDecoding]], and puts the results in an object.  Note\n * that this does not return the entire event info, but just the\n * `args` for the event.\n */\n\n\nfunction nativizeEventArgs(decoding, options = {}) {\n  const numberFormatter = options.numberFormatter || (x => x);\n\n  const format = options.format || \"ethers\";\n\n  switch (format) {\n    case \"ethers\":\n      return ethersCompatibleNativizeEventArgs(decoding, numberFormatter);\n  }\n}\n\nexports.nativizeEventArgs = nativizeEventArgs;\n\nfunction ethersCompatibleNativizeEventArgs(decoding, numberFormatter = x => x) {\n  const result = {};\n\n  for (let i = 0; i < decoding.arguments.length; i++) {\n    const _decoding$arguments$i2 = decoding.arguments[i],\n          name = _decoding$arguments$i2.name,\n          value = _decoding$arguments$i2.value;\n    const nativized = ethersCompatibleNativize(value, numberFormatter);\n    result[i] = nativized;\n\n    if (name) {\n      result[name] = nativized;\n    }\n  } //note: if you have an argument named __length__, what ethers\n  //actually does is... weird.  we're just going to do this instead,\n  //which is simpler and probably more useful, even if it's not strictly\n  //the same (I *seriously* doubt anyone was relying on the old behavior,\n  //because it's, uh, not very useful)\n\n\n  result.__length__ = decoding.arguments.length;\n  return result;\n}\n/**\n * Similar to [[ResultInspector]], but for a [[CalldataDecoding]].\n * See [[ResultInspector]] for more information.\n */\n\n\nclass CalldataDecodingInspector {\n  constructor(decoding) {\n    this.decoding = decoding;\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.decoding.kind) {\n      case \"function\":\n        const fullName = \"\".concat(this.decoding.class.typeName, \".\").concat(this.decoding.abi.name);\n        return formatFunctionLike(fullName, this.decoding.arguments, options);\n\n      case \"constructor\":\n        return formatFunctionLike(\"new \".concat(this.decoding.class.typeName), this.decoding.arguments, options);\n\n      case \"message\":\n        const _this$decoding = this.decoding,\n              data = _this$decoding.data,\n              abi = _this$decoding.abi; //we'll set up a value and inspect that :)\n\n        const codecValue = {\n          kind: \"value\",\n          type: {\n            typeClass: \"bytes\",\n            kind: \"dynamic\"\n          },\n          value: {\n            asHex: data\n          }\n        };\n\n        if (abi) {\n          return formatFunctionLike(\"\".concat(this.decoding.class.typeName, \".\").concat(abi.type), [{\n            value: codecValue\n          }], options, true // we don't need to see the type here!\n          );\n        } else {\n          return \"Sent raw data to \".concat(this.decoding.class.typeName, \": \").concat(util_1.default.inspect(new inspect_1.ResultInspector(codecValue), options));\n        }\n\n      case \"unknown\":\n        return \"Receiving contract could not be identified.\";\n\n      case \"create\":\n        return \"Created contract could not be identified.\";\n    }\n  }\n\n}\n\nexports.CalldataDecodingInspector = CalldataDecodingInspector;\n/**\n * Similar to [[ResultInspector]], but for a [[LogDecoding]].\n * See [[ResultInspector]] for more information.\n */\n\nclass LogDecodingInspector {\n  constructor(decoding) {\n    this.decoding = decoding;\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    const className = this.decoding.definedIn ? this.decoding.definedIn.typeName : this.decoding.class.typeName;\n    const eventName = this.decoding.abi.name;\n    const fullName = \"\".concat(className, \".\").concat(eventName);\n\n    switch (this.decoding.kind) {\n      case \"event\":\n        return formatFunctionLike(fullName, this.decoding.arguments, options);\n\n      case \"anonymous\":\n        return formatFunctionLike(\"<anonymous> \".concat(fullName), this.decoding.arguments, options);\n    }\n  }\n\n}\n\nexports.LogDecodingInspector = LogDecodingInspector;\n/**\n * Similar to [[ResultInspector]], but for a [[ReturndataDecoding]].\n * See [[ResultInspector]] for more information.\n */\n\nclass ReturndataDecodingInspector {\n  constructor(decoding) {\n    this.decoding = decoding;\n  }\n\n  [util_1.default.inspect.custom](depth, options) {\n    switch (this.decoding.kind) {\n      case \"return\":\n        return formatFunctionLike(\"Returned values: \", this.decoding.arguments, options);\n\n      case \"returnmessage\":\n        const data = this.decoding.data; //we'll just set up a value and inspect that :)\n\n        const codecValue = {\n          kind: \"value\",\n          type: {\n            typeClass: \"bytes\",\n            kind: \"dynamic\"\n          },\n          value: {\n            asHex: data\n          }\n        };\n        const dataString = util_1.default.inspect(new inspect_1.ResultInspector(codecValue), options);\n        return \"Returned raw data: \".concat(dataString);\n\n      case \"selfdestruct\":\n        return \"The contract self-destructed.\";\n\n      case \"failure\":\n        return \"The transaction reverted without a message.\";\n\n      case \"revert\":\n        const name = this.decoding.definedIn ? \"\".concat(this.decoding.definedIn.typeName, \".\").concat(this.decoding.abi.name) : this.decoding.abi.name;\n        return formatFunctionLike(\"Error thrown:\".concat(os_1.default.EOL).concat(name), this.decoding.arguments, options);\n\n      case \"bytecode\":\n        //this one gets custom handling :P\n        const contractKind = this.decoding.class.contractKind || \"contract\";\n        const firstLine = this.decoding.address !== undefined ? \"Returned bytecode for a \".concat(contractKind, \" \").concat(this.decoding.class.typeName, \" at \").concat(this.decoding.address, \".\") : \"Returned bytecode for a \".concat(contractKind, \" \").concat(this.decoding.class.typeName, \".\");\n\n        if (this.decoding.immutables && this.decoding.immutables.length > 0) {\n          const prefixes = this.decoding.immutables.map(({\n            name,\n            class: {\n              typeName\n            }\n          }) => \"\".concat(typeName, \".\").concat(name, \": \"));\n          const maxLength = Math.max(...prefixes.map(prefix => prefix.length));\n          const paddedPrefixes = prefixes.map(prefix => prefix.padStart(maxLength));\n          const formattedValues = this.decoding.immutables.map((value, index) => {\n            const prefix = paddedPrefixes[index];\n            const formatted = indentExcludingFirstLine(util_1.default.inspect(new inspect_1.ResultInspector(value.value), options), maxLength);\n            return prefix + formatted;\n          });\n          return \"Immutable values:\".concat(os_1.default.EOL).concat(formattedValues.join(os_1.default.EOL));\n        } else {\n          return firstLine;\n        }\n\n      case \"unknownbytecode\":\n        return \"Bytecode was returned, but it could not be identified.\";\n    }\n  }\n\n}\n\nexports.ReturndataDecodingInspector = ReturndataDecodingInspector; //copied from TestRunner, but simplified for our purposes :)\n\nfunction indentArray(input, indentation) {\n  return input.map(line => \" \".repeat(indentation) + line);\n} //copied from TestRunner, but simplified for our purposes :)\n\n\nfunction indentExcludingFirstLine(input, indentation) {\n  const lines = input.split(/\\r?\\n/);\n  return [lines[0], ...indentArray(lines.slice(1), indentation)].join(os_1.default.EOL);\n} //used for formatting things that look like function calls:\n//events (including anonymous events), identifiable transactions,\n//and revert messages\n//\"header\" param should include everything before the initial parenthesis\n\n/**\n * @hidden\n */\n\n\nfunction formatFunctionLike(header, values, options, suppressType = false, indent = 2 //for use by debug-utils\n) {\n  if (values.length === 0) {\n    return \"\".concat(header, \"()\");\n  }\n\n  let formattedValues = values.map(({\n    name,\n    indexed,\n    value\n  }, index) => {\n    const namePrefix = name ? \"\".concat(name, \": \") : \"\";\n    const indexedPrefix = indexed ? \"<indexed> \" : \"\";\n    const prefix = namePrefix + indexedPrefix;\n    const displayValue = util_1.default.inspect(new inspect_1.ResultInspector(value), options);\n    const typeString = suppressType ? \"\" : \" (type: \".concat(Format.Types.typeStringWithoutLocation(value.type), \")\");\n    return indentExcludingFirstLine(prefix + displayValue + typeString + (index < values.length - 1 ? \",\" : \"\"), 2 * indent);\n  });\n  return \"\".concat(header, \"(\").concat(os_1.default.EOL).concat(indentArray(formattedValues, indent).join(os_1.default.EOL)).concat(os_1.default.EOL, \")\");\n}\n\nexports.formatFunctionLike = formatFunctionLike;","map":null,"metadata":{},"sourceType":"script"}