{"ast":null,"code":"\"use strict\";\n/**\n * @protected\n *\n * @packageDocumentation\n */\n\nvar __createBinding = this && this.__createBinding || (Object.create ? function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  Object.defineProperty(o, k2, {\n    enumerable: true,\n    get: function () {\n      return m[k];\n    }\n  });\n} : function (o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nvar __setModuleDefault = this && this.__setModuleDefault || (Object.create ? function (o, v) {\n  Object.defineProperty(o, \"default\", {\n    enumerable: true,\n    value: v\n  });\n} : function (o, v) {\n  o[\"default\"] = v;\n});\n\nvar __importStar = this && this.__importStar || function (mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n\n  __setModuleDefault(result, mod);\n\n  return result;\n};\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readStorage = exports.readSlot = void 0;\n\nconst debug_1 = __importDefault(require(\"debug\"));\n\nconst debug = debug_1.default(\"codec:storage:read\");\n\nconst Conversion = __importStar(require(\"../../conversion\"));\n\nconst Utils = __importStar(require(\"../utils\"));\n\nconst Evm = __importStar(require(\"../../evm\"));\n\nconst errors_1 = require(\"../../errors\");\n\nfunction* readSlot(storage, slot) {\n  const address = Utils.slotAddress(slot); // debug(\"reading slot: %o\", Conversion.toHexString(address));\n\n  const hexAddress = Conversion.toHexString(address, Evm.Utils.WORD_SIZE);\n  let word = storage[hexAddress]; //if we can't find the word in the map, we place a request to the invoker to supply it\n  //(contract-decoder will look it up from the blockchain, while the debugger will just\n  //say 0)\n\n  if (word === undefined) {\n    word = yield {\n      type: \"storage\",\n      slot: address\n    };\n  }\n\n  return word;\n}\n\nexports.readSlot = readSlot;\n\nfunction* readStorage(pointer, state) {\n  const storage = state.storage;\n  const range = pointer.range;\n  debug(\"readRange %o\", range);\n  let from = range.from,\n      to = range.to,\n      length = range.length;\n  from = {\n    slot: from.slot,\n    index: from.index || 0\n  };\n\n  if (length !== undefined) {\n    to = {\n      slot: {\n        path: from.slot.path || undefined,\n        offset: from.slot.offset.addn(Math.floor((from.index + length - 1) / Evm.Utils.WORD_SIZE))\n      },\n      index: (from.index + length - 1) % Evm.Utils.WORD_SIZE\n    };\n  }\n\n  debug(\"normalized readRange %o\", {\n    from,\n    to\n  });\n  let totalWordsAsBN = to.slot.offset.sub(from.slot.offset).addn(1);\n  let totalWords;\n\n  try {\n    totalWords = totalWordsAsBN.toNumber();\n  } catch (_) {\n    throw new errors_1.DecodingError({\n      kind: \"ReadErrorStorage\",\n      range\n    });\n  }\n\n  let data = new Uint8Array(totalWords * Evm.Utils.WORD_SIZE);\n\n  for (let i = 0; i < totalWords; i++) {\n    let offset = from.slot.offset.addn(i);\n    const word = yield* readSlot(storage, Object.assign(Object.assign({}, from.slot), {\n      offset\n    }));\n\n    if (typeof word !== \"undefined\") {\n      data.set(word, i * Evm.Utils.WORD_SIZE);\n    }\n  }\n\n  debug(\"words %o\", data);\n  data = data.slice(from.index, (totalWords - 1) * Evm.Utils.WORD_SIZE + to.index + 1);\n  debug(\"data: %o\", data);\n  return data;\n}\n\nexports.readStorage = readStorage;","map":null,"metadata":{},"sourceType":"script"}