{"ast":null,"code":"const OS = require(\"os\");\n\nconst debug = require(\"debug\")(\"debug-utils\");\n\nconst util = require(\"util\");\n\nconst Codec = require(\"@truffle/codec\");\n\nconst BN = require(\"bn.js\");\n\nconst chromafi = require(\"@trufflesuite/chromafi\");\n\nconst hljsDefineSolidity = require(\"highlightjs-solidity\");\n\nhljsDefineSolidity(chromafi.hljs);\n\nconst chalk = require(\"chalk\");\n\nconst panicTable = {\n  0x01: \"Failed assertion\",\n  0x11: \"Arithmetic overflow\",\n  0x12: \"Division by zero\",\n  0x21: \"Enum value out of bounds\",\n  0x22: \"Malformed string\",\n  0x31: \"Array underflow\",\n  0x32: \"Index out of bounds\",\n  0x41: \"Oversized array or out of memory\",\n  0x51: \"Call to invalid function\"\n};\nconst verbosePanicTable = {\n  0x01: \"An assert() check was not satisfied.\",\n  0x11: \"An arithmetic overflow occurred outside an unchecked { ... } block.\",\n  0x12: \"A division by zero occurred.\",\n  0x21: \"An integer was cast to an enum type that cannot hold it.\",\n  0x22: \"There was an attempt to read an incorrectly-encoded string or bytestring.\",\n  0x31: \"An empty array's pop() method was called.\",\n  0x32: \"An array or bytestring was indexed or sliced with an out-of-bounds index.\",\n  0x41: \"An oversized array was created, or the contract ran out of memory.\",\n  0x51: \"An uninitialized internal function pointer was called.\"\n};\nconst commandReference = {\n  o: \"step over\",\n  i: \"step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction (include number to step multiple)\",\n  p: \"print instruction & state (`p [mem|cal|sto]*`; see docs for more)\",\n  l: \"print additional source context (`l [+<lines-ahead>] [-<lines-back>]`)\",\n  h: \"print this help\",\n  v: \"print variables and values (`v [bui|glo|con|loc]*`)\",\n  \":\": \"evaluate expression - see `v`\",\n  \"+\": \"add watch expression (`+:<expr>`)\",\n  \"-\": \"remove watch expression (-:<expr>)\",\n  \"?\": \"list existing watch expressions and breakpoints\",\n  b: \"add breakpoint (`b [[<source-file>:]<line-number>]`; see docs for more)\",\n  B: \"remove breakpoint (similar to adding, or `B all` to remove all)\",\n  c: \"continue until breakpoint\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load new transaction\",\n  T: \"unload transaction\",\n  s: \"print stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources except via `;`\",\n  y: \"(if at end) reset & continue to final error\",\n  Y: \"reset & continue to previous error\"\n};\nconst shortCommandReference = {\n  o: \"step over\",\n  i: \"step into\",\n  u: \"step out\",\n  n: \"step next\",\n  \";\": \"step instruction\",\n  p: \"print state\",\n  l: \"print context\",\n  h: \"print help\",\n  v: \"print variables\",\n  \":\": \"evaluate\",\n  \"+\": \"add watch\",\n  \"-\": \"remove watch\",\n  \"?\": \"list watches & breakpoints\",\n  b: \"add breakpoint\",\n  B: \"remove breakpoint\",\n  c: \"continue\",\n  q: \"quit\",\n  r: \"reset\",\n  t: \"load\",\n  T: \"unload\",\n  s: \"stacktrace\",\n  g: \"turn on generated sources\",\n  G: \"turn off generated sources\",\n  y: \"reset & go to final error\",\n  Y: \"reset & go to previous error\"\n};\nconst truffleColors = {\n  mint: chalk.hex(\"#3FE0C5\"),\n  orange: chalk.hex(\"#E4A663\"),\n  pink: chalk.hex(\"#E911BD\"),\n  purple: chalk.hex(\"#8731E8\"),\n  green: chalk.hex(\"#00D717\"),\n  red: chalk.hex(\"#D60000\"),\n  yellow: chalk.hex(\"#F2E941\"),\n  blue: chalk.hex(\"#25A9E0\"),\n  comment: chalk.hsl(30, 20, 50),\n  watermelon: chalk.hex(\"#E86591\"),\n  periwinkle: chalk.hex(\"#7F9DD1\")\n};\nconst DEFAULT_TAB_WIDTH = 8;\nconst trufflePalette = {\n  /* base (chromafi special, not hljs) */\n  base: chalk,\n  lineNumbers: chalk,\n  trailingSpace: chalk,\n\n  /* classes hljs-solidity actually uses */\n  keyword: truffleColors.mint,\n  number: truffleColors.red,\n  string: truffleColors.green,\n  params: truffleColors.pink,\n  builtIn: truffleColors.watermelon,\n  built_in: truffleColors.watermelon,\n  //just to be sure\n  literal: truffleColors.watermelon,\n  function: truffleColors.orange,\n  title: truffleColors.orange,\n  class: truffleColors.orange,\n  comment: truffleColors.comment,\n  doctag: truffleColors.comment,\n  operator: truffleColors.blue,\n  punctuation: truffleColors.purple,\n\n  /* classes it might soon use! */\n  meta: truffleColors.pink,\n  metaString: truffleColors.green,\n  \"meta-string\": truffleColors.green,\n  //similar\n\n  /* classes it doesn't currently use but notionally could */\n  type: truffleColors.orange,\n  symbol: truffleColors.orange,\n  metaKeyword: truffleColors.mint,\n  \"meta-keyword\": truffleColors.mint,\n  //again, to be sure\n  property: chalk,\n  //not putting any highlighting here for now\n\n  /* classes that don't make sense for Solidity */\n  regexp: chalk,\n  //solidity does not have regexps\n  subst: chalk,\n  //or string interpolation\n  name: chalk,\n  //or s-expressions\n  builtInName: chalk,\n  //or s-expressions, again\n  \"builtin-name\": chalk,\n  //just to be sure\n\n  /* classes for config, markup, CSS, templates, diffs (not programming) */\n  section: chalk,\n  tag: chalk,\n  attr: chalk,\n  attribute: chalk,\n  variable: chalk,\n  bullet: chalk,\n  code: chalk,\n  emphasis: chalk,\n  strong: chalk,\n  formula: chalk,\n  link: chalk,\n  quote: chalk,\n  selectorAttr: chalk,\n  //lotta redundancy follows\n  \"selector-attr\": chalk,\n  selectorClass: chalk,\n  \"selector-class\": chalk,\n  selectorId: chalk,\n  \"selector-id\": chalk,\n  selectorPseudo: chalk,\n  \"selector-pseudo\": chalk,\n  selectorTag: chalk,\n  \"selector-tag\": chalk,\n  templateTag: chalk,\n  \"template-tag\": chalk,\n  templateVariable: chalk,\n  \"template-variable\": chalk,\n  addition: chalk,\n  deletion: chalk\n};\nvar DebugUtils = {\n  truffleColors,\n  //make these externally available\n  //panicCode may be either a number, BN, or decimal string\n  panicString: function (panicCode, verbose = false) {\n    const unknownString = \"Unknown panic\";\n    const verboseUnknownString = \"A panic occurred of unrecognized type.\";\n\n    if (BN.isBN(panicCode)) {\n      try {\n        panicCode = panicCode.toNumber();\n      } catch (_) {\n        return verbose ? verboseUnknownString : unknownString;\n      }\n    }\n\n    return verbose ? verbosePanicTable[panicCode] || verboseUnknownString : panicTable[panicCode] || unknownString;\n  },\n  //attempts to test whether a given compilation is a real compilation,\n  //i.e., was compiled all at once.\n  //if it is real, it will definitely pass this test, barring a Solidity bug.\n  //(anyway worst case failing it just results in a recompilation)\n  //if it isn't real, but passes this test anyway... well, I'm hoping it should\n  //still be usable all the same!\n  isUsableCompilation: function (compilation) {\n    //check #1: is the source order reliable?\n    if (compilation.unreliableSourceOrder) {\n      debug(\"unreliable source order\");\n      return false;\n    } //check #2: are (user) source indices consecutive?\n    //(while nonconsecutivity should not be a problem by itself, this probably\n    //indicates a name collision of a sort that will be fatal for other\n    //reasons)\n    //NOTE: oddly, empty spots in an array will cause array.includes(undefined)\n    //to return true!  So I'm doing it this way even though it looks wrong\n    //(since the real concern is empty spots, not undefined, yet this turns\n    //this up anyhow)\n\n\n    if (compilation.sources.includes(undefined)) {\n      debug(\"nonconsecutive sources\");\n      return false;\n    }\n\n    const lowestInternalIndex = Math.min(...compilation.contracts.map(contract => {\n      //find first defined index\n      let lowestConstructor = (contract.generatedSources || []).findIndex(x => x !== undefined);\n\n      if (lowestConstructor === -1) {\n        lowestConstructor = Infinity;\n      }\n\n      let lowestDeployed = (contract.deployedGeneratedSources || []).findIndex(x => x !== undefined);\n\n      if (lowestDeployed === -1) {\n        lowestDeployed = Infinity;\n      }\n\n      return Math.min(lowestConstructor, lowestDeployed);\n    }));\n\n    if (lowestInternalIndex !== Infinity) {\n      //Infinity would mean there were none\n      if (lowestInternalIndex !== compilation.sources.length) {\n        //if it's a usable compilation, these should be equal,\n        //as length = 1 + last user source\n        debug(\"gap before internal sources\");\n        return false;\n      }\n    } //check #4: are there any AST ID collisions?\n\n\n    let astIds = new Set();\n\n    let allIDsUnseenSoFar = node => {\n      if (Array.isArray(node)) {\n        return node.every(allIDsUnseenSoFar);\n      } else if (node !== null && typeof node === \"object\") {\n        if (node.id !== undefined) {\n          if (astIds.has(node.id)) {\n            debug(\"id occured twice: %o\", node.id);\n            return false;\n          } else {\n            astIds.add(node.id);\n          }\n        }\n\n        return Object.values(node).every(allIDsUnseenSoFar);\n      } else {\n        return true;\n      }\n    }; //now: walk each Solidity AST\n    //(and don't bother checking generated sources as they're\n    //never Solidity)\n\n\n    debug(\"checking Solidity ASTs for collisions\");\n    return compilation.sources.every(source => !source || source.language !== \"Solidity\" || allIDsUnseenSoFar(source.ast));\n  },\n  formatStartMessage: function (withTransaction) {\n    if (withTransaction) {\n      return \"Gathering information about your project and the transaction...\";\n    } else {\n      return \"Gathering information about your project...\";\n    }\n  },\n  formatTransactionStartMessage: function () {\n    return \"Gathering information about the transaction...\";\n  },\n  formatCommandDescription: function (commandId) {\n    return truffleColors.mint(\"(\".concat(commandId, \")\")) + \" \" + commandReference[commandId];\n  },\n  formatPrompt: function (network, txHash) {\n    return txHash !== undefined ? \"debug(\".concat(network, \":\").concat(txHash.substring(0, 10), \"...)> \") : \"debug(\".concat(network, \")> \");\n  },\n  formatAffectedInstances: function (instances) {\n    var hasAllSource = true;\n    var lines = Object.keys(instances).map(function (address) {\n      var instance = instances[address];\n\n      if (instance.contractName) {\n        return \" \" + address + \" - \" + instance.contractName;\n      }\n\n      if (!instance.source) {\n        hasAllSource = false;\n      }\n\n      return \" \" + address + \"(UNKNOWN)\";\n    });\n\n    if (lines.length === 0) {\n      lines.push(\"No affected addresses found.\");\n    }\n\n    if (!hasAllSource) {\n      lines.push(\"\");\n      lines.push(\"\".concat(chalk.bold(\"Warning:\"), \" The source code for one or more contracts could not be found.\"));\n    }\n\n    return lines.join(OS.EOL);\n  },\n  formatHelp: function (lastCommand = \"n\") {\n    var prefix = [\"Commands:\", truffleColors.mint(\"(enter)\") + \" last command entered (\" + shortCommandReference[lastCommand] + \")\"];\n    var commandSections = [[\"o\", \"i\", \"u\", \"n\"], [\"c\", \"Y\"], [\"y\"], [\";\"], [\"g\", \"G\"], [\"p\"], [\"l\"], [\"s\", \"h\"], [\"q\", \"r\", \"t\", \"T\"], [\"b\"], [\"B\"], [\"+\", \"-\"], [\"?\"], [\"v\"], [\":\"]].map(function (shortcuts) {\n      return shortcuts.map(DebugUtils.formatCommandDescription).join(\", \");\n    });\n    var suffix = [\"\"];\n    var lines = prefix.concat(commandSections).concat(suffix);\n    return lines.join(OS.EOL);\n  },\n  tabsToSpaces: function (inputLine, tabLength = DEFAULT_TAB_WIDTH) {\n    //note: I'm going to assume for these purposes that everything is\n    //basically ASCII and I don't have to worry about astral planes or\n    //grapheme clusters.  Sorry. :-/\n    let line = \"\";\n    let counter = 0;\n\n    for (let i = 0; i < inputLine.length; i++) {\n      if (inputLine[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        line += \" \".repeat(remaining);\n        counter = 0;\n      } else if (inputLine[i] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n      } else if (inputLine[i] === \"\\r\" && inputLine[i + 1] === \"\\n\") {\n        line += \"\\n\";\n        counter = 0;\n        i++;\n      } else {\n        line += inputLine[i];\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n    }\n\n    return line;\n  },\n  formatLineNumberPrefix: function (line, number, cols) {\n    const prefix = String(number).padStart(cols) + \": \";\n    return prefix + line;\n  },\n  formatLinePointer: function (line, startCol, endCol, padding, tabLength = DEFAULT_TAB_WIDTH) {\n    const prefix = \" \".repeat(padding + 2); //account for \": \"\n\n    let output = \"\";\n    let counter = 0;\n\n    for (let i = 0; i < line.length; i++) {\n      let pointedAt = i >= startCol && i < endCol;\n      let additional;\n\n      if (line[i] === \"\\t\") {\n        const remaining = tabLength - counter;\n        additional = \" \".repeat(remaining);\n        debug(\"advancing %d\", remaining);\n        counter = 0;\n      } else {\n        additional = \" \"; // just a space\n\n        counter++;\n\n        if (counter === tabLength) {\n          counter = 0;\n        }\n      }\n\n      if (pointedAt) {\n        additional = additional.replace(/./g, \"^\");\n      }\n\n      output += additional;\n    }\n\n    return truffleColors.purple(prefix + output);\n  },\n  //NOTE: source and uncolorizedSource here have already\n  //been split into lines here, they're not the raw text\n  //ALSO: assuming here that colorized source has been detabbed\n  //but that uncolorized source has not\n  formatRangeLines: function (source, range, uncolorizedSource, contextBefore = 2, contextAfter = 0) {\n    // range is {\n    //   start: { line, column },\n    //   end: { line, column}\n    // }\n    //\n    var startIndex = Math.max(range.start.line - contextBefore, 0);\n    var endIndex = Math.min(range.start.line + contextAfter, source.length - 1);\n    var prefixLength = (endIndex + 1 + \"\").length; //+1 to account for 0-index\n    //note: beforeLines now includes the line itself\n\n    var beforeLines = source.slice(startIndex, range.start.line + 1).map((line, index) => {\n      let number = startIndex + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var afterLines = source.slice(range.start.line + 1, endIndex + 1).map((line, index) => {\n      let number = range.start.line + 1 + index + 1; // 1 to account for 0-index\n\n      return DebugUtils.formatLineNumberPrefix(line, number, prefixLength);\n    });\n    var pointerStart = range.start.column;\n    var pointerEnd;\n    let uncolorizedLine = uncolorizedSource[range.start.line]; // range.end is undefined in some cases\n    // null/undefined check to avoid exceptions\n\n    if (range.end && range.start.line === range.end.line) {\n      // start and end are same line: pointer ends at column\n      pointerEnd = range.end.column;\n    } else {\n      pointerEnd = uncolorizedLine.length;\n    }\n\n    var allLines = beforeLines.concat([DebugUtils.formatLinePointer( //the line-pointer formatter doesn't work right with colorized\n    //lines, so we pass in the uncolored version\n    uncolorizedLine, pointerStart, pointerEnd, prefixLength)], afterLines);\n    return allLines.join(OS.EOL);\n  },\n  formatBreakpointLocation: function (breakpoint, here, currentSourceId, sourceNames) {\n    let baseMessage;\n\n    if (breakpoint.start !== undefined && breakpoint.length !== undefined) {\n      baseMessage = here ? \"this point in line \".concat(breakpoint.line + 1) : \"a point in line \".concat(breakpoint.line + 1); //note we always add 1 to adjust for zero-indexing\n    } else {\n      baseMessage = \"line \".concat(breakpoint.line + 1);\n    }\n\n    if (breakpoint.sourceId !== currentSourceId) {\n      const sourceName = sourceNames[breakpoint.sourceId];\n      return baseMessage + \" in \".concat(sourceName);\n    } else {\n      return baseMessage;\n    }\n  },\n  formatCurrentInstruction: function (instruction) {\n    const pc = this.formatPC(instruction.pc);\n    const formattedInstruction = this.formatInstruction(instruction);\n    return \"-> \" + truffleColors.mint(formattedInstruction) + pc;\n  },\n  formatInstruction: function (instruction) {\n    return truffleColors.mint(instruction.name + \" \" + (instruction.pushData || \"\"));\n  },\n  formatPC: function (pc) {\n    let hex = pc.toString(16);\n\n    if (hex.length % 2 !== 0) {\n      hex = \"0\" + hex; //ensure even length\n    }\n\n    return \" (PC=\" + pc.toString() + \", 0x\" + hex + \")\";\n  },\n  formatStack: function (stack) {\n    //stack here is an array of hex words (no \"0x\")\n    var formatted = stack.map((item, index) => {\n      item = truffleColors.orange(item);\n      item = \"  \" + item;\n\n      if (index === stack.length - 1) {\n        item += \" (top)\";\n      } else {\n        item += \" (\".concat(stack.length - index - 1, \" from top)\");\n      }\n\n      return item;\n    });\n\n    if (stack.length === 0) {\n      formatted.unshift(\"  No data on stack.\");\n    } else {\n      formatted.unshift(\"Stack:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatMemory: function (memory) {\n    //note memory here is an array of hex words (no \"0x\"),\n    //not a single long hex string\n    //get longest prefix needed;\n    //minimum of 2 so always show at least 2 hex digits\n    let maxPrefixLength = Math.max(2, ((memory.length - 1) * Codec.Evm.Utils.WORD_SIZE).toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++; //make sure to use even # of hex digits\n    }\n\n    let formatted = memory.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      return \"  0x\".concat(address, \":  \").concat(truffleColors.pink(word));\n    });\n\n    if (memory.length === 0) {\n      formatted.unshift(\"  No data in memory.\");\n    } else {\n      formatted.unshift(\"Memory:\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatStorage: function (storage) {\n    //storage here is an object mapping hex words to hex words (no 0x)\n    //first: sort the keys (slice to clone as sort is in-place)\n    //note: we can use the default sort here; it will do the righ thing\n    let slots = Object.keys(storage).slice().sort();\n    let formatted = slots.map((slot, index) => {\n      if (index === 0 || !Codec.Conversion.toBN(slot).eq(Codec.Conversion.toBN(slots[index - 1]).addn(1))) {\n        return \"0x\".concat(slot, \":\\n\") + \"  \".concat(truffleColors.blue(storage[slot]));\n      } else {\n        return \"  \".concat(truffleColors.blue(storage[slot]));\n      }\n    });\n\n    if (slots.length === 0) {\n      formatted.unshift(\"  No known relevant data found in storage.\");\n    } else {\n      formatted.unshift(\"Storage (partial view):\");\n    }\n\n    return formatted.join(OS.EOL);\n  },\n  formatCalldata: function (calldata) {\n    //takes a Uint8Array\n    let selector = calldata.slice(0, Codec.Evm.Utils.SELECTOR_SIZE);\n    let words = [];\n\n    for (let wordIndex = Codec.Evm.Utils.SELECTOR_SIZE; wordIndex < calldata.length; wordIndex += Codec.Evm.Utils.WORD_SIZE) {\n      words.push(calldata.slice(wordIndex, wordIndex + Codec.Evm.Utils.WORD_SIZE));\n    }\n\n    let maxWordIndex = (words.length - 1) * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE;\n    let maxPrefixLength = Math.max(2, maxWordIndex.toString(16).length);\n\n    if (maxPrefixLength % 2 !== 0) {\n      maxPrefixLength++;\n    }\n\n    let formattedSelector;\n\n    if (selector.length > 0) {\n      formattedSelector = \"Calldata:\\n\" + \"  0x\".concat(\"00\".padStart(maxPrefixLength, \"0\"), \":  \") + truffleColors.pink(Codec.Conversion.toHexString(selector).slice(2).padStart(2 * Codec.Evm.Utils.WORD_SIZE, \"  \"));\n    } else {\n      formattedSelector = \"  No data in calldata.\";\n    }\n\n    let formatted = words.map((word, index) => {\n      let address = (index * Codec.Evm.Utils.WORD_SIZE + Codec.Evm.Utils.SELECTOR_SIZE).toString(16).padStart(maxPrefixLength, \"0\");\n      let data = Codec.Conversion.toHexString(word).slice(2).padEnd(2 * Codec.Evm.Utils.WORD_SIZE);\n      return \"  0x\".concat(address, \":  \").concat(truffleColors.pink(data));\n    });\n    formatted.unshift(formattedSelector);\n    return formatted.join(OS.EOL);\n  },\n  formatValue: function (value, indent = 0, nativized = false) {\n    let inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    let valueToInspect = nativized ? value : new Codec.Export.ResultInspector(value);\n    return util.inspect(valueToInspect, inspectOptions).split(/\\r?\\n/g).map((line, i) => {\n      // don't indent first line\n      const padding = i > 0 ? Array(indent).join(\" \") : \"\";\n      return padding + line;\n    }).join(OS.EOL);\n  },\n  //note: only intended to be used for *custom* errors :)\n  formatCustomError: function (decoding, indent = 0) {\n    const inspectOptions = {\n      colors: true,\n      depth: null,\n      maxArrayLength: null,\n      breakLength: 30\n    };\n    const name = decoding.definedIn ? \"\".concat(decoding.definedIn.typeName, \".\").concat(decoding.abi.name) : decoding.abi.name;\n    return Codec.Export.formatFunctionLike(name, decoding.arguments, inspectOptions, false, indent);\n  },\n  formatStacktrace: function (stacktrace, indent = 2) {\n    //get message or panic code from stacktrace\n    const _stacktrace$ = stacktrace[0],\n          message = _stacktrace$.message,\n          panic = _stacktrace$.panic,\n          custom = _stacktrace$.custom; //we want to print inner to outer, so first, let's\n    //reverse\n\n    stacktrace = stacktrace.slice().reverse(); //reverse is in-place so clone first\n\n    let lines = stacktrace.map(({\n      functionName,\n      contractName,\n      address,\n      location,\n      type\n    }) => {\n      let name;\n\n      if (contractName && functionName) {\n        name = \"\".concat(contractName, \".\").concat(functionName);\n      } else if (contractName) {\n        name = contractName;\n      } else if (functionName) {\n        name = functionName;\n      } else {\n        name = \"unknown function\";\n      }\n\n      let locationString;\n\n      if (location) {\n        let sourcePath = location.source.sourcePath,\n            _location$sourceRange = location.sourceRange.lines.start,\n            line = _location$sourceRange.line,\n            column = _location$sourceRange.column;\n        locationString = sourcePath ? \"\".concat(sourcePath, \":\").concat(line + 1, \":\").concat(column + 1) //add 1 to account for 0-indexing\n        : \"unknown location\";\n      } else {\n        locationString = \"unknown location\";\n      }\n\n      let addressString = type === \"external\" ? address !== undefined ? \" [address \".concat(address, \"]\") : \" [unknown address]\" : \"\";\n      return \"at \".concat(name).concat(addressString, \" (\").concat(locationString, \")\");\n    });\n    let status = stacktrace[0].status;\n\n    if (status != undefined) {\n      let statusLine;\n\n      if (message !== undefined) {\n        statusLine = status ? \"Error: Improper return (caused message: \".concat(message, \")\") : \"Error: Revert (message: \".concat(message, \")\");\n      } else if (panic !== undefined) {\n        statusLine = status ? \"Panic: Improper return (caused \".concat(DebugUtils.panicString(panic).toLowerCase(), \" (code 0x\").concat(panic.toString(16), \"))\") : \"Panic: \".concat(DebugUtils.panicString(panic), \" (code 0x\").concat(panic.toString(16), \")\");\n      } else if (custom !== undefined) {\n        statusLine = status ? \"Error: Improper return (caused custom error)\" : \"Error: Revert (custom error)\";\n      } else {\n        statusLine = status ? \"Error: Improper return (may be an unexpected self-destruct)\" : \"Error: Revert or exceptional halt\";\n      }\n\n      lines.unshift(statusLine);\n    }\n\n    let indented = lines.map((line, index) => index === 0 ? line : \" \".repeat(indent) + line);\n    return indented.join(OS.EOL);\n  },\n  colorize: function (code, language = \"Solidity\") {\n    const options = {\n      lang: \"solidity\",\n      colors: trufflePalette,\n      //we want to turn off basically everything else, as we're\n      //handling padding & numbering manually\n      lineNumbers: false,\n      stripIndent: false,\n      codePad: 0,\n      tabsToSpaces: false,\n      //we handle this ourself and don't\n      //want chromafi's padding\n      lineEndPad: false\n    };\n\n    switch (language) {\n      case \"Solidity\":\n        return chromafi(code, options);\n\n      case \"Yul\":\n        options.lang = \"yul\"; //registered along with Solidity :)\n\n        return chromafi(code, options);\n\n      case \"Vyper\":\n        options.lang = \"python\"; //HACK -- close enough for now!\n\n        return chromafi(code, options);\n\n      default:\n        //don't highlight\n        return code;\n    }\n  },\n  //HACK\n  cleanThis: function (variables, replacement) {\n    return Object.assign({}, ...Object.entries(variables).map(([variable, value]) => variable === \"this\" ? {\n      [replacement]: value\n    } : {\n      [variable]: value\n    }));\n  },\n\n  /**\n   * HACK warning!  This function modifies the debugger state\n   * and should only be used in light mode, at startup, in a very specific way!\n   *\n   * let bugger = await Debugger.forTx(txHash, { lightMode: true, ... });\n   * const sources = await getTransactionSourcesBeforeStarting(bugger);\n   * await bugger.startFullMode();\n   *\n   * Don't go switching transactions after doing this, because there's no\n   * way at the moment to switch back into light mode in order to re-run\n   * this function.  You do *not* want to run this in full mode.\n   */\n  getTransactionSourcesBeforeStarting: async function (bugger) {\n    await bugger.reset();\n    let sources = {};\n    const controller = bugger.selectors.controller;\n\n    while (!bugger.view(controller.current.trace.finished)) {\n      const source = bugger.view(controller.current.location.source);\n      const compilationId = source.compilationId,\n            id = source.id,\n            internal = source.internal; //stepInto should skip internal sources, but there still might be\n      //one at the end\n\n      if (!internal && compilationId !== undefined && id !== undefined) {\n        sources[compilationId] = { ...sources[compilationId],\n          [id]: source\n        };\n      }\n\n      await bugger.stepInto();\n    }\n\n    await bugger.reset(); //flatten sources before returning\n\n    return [].concat(...Object.values(sources).map(Object.values));\n  }\n};\nmodule.exports = DebugUtils;","map":null,"metadata":{},"sourceType":"script"}