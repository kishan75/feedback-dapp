{"ast":null,"code":"'use strict';\n\nconst stream = require('stream');\n\nconst util = require('util');\n/**\n * NoFilter stream.  Can be used to sink or source data to and from\n * other node streams.  Implemented as the \"identity\" Transform stream\n * (hence the name), but allows for inspecting data that is in-flight.\n *\n * Allows passing in source data (input, inputEncoding) at creation\n * time.  Source data can also be passed in the options object.\n *\n * @example <caption>source</caption>\n * const n = new NoFilter('Zm9v', 'base64');\n * n.pipe(process.stdout);\n *\n * @example <caption>sink</caption>\n * const n = new Nofilter();\n * // NOTE: 'finish' fires when the input is done writing\n * n.on('finish', function() { console.log(n.toString('base64')); });\n * process.stdin.pipe(n);\n */\n\n\nclass NoFilter extends stream.Transform {\n  /**\n   * Create an instance of NoFilter.\n   *\n   * @param {string|Buffer} [input] - Source data\n   * @param {string} [inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {Object} [options={}] - Other options\n   * @param {string|Buffer} [options.input=null] - Input source data\n   * @param {string} [options.inputEncoding=null] - Encoding name for input,\n   *   ignored if input is not a String\n   * @param {number} [options.highWaterMark=16384] - The maximum number of bytes\n   *   to store in the internal buffer before ceasing to read from the\n   *   underlying resource. Default=16kb, or 16 for objectMode streams\n   * @param {string} [options.encoding=null] - If specified, then buffers will\n   *   be decoded to strings using the specified encoding\n   * @param {boolean} [options.objectMode=false] - Whether this stream should\n   *   behave as a stream of objects. Meaning that stream.read(n) returns a\n   *   single value instead of a Buffer of size n\n   * @param {boolean} [options.decodeStrings=true] - Whether or not to decode\n   *   strings into Buffers before passing them to _write()\n   * @param {boolean} [options.watchPipe=true] - Whether to watch for 'pipe'\n   *   events, setting this stream's objectMode based on the objectMode of the\n   *   input stream\n   * @param {boolean} [options.readError=false] - If true, when a read()\n   *   underflows, throw an error.\n   */\n  constructor(input, inputEncoding, options) {\n    if (options == null) {\n      options = {};\n    }\n\n    let inp;\n    let inpE;\n\n    switch (typeof input) {\n      case 'object':\n        if (Buffer.isBuffer(input)) {\n          inp = input;\n\n          if (inputEncoding != null && typeof inputEncoding === 'object') {\n            options = inputEncoding;\n          }\n        } else {\n          options = input;\n        }\n\n        break;\n\n      case 'string':\n        inp = input;\n\n        if (inputEncoding != null && typeof inputEncoding === 'object') {\n          options = inputEncoding;\n        } else {\n          inpE = inputEncoding;\n        }\n\n        break;\n    }\n\n    if (options == null) {\n      options = {};\n    }\n\n    if (inp == null) {\n      inp = options.input;\n    }\n\n    if (inpE == null) {\n      inpE = options.inputEncoding;\n    }\n\n    delete options.input;\n    delete options.inputEncoding;\n    const watchPipe = options.watchPipe != null ? options.watchPipe : true;\n    delete options.watchPipe;\n    const readError = !!options.readError;\n    delete options.readError;\n    super(options);\n    this.readError = readError;\n\n    if (watchPipe) {\n      this.on('pipe', readable => {\n        const om = readable._readableState.objectMode;\n\n        if (this.length > 0 && om !== this._readableState.objectMode) {\n          throw new Error('Do not switch objectMode in the middle of the stream');\n        }\n\n        this._readableState.objectMode = om;\n        return this._writableState.objectMode = om;\n      });\n    }\n\n    if (inp != null) {\n      this.end(inp, inpE);\n    }\n  }\n  /**\n   * Is the given object a {NoFilter}?\n   *\n   * @param {Object} obj The object to test.\n   * @returns {boolean} true if obj is a NoFilter\n   */\n\n\n  static isNoFilter(obj) {\n    return obj instanceof this;\n  }\n  /**\n   * The same as nf1.compare(nf2). Useful for sorting an Array of NoFilters.\n   *\n   * @param {NoFilter} nf1 - The first object to compare\n   * @param {NoFilter} nf2 - The second object to compare\n   * @returns {number} -1, 0, 1 for less, equal, greater\n   *\n   * @example\n   * const arr = [new NoFilter('1234'), new NoFilter('0123')];\n   * arr.sort(NoFilter.compare);\n   */\n\n\n  static compare(nf1, nf2) {\n    if (!(nf1 instanceof this)) {\n      throw new TypeError('Arguments must be NoFilters');\n    }\n\n    if (nf1 === nf2) {\n      return 0;\n    } else {\n      return nf1.compare(nf2);\n    }\n  }\n  /**\n   * Returns a buffer which is the result of concatenating all the\n   * NoFilters in the list together. If the list has no items, or if\n   * the totalLength is 0, then it returns a zero-length buffer.\n   *\n   * If length is not provided, it is read from the buffers in the\n   * list. However, this adds an additional loop to the function, so\n   * it is faster to provide the length explicitly if you already know it.\n   *\n   * @param {Array<NoFilter>} list Inputs.  Must not be all either in object\n   *   mode, or all not in object mode.\n   * @param {number} [length=null] Number of bytes or objects to read\n   * @returns {Buffer|Array} The concatenated values as an array if in object\n   *   mode, otherwise a Buffer\n   */\n\n\n  static concat(list, length) {\n    if (!Array.isArray(list)) {\n      throw new TypeError('list argument must be an Array of NoFilters');\n    }\n\n    if (list.length === 0 || length === 0) {\n      return Buffer.alloc(0);\n    }\n\n    if (length == null) {\n      length = list.reduce((tot, nf) => {\n        if (!(nf instanceof NoFilter)) {\n          throw new TypeError('list argument must be an Array of NoFilters');\n        }\n\n        return tot + nf.length;\n      }, 0);\n    }\n\n    let allBufs = true;\n    let allObjs = true;\n    const bufs = list.map(nf => {\n      if (!(nf instanceof NoFilter)) {\n        throw new TypeError('list argument must be an Array of NoFilters');\n      }\n\n      const buf = nf.slice();\n\n      if (Buffer.isBuffer(buf)) {\n        allObjs = false;\n      } else {\n        allBufs = false;\n      }\n\n      return buf;\n    });\n\n    if (allBufs) {\n      return Buffer.concat(bufs, length);\n    }\n\n    if (allObjs) {\n      return [].concat(...bufs).slice(0, length);\n    } // TODO: maybe coalesce buffers, counting bytes, and flatten in arrays\n    // counting objects?  I can't imagine why that would be useful.\n\n\n    throw new Error('Concatenating mixed object and byte streams not supported');\n  }\n  /**\n   * @private\n   */\n\n\n  _transform(chunk, encoding, callback) {\n    if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {\n      chunk = Buffer.from(chunk, encoding);\n    }\n\n    this.push(chunk);\n    callback();\n  }\n  /**\n   * @private\n   */\n\n\n  _bufArray() {\n    let bufs = this._readableState.buffer; // HACK: replace with something else one day.  This is what I get for\n    // relying on internals.\n\n    if (!Array.isArray(bufs)) {\n      let b = bufs.head;\n      bufs = [];\n\n      while (b != null) {\n        bufs.push(b.data);\n        b = b.next;\n      }\n    }\n\n    return bufs;\n  }\n  /**\n   * Pulls some data out of the internal buffer and returns it.\n   * If there is no data available, then it will return null.\n   *\n   * If you pass in a size argument, then it will return that many bytes. If\n   * size bytes are not available, then it will return null, unless we've\n   * ended, in which case it will return the data remaining in the buffer.\n   *\n   * If you do not specify a size argument, then it will return all the data in\n   * the internal buffer.\n   *\n   * @param {number} [size=null] - Number of bytes to read.\n   * @returns {string|Buffer|null} If no data or not enough data, null.  If\n   *   decoding output a string, otherwise a Buffer\n   * @throws Error - if readError is true and there was underflow\n   * @fires NoFilter#read\n   */\n\n\n  read(size) {\n    const buf = super.read(size);\n\n    if (buf != null) {\n      /*\n       * Read event. Fired whenever anything is read from the stream.\n       *\n       * @event NoFilter#read\n       * @type {Buffer|string|Object}\n       *\n       */\n      this.emit('read', buf);\n\n      if (this.readError && buf.length < size) {\n        throw new Error(\"Read \".concat(buf.length, \", wanted \").concat(size));\n      }\n    } else if (this.readError) {\n      throw new Error(\"No data available, wanted \".concat(size));\n    }\n\n    return buf;\n  }\n  /**\n   * Return a promise fulfilled with the full contents, after the 'finish'\n   * event fires.  Errors on the stream cause the promise to be rejected.\n   *\n   * @param {function} [cb=null] - finished/error callback used in *addition*\n   *   to the promise\n   * @returns {Promise<Buffer|String>} fulfilled when complete\n   */\n\n\n  promise(cb) {\n    let done = false;\n    return new Promise((resolve, reject) => {\n      this.on('finish', () => {\n        const data = this.read();\n\n        if (cb != null && !done) {\n          done = true;\n          cb(null, data);\n        }\n\n        resolve(data);\n      });\n      this.on('error', er => {\n        if (cb != null && !done) {\n          done = true;\n          cb(er);\n        }\n\n        reject(er);\n      });\n    });\n  }\n  /**\n   * Returns a number indicating whether this comes before or after or is the\n   * same as the other NoFilter in sort order.\n   *\n   * @param {NoFilter} other - The other object to compare\n   * @returns {Number} -1, 0, 1 for less, equal, greater\n   */\n\n\n  compare(other) {\n    if (!(other instanceof NoFilter)) {\n      throw new TypeError('Arguments must be NoFilters');\n    }\n\n    if (this === other) {\n      return 0;\n    } else {\n      const buf1 = this.slice();\n      const buf2 = other.slice(); // these will both be buffers because of the check above.\n\n      if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {\n        return buf1.compare(buf2);\n      }\n\n      throw new Error('Cannot compare streams in object mode');\n    }\n  }\n  /**\n   * Do these NoFilter's contain the same bytes?  Doesn't work if either is\n   * in object mode.\n   *\n   * @param {NoFilter} other\n   * @returns {boolean} Equal?\n   */\n\n\n  equals(other) {\n    return this.compare(other) === 0;\n  }\n  /**\n   * Read bytes or objects without consuming them.  Useful for diagnostics.\n   * Note: as a side-effect, concatenates multiple writes together into what\n   * looks like a single write, so that this concat doesn't have to happen\n   * multiple times when you're futzing with the same NoFilter.\n   *\n   * @param {Number} [start=0] - beginning offset\n   * @param {Number} [end=length] - ending offset\n   * @returns {Buffer|Array} if in object mode, an array of objects.  Otherwise,\n   *   concatenated array of contents.\n   */\n\n\n  slice(start, end) {\n    if (this._readableState.objectMode) {\n      return this._bufArray().slice(start, end);\n    }\n\n    const bufs = this._bufArray();\n\n    switch (bufs.length) {\n      case 0:\n        return Buffer.alloc(0);\n\n      case 1:\n        return bufs[0].slice(start, end);\n\n      default:\n        const b = Buffer.concat(bufs); // TODO: store the concatented bufs back\n        // @_readableState.buffer = [b]\n\n        return b.slice(start, end);\n    }\n  }\n  /**\n    * Get a byte by offset.  I didn't want to get into metaprogramming\n    * to give you the `NoFilter[0]` syntax.\n    *\n    * @param {Number} index - The byte to retrieve\n    * @returns {Number} 0-255\n    */\n\n\n  get(index) {\n    return this.slice()[index];\n  }\n  /**\n   * Return an object compatible with Buffer's toJSON implementation, so\n   * that round-tripping will produce a Buffer.\n   *\n   * @returns {Object}\n   *\n   * @example output for 'foo'\n   *   { type: 'Buffer', data: [ 102, 111, 111 ] }\n   */\n\n\n  toJSON() {\n    const b = this.slice();\n\n    if (Buffer.isBuffer(b)) {\n      return b.toJSON();\n    } else {\n      return b;\n    }\n  }\n  /**\n   * Decodes and returns a string from buffer data encoded using the specified\n   * character set encoding. If encoding is undefined or null, then encoding\n   * defaults to 'utf8'. The start and end parameters default to 0 and\n   * NoFilter.length when undefined.\n   *\n   * @param {String} [encoding='utf8'] - Which to use for decoding?\n   * @param {Number} [start=0] - Start offset\n   * @param {Number} [end=length] - End offset\n   * @returns {String}\n   */\n\n\n  toString(encoding, start, end) {\n    const buf = this.slice(start, end);\n\n    if (!Buffer.isBuffer(buf)) {\n      return JSON.stringify(buf);\n    }\n\n    if ((!encoding || encoding === 'utf8') && util.TextDecoder) {\n      const td = new util.TextDecoder('utf8', {\n        fatal: true,\n        ignoreBOM: true\n      });\n      return td.decode(buf);\n    }\n\n    return buf.toString(encoding, start, end);\n  }\n  /**\n   * @private\n   * @deprecated\n   */\n\n\n  inspect(depth, options) {\n    return this[util.inspect.custom](depth, options);\n  }\n  /**\n   * @private\n   */\n\n\n  [util.inspect.custom](depth, options) {\n    const bufs = this._bufArray();\n\n    const hex = bufs.map(b => {\n      if (Buffer.isBuffer(b)) {\n        if (options != null ? options.stylize : undefined) {\n          return options.stylize(b.toString('hex'), 'string');\n        } else {\n          return b.toString('hex');\n        }\n      } else {\n        return util.inspect(b, options);\n      }\n    }).join(', ');\n    return \"\".concat(this.constructor.name, \" [\").concat(hex, \"]\");\n  }\n  /**\n   * Current readable length, in bytes.\n   *\n   * @member {number}\n   * @readonly\n   */\n\n\n  get length() {\n    return this._readableState.length;\n  }\n  /**\n   * Write a JavaScript BigInt to the stream.  Negative numbers will be\n   * written as their 2's complement version.\n   *\n   * @param {bigint} val - The value to write\n   * @returns {boolean} true on success\n   */\n\n\n  writeBigInt(val) {\n    let str = val.toString(16);\n\n    if (val < 0) {\n      // two's complement\n      // Note: str always starts with '-' here.\n      const sz = BigInt(Math.floor(str.length / 2));\n      const mask = BigInt(1) << sz * BigInt(8);\n      val = mask + val;\n      str = val.toString(16);\n    }\n\n    if (str.length % 2) {\n      str = '0' + str;\n    }\n\n    return this.push(Buffer.from(str, 'hex'));\n  }\n  /**\n   * Read a variable-sized JavaScript unsigned BigInt from the stream.\n   *\n   * @param {number}  [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n\n\n  readUBigInt(len) {\n    const b = this.read(len);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return BigInt('0x' + b.toString('hex'));\n  }\n  /**\n   * Read a variable-sized JavaScript signed BigInt from the stream in 2's\n   * complement format.\n   *\n   * @param {number} [len=null] - number of bytes to read or all remaining\n   *   if null\n   * @returns {bigint}\n   */\n\n\n  readBigInt(len) {\n    const b = this.read(len);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    let ret = BigInt('0x' + b.toString('hex')); // negative?\n\n    if (b[0] & 0x80) {\n      // two's complement\n      const mask = BigInt(1) << BigInt(b.length) * BigInt(8);\n      ret = ret - mask;\n    }\n\n    return ret;\n  }\n\n}\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\n\n\nfunction _read_gen(meth, len) {\n  return function (val) {\n    const b = this.read(len);\n\n    if (!Buffer.isBuffer(b)) {\n      return null;\n    }\n\n    return b[meth].call(b, 0, true);\n  };\n}\n/**\n * @param {string} meth - method to call\n * @param {number} len - number of bytes to write\n * @private\n */\n\n\nfunction _write_gen(meth, len) {\n  return function (val) {\n    const b = Buffer.alloc(len);\n    b[meth].call(b, val, 0, true);\n    return this.push(b);\n  };\n}\n\nObject.assign(NoFilter.prototype, {\n  /**\n   * Write an 8-bit unsigned integer to the stream.  Adds 1 byte.\n   *\n   * @function writeUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value - 0-255\n   * @returns {boolean} true on success\n   */\n  writeUInt8: _write_gen('writeUInt8', 1),\n\n  /**\n   * Write a little-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16LE: _write_gen('writeUInt16LE', 2),\n\n  /**\n   * Write a big-endian 16-bit unsigned integer to the stream.  Adds\n   * 2 bytes.\n   *\n   * @function writeUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt16BE: _write_gen('writeUInt16BE', 2),\n\n  /**\n   * Write a little-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32LE: _write_gen('writeUInt32LE', 4),\n\n  /**\n   * Write a big-endian 32-bit unsigned integer to the stream.  Adds\n   * 4 bytes.\n   *\n   * @function writeUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeUInt32BE: _write_gen('writeUInt32BE', 4),\n\n  /**\n   * Write a signed 8-bit integer to the stream.  Adds 1 byte.\n   *\n   * @function writeInt8\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt8: _write_gen('writeInt8', 1),\n\n  /**\n   * Write a signed little-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16LE: _write_gen('writeInt16LE', 2),\n\n  /**\n   * Write a signed big-endian 16-bit integer to the stream.  Adds 2 bytes.\n   *\n   * @function writeInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt16BE: _write_gen('writeInt16BE', 2),\n\n  /**\n   * Write a signed little-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32LE: _write_gen('writeInt32LE', 4),\n\n  /**\n   * Write a signed big-endian 32-bit integer to the stream.  Adds 4 bytes.\n   *\n   * @function writeInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeInt32BE: _write_gen('writeInt32BE', 4),\n\n  /**\n   * Write a little-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatLE: _write_gen('writeFloatLE', 4),\n\n  /**\n   * Write a big-endian 32-bit float to the stream.  Adds 4 bytes.\n   *\n   * @function writeFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeFloatBE: _write_gen('writeFloatBE', 4),\n\n  /**\n   * Write a little-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleLE: _write_gen('writeDoubleLE', 8),\n\n  /**\n   * Write a big-endian 64-bit float to the stream.  Adds 8 bytes.\n   *\n   * @function writeDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @param {Number} value\n   * @returns {boolean} true on success\n   */\n  writeDoubleBE: _write_gen('writeDoubleBE', 8),\n\n  /**\n   * Read an unsigned 8-bit integer from the stream.  Consumes 1 byte.\n   *\n   * @function readUInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt8: _read_gen('readUInt8', 1),\n\n  /**\n   * Read a little-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16LE: _read_gen('readUInt16LE', 2),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readUInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt16BE: _read_gen('readUInt16BE', 2),\n\n  /**\n   * Read a little-endian unsigned 32-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32LE: _read_gen('readUInt32LE', 4),\n\n  /**\n   * Read a big-endian unsigned 16-bit integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readUInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readUInt32BE: _read_gen('readUInt32BE', 4),\n\n  /**\n   * Read a signed 8-bit integer from the stream.\n   * Consumes 1 byte.\n   *\n   * @function readInt8\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt8: _read_gen('readInt8', 1),\n\n  /**\n   * Read a signed 16-bit little-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16LE: _read_gen('readInt16LE', 2),\n\n  /**\n   * Read a signed 16-bit big-endian integer from the stream.\n   * Consumes 2 bytes.\n   *\n   * @function readInt16BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt16BE: _read_gen('readInt16BE', 2),\n\n  /**\n   * Read a signed 32-bit little-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32LE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32LE: _read_gen('readInt32LE', 4),\n\n  /**\n   * Read a signed 32-bit big-endian integer from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readInt32BE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readInt32BE: _read_gen('readInt32BE', 4),\n\n  /**\n   * Read a 32-bit little-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatLE: _read_gen('readFloatLE', 4),\n\n  /**\n   * Read a 32-bit big-endian float from the stream.\n   * Consumes 4 bytes.\n   *\n   * @function readFloatBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readFloatBE: _read_gen('readFloatBE', 4),\n\n  /**\n   * Read a 64-bit little-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleLE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleLE: _read_gen('readDoubleLE', 8),\n\n  /**\n   * Read a 64-bit big-endian float from the stream.\n   * Consumes 8 bytes.\n   *\n   * @function readDoubleBE\n   * @memberOf NoFilter\n   * @instance\n   * @returns {Number} value\n   */\n  readDoubleBE: _read_gen('readDoubleBE', 8)\n});\nmodule.exports = NoFilter;","map":null,"metadata":{},"sourceType":"script"}